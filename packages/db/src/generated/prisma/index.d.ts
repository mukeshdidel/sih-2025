
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model DoctorPatient
 * 
 */
export type DoctorPatient = $Result.DefaultSelection<Prisma.$DoctorPatientPayload>
/**
 * Model Cuisine
 * 
 */
export type Cuisine = $Result.DefaultSelection<Prisma.$CuisinePayload>
/**
 * Model Food
 * 
 */
export type Food = $Result.DefaultSelection<Prisma.$FoodPayload>
/**
 * Model Nutrient
 * 
 */
export type Nutrient = $Result.DefaultSelection<Prisma.$NutrientPayload>
/**
 * Model Rasa
 * 
 */
export type Rasa = $Result.DefaultSelection<Prisma.$RasaPayload>
/**
 * Model Guna
 * 
 */
export type Guna = $Result.DefaultSelection<Prisma.$GunaPayload>
/**
 * Model Dosha
 * 
 */
export type Dosha = $Result.DefaultSelection<Prisma.$DoshaPayload>
/**
 * Model Virya
 * 
 */
export type Virya = $Result.DefaultSelection<Prisma.$ViryaPayload>
/**
 * Model Vipaka
 * 
 */
export type Vipaka = $Result.DefaultSelection<Prisma.$VipakaPayload>
/**
 * Model Digestibility
 * 
 */
export type Digestibility = $Result.DefaultSelection<Prisma.$DigestibilityPayload>
/**
 * Model Rda
 * 
 */
export type Rda = $Result.DefaultSelection<Prisma.$RdaPayload>
/**
 * Model FoodNutrient
 * 
 */
export type FoodNutrient = $Result.DefaultSelection<Prisma.$FoodNutrientPayload>
/**
 * Model FoodRasa
 * 
 */
export type FoodRasa = $Result.DefaultSelection<Prisma.$FoodRasaPayload>
/**
 * Model FoodGuna
 * 
 */
export type FoodGuna = $Result.DefaultSelection<Prisma.$FoodGunaPayload>
/**
 * Model FoodDosha
 * 
 */
export type FoodDosha = $Result.DefaultSelection<Prisma.$FoodDoshaPayload>
/**
 * Model PatientDosha
 * 
 */
export type PatientDosha = $Result.DefaultSelection<Prisma.$PatientDoshaPayload>
/**
 * Model FoodVirya
 * 
 */
export type FoodVirya = $Result.DefaultSelection<Prisma.$FoodViryaPayload>
/**
 * Model FoodVipaka
 * 
 */
export type FoodVipaka = $Result.DefaultSelection<Prisma.$FoodVipakaPayload>
/**
 * Model FoodDigestibility
 * 
 */
export type FoodDigestibility = $Result.DefaultSelection<Prisma.$FoodDigestibilityPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeIngredient
 * 
 */
export type RecipeIngredient = $Result.DefaultSelection<Prisma.$RecipeIngredientPayload>
/**
 * Model DietChart
 * 
 */
export type DietChart = $Result.DefaultSelection<Prisma.$DietChartPayload>
/**
 * Model DietChartRecipe
 * 
 */
export type DietChartRecipe = $Result.DefaultSelection<Prisma.$DietChartRecipePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DietaryHabits: {
  VEGETARIAN: 'VEGETARIAN',
  VEGAN: 'VEGAN',
  NON_VEGETARIAN: 'NON_VEGETARIAN',
  EGGITARIAN: 'EGGITARIAN'
};

export type DietaryHabits = (typeof DietaryHabits)[keyof typeof DietaryHabits]


export const BowelMovement: {
  REGULAR: 'REGULAR',
  CONSTIPATED: 'CONSTIPATED',
  LOOSE: 'LOOSE'
};

export type BowelMovement = (typeof BowelMovement)[keyof typeof BowelMovement]


export const DigestionQuality: {
  EXCELLENT: 'EXCELLENT',
  GOOD: 'GOOD',
  AVERAGE: 'AVERAGE',
  POOR: 'POOR'
};

export type DigestionQuality = (typeof DigestionQuality)[keyof typeof DigestionQuality]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const AgeGroup: {
  INFANT: 'INFANT',
  CHILD: 'CHILD',
  ADOLESCENT: 'ADOLESCENT',
  ADULT: 'ADULT',
  SENIOR: 'SENIOR'
};

export type AgeGroup = (typeof AgeGroup)[keyof typeof AgeGroup]


export const MealTime: {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  SNACKS: 'SNACKS',
  DINNER: 'DINNER'
};

export type MealTime = (typeof MealTime)[keyof typeof MealTime]

}

export type DietaryHabits = $Enums.DietaryHabits

export const DietaryHabits: typeof $Enums.DietaryHabits

export type BowelMovement = $Enums.BowelMovement

export const BowelMovement: typeof $Enums.BowelMovement

export type DigestionQuality = $Enums.DigestionQuality

export const DigestionQuality: typeof $Enums.DigestionQuality

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type AgeGroup = $Enums.AgeGroup

export const AgeGroup: typeof $Enums.AgeGroup

export type MealTime = $Enums.MealTime

export const MealTime: typeof $Enums.MealTime

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Doctors
 * const doctors = await prisma.doctor.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Doctors
   * const doctors = await prisma.doctor.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctorPatient`: Exposes CRUD operations for the **DoctorPatient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorPatients
    * const doctorPatients = await prisma.doctorPatient.findMany()
    * ```
    */
  get doctorPatient(): Prisma.DoctorPatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cuisine`: Exposes CRUD operations for the **Cuisine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuisines
    * const cuisines = await prisma.cuisine.findMany()
    * ```
    */
  get cuisine(): Prisma.CuisineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **Food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.FoodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutrient`: Exposes CRUD operations for the **Nutrient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nutrients
    * const nutrients = await prisma.nutrient.findMany()
    * ```
    */
  get nutrient(): Prisma.NutrientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rasa`: Exposes CRUD operations for the **Rasa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rasas
    * const rasas = await prisma.rasa.findMany()
    * ```
    */
  get rasa(): Prisma.RasaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guna`: Exposes CRUD operations for the **Guna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gunas
    * const gunas = await prisma.guna.findMany()
    * ```
    */
  get guna(): Prisma.GunaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dosha`: Exposes CRUD operations for the **Dosha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doshas
    * const doshas = await prisma.dosha.findMany()
    * ```
    */
  get dosha(): Prisma.DoshaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virya`: Exposes CRUD operations for the **Virya** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viryas
    * const viryas = await prisma.virya.findMany()
    * ```
    */
  get virya(): Prisma.ViryaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vipaka`: Exposes CRUD operations for the **Vipaka** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vipakas
    * const vipakas = await prisma.vipaka.findMany()
    * ```
    */
  get vipaka(): Prisma.VipakaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.digestibility`: Exposes CRUD operations for the **Digestibility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Digestibilities
    * const digestibilities = await prisma.digestibility.findMany()
    * ```
    */
  get digestibility(): Prisma.DigestibilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rda`: Exposes CRUD operations for the **Rda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rdas
    * const rdas = await prisma.rda.findMany()
    * ```
    */
  get rda(): Prisma.RdaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodNutrient`: Exposes CRUD operations for the **FoodNutrient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodNutrients
    * const foodNutrients = await prisma.foodNutrient.findMany()
    * ```
    */
  get foodNutrient(): Prisma.FoodNutrientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodRasa`: Exposes CRUD operations for the **FoodRasa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodRasas
    * const foodRasas = await prisma.foodRasa.findMany()
    * ```
    */
  get foodRasa(): Prisma.FoodRasaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodGuna`: Exposes CRUD operations for the **FoodGuna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodGunas
    * const foodGunas = await prisma.foodGuna.findMany()
    * ```
    */
  get foodGuna(): Prisma.FoodGunaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodDosha`: Exposes CRUD operations for the **FoodDosha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodDoshas
    * const foodDoshas = await prisma.foodDosha.findMany()
    * ```
    */
  get foodDosha(): Prisma.FoodDoshaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientDosha`: Exposes CRUD operations for the **PatientDosha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientDoshas
    * const patientDoshas = await prisma.patientDosha.findMany()
    * ```
    */
  get patientDosha(): Prisma.PatientDoshaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodVirya`: Exposes CRUD operations for the **FoodVirya** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodViryas
    * const foodViryas = await prisma.foodVirya.findMany()
    * ```
    */
  get foodVirya(): Prisma.FoodViryaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodVipaka`: Exposes CRUD operations for the **FoodVipaka** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodVipakas
    * const foodVipakas = await prisma.foodVipaka.findMany()
    * ```
    */
  get foodVipaka(): Prisma.FoodVipakaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodDigestibility`: Exposes CRUD operations for the **FoodDigestibility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodDigestibilities
    * const foodDigestibilities = await prisma.foodDigestibility.findMany()
    * ```
    */
  get foodDigestibility(): Prisma.FoodDigestibilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeIngredient`: Exposes CRUD operations for the **RecipeIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeIngredients
    * const recipeIngredients = await prisma.recipeIngredient.findMany()
    * ```
    */
  get recipeIngredient(): Prisma.RecipeIngredientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dietChart`: Exposes CRUD operations for the **DietChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietCharts
    * const dietCharts = await prisma.dietChart.findMany()
    * ```
    */
  get dietChart(): Prisma.DietChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dietChartRecipe`: Exposes CRUD operations for the **DietChartRecipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietChartRecipes
    * const dietChartRecipes = await prisma.dietChartRecipe.findMany()
    * ```
    */
  get dietChartRecipe(): Prisma.DietChartRecipeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Doctor: 'Doctor',
    Patient: 'Patient',
    DoctorPatient: 'DoctorPatient',
    Cuisine: 'Cuisine',
    Food: 'Food',
    Nutrient: 'Nutrient',
    Rasa: 'Rasa',
    Guna: 'Guna',
    Dosha: 'Dosha',
    Virya: 'Virya',
    Vipaka: 'Vipaka',
    Digestibility: 'Digestibility',
    Rda: 'Rda',
    FoodNutrient: 'FoodNutrient',
    FoodRasa: 'FoodRasa',
    FoodGuna: 'FoodGuna',
    FoodDosha: 'FoodDosha',
    PatientDosha: 'PatientDosha',
    FoodVirya: 'FoodVirya',
    FoodVipaka: 'FoodVipaka',
    FoodDigestibility: 'FoodDigestibility',
    Recipe: 'Recipe',
    RecipeIngredient: 'RecipeIngredient',
    DietChart: 'DietChart',
    DietChartRecipe: 'DietChartRecipe'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "doctor" | "patient" | "doctorPatient" | "cuisine" | "food" | "nutrient" | "rasa" | "guna" | "dosha" | "virya" | "vipaka" | "digestibility" | "rda" | "foodNutrient" | "foodRasa" | "foodGuna" | "foodDosha" | "patientDosha" | "foodVirya" | "foodVipaka" | "foodDigestibility" | "recipe" | "recipeIngredient" | "dietChart" | "dietChartRecipe"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      DoctorPatient: {
        payload: Prisma.$DoctorPatientPayload<ExtArgs>
        fields: Prisma.DoctorPatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorPatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorPatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          findFirst: {
            args: Prisma.DoctorPatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorPatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          findMany: {
            args: Prisma.DoctorPatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>[]
          }
          create: {
            args: Prisma.DoctorPatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          createMany: {
            args: Prisma.DoctorPatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorPatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>[]
          }
          delete: {
            args: Prisma.DoctorPatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          update: {
            args: Prisma.DoctorPatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          deleteMany: {
            args: Prisma.DoctorPatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorPatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorPatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>[]
          }
          upsert: {
            args: Prisma.DoctorPatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPatientPayload>
          }
          aggregate: {
            args: Prisma.DoctorPatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorPatient>
          }
          groupBy: {
            args: Prisma.DoctorPatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorPatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorPatientCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorPatientCountAggregateOutputType> | number
          }
        }
      }
      Cuisine: {
        payload: Prisma.$CuisinePayload<ExtArgs>
        fields: Prisma.CuisineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CuisineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuisineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          findFirst: {
            args: Prisma.CuisineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuisineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          findMany: {
            args: Prisma.CuisineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>[]
          }
          create: {
            args: Prisma.CuisineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          createMany: {
            args: Prisma.CuisineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CuisineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>[]
          }
          delete: {
            args: Prisma.CuisineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          update: {
            args: Prisma.CuisineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          deleteMany: {
            args: Prisma.CuisineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CuisineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CuisineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>[]
          }
          upsert: {
            args: Prisma.CuisineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          aggregate: {
            args: Prisma.CuisineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCuisine>
          }
          groupBy: {
            args: Prisma.CuisineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CuisineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CuisineCountArgs<ExtArgs>
            result: $Utils.Optional<CuisineCountAggregateOutputType> | number
          }
        }
      }
      Food: {
        payload: Prisma.$FoodPayload<ExtArgs>
        fields: Prisma.FoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findFirst: {
            args: Prisma.FoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findMany: {
            args: Prisma.FoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          create: {
            args: Prisma.FoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          createMany: {
            args: Prisma.FoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          delete: {
            args: Prisma.FoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          update: {
            args: Prisma.FoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          upsert: {
            args: Prisma.FoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFood>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
          }
        }
      }
      Nutrient: {
        payload: Prisma.$NutrientPayload<ExtArgs>
        fields: Prisma.NutrientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutrientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutrientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          findFirst: {
            args: Prisma.NutrientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutrientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          findMany: {
            args: Prisma.NutrientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>[]
          }
          create: {
            args: Prisma.NutrientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          createMany: {
            args: Prisma.NutrientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutrientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>[]
          }
          delete: {
            args: Prisma.NutrientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          update: {
            args: Prisma.NutrientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          deleteMany: {
            args: Prisma.NutrientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutrientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutrientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>[]
          }
          upsert: {
            args: Prisma.NutrientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutrientPayload>
          }
          aggregate: {
            args: Prisma.NutrientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutrient>
          }
          groupBy: {
            args: Prisma.NutrientGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutrientGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutrientCountArgs<ExtArgs>
            result: $Utils.Optional<NutrientCountAggregateOutputType> | number
          }
        }
      }
      Rasa: {
        payload: Prisma.$RasaPayload<ExtArgs>
        fields: Prisma.RasaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RasaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RasaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          findFirst: {
            args: Prisma.RasaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RasaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          findMany: {
            args: Prisma.RasaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>[]
          }
          create: {
            args: Prisma.RasaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          createMany: {
            args: Prisma.RasaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RasaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>[]
          }
          delete: {
            args: Prisma.RasaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          update: {
            args: Prisma.RasaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          deleteMany: {
            args: Prisma.RasaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RasaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RasaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>[]
          }
          upsert: {
            args: Prisma.RasaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RasaPayload>
          }
          aggregate: {
            args: Prisma.RasaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRasa>
          }
          groupBy: {
            args: Prisma.RasaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RasaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RasaCountArgs<ExtArgs>
            result: $Utils.Optional<RasaCountAggregateOutputType> | number
          }
        }
      }
      Guna: {
        payload: Prisma.$GunaPayload<ExtArgs>
        fields: Prisma.GunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          findFirst: {
            args: Prisma.GunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          findMany: {
            args: Prisma.GunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>[]
          }
          create: {
            args: Prisma.GunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          createMany: {
            args: Prisma.GunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>[]
          }
          delete: {
            args: Prisma.GunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          update: {
            args: Prisma.GunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          deleteMany: {
            args: Prisma.GunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>[]
          }
          upsert: {
            args: Prisma.GunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GunaPayload>
          }
          aggregate: {
            args: Prisma.GunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuna>
          }
          groupBy: {
            args: Prisma.GunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<GunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.GunaCountArgs<ExtArgs>
            result: $Utils.Optional<GunaCountAggregateOutputType> | number
          }
        }
      }
      Dosha: {
        payload: Prisma.$DoshaPayload<ExtArgs>
        fields: Prisma.DoshaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoshaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoshaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          findFirst: {
            args: Prisma.DoshaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoshaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          findMany: {
            args: Prisma.DoshaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>[]
          }
          create: {
            args: Prisma.DoshaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          createMany: {
            args: Prisma.DoshaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoshaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>[]
          }
          delete: {
            args: Prisma.DoshaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          update: {
            args: Prisma.DoshaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          deleteMany: {
            args: Prisma.DoshaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoshaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoshaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>[]
          }
          upsert: {
            args: Prisma.DoshaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoshaPayload>
          }
          aggregate: {
            args: Prisma.DoshaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDosha>
          }
          groupBy: {
            args: Prisma.DoshaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoshaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoshaCountArgs<ExtArgs>
            result: $Utils.Optional<DoshaCountAggregateOutputType> | number
          }
        }
      }
      Virya: {
        payload: Prisma.$ViryaPayload<ExtArgs>
        fields: Prisma.ViryaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViryaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViryaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          findFirst: {
            args: Prisma.ViryaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViryaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          findMany: {
            args: Prisma.ViryaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>[]
          }
          create: {
            args: Prisma.ViryaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          createMany: {
            args: Prisma.ViryaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViryaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>[]
          }
          delete: {
            args: Prisma.ViryaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          update: {
            args: Prisma.ViryaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          deleteMany: {
            args: Prisma.ViryaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViryaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViryaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>[]
          }
          upsert: {
            args: Prisma.ViryaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViryaPayload>
          }
          aggregate: {
            args: Prisma.ViryaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirya>
          }
          groupBy: {
            args: Prisma.ViryaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViryaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViryaCountArgs<ExtArgs>
            result: $Utils.Optional<ViryaCountAggregateOutputType> | number
          }
        }
      }
      Vipaka: {
        payload: Prisma.$VipakaPayload<ExtArgs>
        fields: Prisma.VipakaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VipakaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VipakaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          findFirst: {
            args: Prisma.VipakaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VipakaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          findMany: {
            args: Prisma.VipakaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>[]
          }
          create: {
            args: Prisma.VipakaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          createMany: {
            args: Prisma.VipakaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VipakaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>[]
          }
          delete: {
            args: Prisma.VipakaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          update: {
            args: Prisma.VipakaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          deleteMany: {
            args: Prisma.VipakaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VipakaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VipakaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>[]
          }
          upsert: {
            args: Prisma.VipakaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipakaPayload>
          }
          aggregate: {
            args: Prisma.VipakaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVipaka>
          }
          groupBy: {
            args: Prisma.VipakaGroupByArgs<ExtArgs>
            result: $Utils.Optional<VipakaGroupByOutputType>[]
          }
          count: {
            args: Prisma.VipakaCountArgs<ExtArgs>
            result: $Utils.Optional<VipakaCountAggregateOutputType> | number
          }
        }
      }
      Digestibility: {
        payload: Prisma.$DigestibilityPayload<ExtArgs>
        fields: Prisma.DigestibilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigestibilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigestibilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          findFirst: {
            args: Prisma.DigestibilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigestibilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          findMany: {
            args: Prisma.DigestibilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>[]
          }
          create: {
            args: Prisma.DigestibilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          createMany: {
            args: Prisma.DigestibilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DigestibilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>[]
          }
          delete: {
            args: Prisma.DigestibilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          update: {
            args: Prisma.DigestibilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          deleteMany: {
            args: Prisma.DigestibilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DigestibilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DigestibilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>[]
          }
          upsert: {
            args: Prisma.DigestibilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigestibilityPayload>
          }
          aggregate: {
            args: Prisma.DigestibilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDigestibility>
          }
          groupBy: {
            args: Prisma.DigestibilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<DigestibilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigestibilityCountArgs<ExtArgs>
            result: $Utils.Optional<DigestibilityCountAggregateOutputType> | number
          }
        }
      }
      Rda: {
        payload: Prisma.$RdaPayload<ExtArgs>
        fields: Prisma.RdaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RdaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RdaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          findFirst: {
            args: Prisma.RdaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RdaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          findMany: {
            args: Prisma.RdaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>[]
          }
          create: {
            args: Prisma.RdaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          createMany: {
            args: Prisma.RdaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RdaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>[]
          }
          delete: {
            args: Prisma.RdaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          update: {
            args: Prisma.RdaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          deleteMany: {
            args: Prisma.RdaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RdaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RdaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>[]
          }
          upsert: {
            args: Prisma.RdaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RdaPayload>
          }
          aggregate: {
            args: Prisma.RdaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRda>
          }
          groupBy: {
            args: Prisma.RdaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RdaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RdaCountArgs<ExtArgs>
            result: $Utils.Optional<RdaCountAggregateOutputType> | number
          }
        }
      }
      FoodNutrient: {
        payload: Prisma.$FoodNutrientPayload<ExtArgs>
        fields: Prisma.FoodNutrientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodNutrientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodNutrientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          findFirst: {
            args: Prisma.FoodNutrientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodNutrientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          findMany: {
            args: Prisma.FoodNutrientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>[]
          }
          create: {
            args: Prisma.FoodNutrientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          createMany: {
            args: Prisma.FoodNutrientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodNutrientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>[]
          }
          delete: {
            args: Prisma.FoodNutrientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          update: {
            args: Prisma.FoodNutrientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          deleteMany: {
            args: Prisma.FoodNutrientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodNutrientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodNutrientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>[]
          }
          upsert: {
            args: Prisma.FoodNutrientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodNutrientPayload>
          }
          aggregate: {
            args: Prisma.FoodNutrientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodNutrient>
          }
          groupBy: {
            args: Prisma.FoodNutrientGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodNutrientGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodNutrientCountArgs<ExtArgs>
            result: $Utils.Optional<FoodNutrientCountAggregateOutputType> | number
          }
        }
      }
      FoodRasa: {
        payload: Prisma.$FoodRasaPayload<ExtArgs>
        fields: Prisma.FoodRasaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodRasaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodRasaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          findFirst: {
            args: Prisma.FoodRasaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodRasaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          findMany: {
            args: Prisma.FoodRasaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>[]
          }
          create: {
            args: Prisma.FoodRasaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          createMany: {
            args: Prisma.FoodRasaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodRasaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>[]
          }
          delete: {
            args: Prisma.FoodRasaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          update: {
            args: Prisma.FoodRasaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          deleteMany: {
            args: Prisma.FoodRasaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodRasaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodRasaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>[]
          }
          upsert: {
            args: Prisma.FoodRasaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRasaPayload>
          }
          aggregate: {
            args: Prisma.FoodRasaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodRasa>
          }
          groupBy: {
            args: Prisma.FoodRasaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodRasaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodRasaCountArgs<ExtArgs>
            result: $Utils.Optional<FoodRasaCountAggregateOutputType> | number
          }
        }
      }
      FoodGuna: {
        payload: Prisma.$FoodGunaPayload<ExtArgs>
        fields: Prisma.FoodGunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodGunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodGunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          findFirst: {
            args: Prisma.FoodGunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodGunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          findMany: {
            args: Prisma.FoodGunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>[]
          }
          create: {
            args: Prisma.FoodGunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          createMany: {
            args: Prisma.FoodGunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodGunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>[]
          }
          delete: {
            args: Prisma.FoodGunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          update: {
            args: Prisma.FoodGunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          deleteMany: {
            args: Prisma.FoodGunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodGunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodGunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>[]
          }
          upsert: {
            args: Prisma.FoodGunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodGunaPayload>
          }
          aggregate: {
            args: Prisma.FoodGunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodGuna>
          }
          groupBy: {
            args: Prisma.FoodGunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodGunaCountArgs<ExtArgs>
            result: $Utils.Optional<FoodGunaCountAggregateOutputType> | number
          }
        }
      }
      FoodDosha: {
        payload: Prisma.$FoodDoshaPayload<ExtArgs>
        fields: Prisma.FoodDoshaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodDoshaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodDoshaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          findFirst: {
            args: Prisma.FoodDoshaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodDoshaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          findMany: {
            args: Prisma.FoodDoshaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>[]
          }
          create: {
            args: Prisma.FoodDoshaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          createMany: {
            args: Prisma.FoodDoshaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodDoshaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>[]
          }
          delete: {
            args: Prisma.FoodDoshaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          update: {
            args: Prisma.FoodDoshaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          deleteMany: {
            args: Prisma.FoodDoshaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodDoshaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodDoshaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>[]
          }
          upsert: {
            args: Prisma.FoodDoshaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDoshaPayload>
          }
          aggregate: {
            args: Prisma.FoodDoshaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodDosha>
          }
          groupBy: {
            args: Prisma.FoodDoshaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodDoshaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodDoshaCountArgs<ExtArgs>
            result: $Utils.Optional<FoodDoshaCountAggregateOutputType> | number
          }
        }
      }
      PatientDosha: {
        payload: Prisma.$PatientDoshaPayload<ExtArgs>
        fields: Prisma.PatientDoshaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientDoshaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientDoshaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          findFirst: {
            args: Prisma.PatientDoshaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientDoshaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          findMany: {
            args: Prisma.PatientDoshaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>[]
          }
          create: {
            args: Prisma.PatientDoshaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          createMany: {
            args: Prisma.PatientDoshaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientDoshaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>[]
          }
          delete: {
            args: Prisma.PatientDoshaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          update: {
            args: Prisma.PatientDoshaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          deleteMany: {
            args: Prisma.PatientDoshaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientDoshaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientDoshaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>[]
          }
          upsert: {
            args: Prisma.PatientDoshaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDoshaPayload>
          }
          aggregate: {
            args: Prisma.PatientDoshaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientDosha>
          }
          groupBy: {
            args: Prisma.PatientDoshaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientDoshaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientDoshaCountArgs<ExtArgs>
            result: $Utils.Optional<PatientDoshaCountAggregateOutputType> | number
          }
        }
      }
      FoodVirya: {
        payload: Prisma.$FoodViryaPayload<ExtArgs>
        fields: Prisma.FoodViryaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodViryaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodViryaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          findFirst: {
            args: Prisma.FoodViryaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodViryaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          findMany: {
            args: Prisma.FoodViryaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>[]
          }
          create: {
            args: Prisma.FoodViryaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          createMany: {
            args: Prisma.FoodViryaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodViryaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>[]
          }
          delete: {
            args: Prisma.FoodViryaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          update: {
            args: Prisma.FoodViryaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          deleteMany: {
            args: Prisma.FoodViryaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodViryaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodViryaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>[]
          }
          upsert: {
            args: Prisma.FoodViryaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodViryaPayload>
          }
          aggregate: {
            args: Prisma.FoodViryaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodVirya>
          }
          groupBy: {
            args: Prisma.FoodViryaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodViryaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodViryaCountArgs<ExtArgs>
            result: $Utils.Optional<FoodViryaCountAggregateOutputType> | number
          }
        }
      }
      FoodVipaka: {
        payload: Prisma.$FoodVipakaPayload<ExtArgs>
        fields: Prisma.FoodVipakaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodVipakaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodVipakaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          findFirst: {
            args: Prisma.FoodVipakaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodVipakaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          findMany: {
            args: Prisma.FoodVipakaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>[]
          }
          create: {
            args: Prisma.FoodVipakaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          createMany: {
            args: Prisma.FoodVipakaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodVipakaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>[]
          }
          delete: {
            args: Prisma.FoodVipakaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          update: {
            args: Prisma.FoodVipakaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          deleteMany: {
            args: Prisma.FoodVipakaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodVipakaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodVipakaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>[]
          }
          upsert: {
            args: Prisma.FoodVipakaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodVipakaPayload>
          }
          aggregate: {
            args: Prisma.FoodVipakaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodVipaka>
          }
          groupBy: {
            args: Prisma.FoodVipakaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodVipakaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodVipakaCountArgs<ExtArgs>
            result: $Utils.Optional<FoodVipakaCountAggregateOutputType> | number
          }
        }
      }
      FoodDigestibility: {
        payload: Prisma.$FoodDigestibilityPayload<ExtArgs>
        fields: Prisma.FoodDigestibilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodDigestibilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodDigestibilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          findFirst: {
            args: Prisma.FoodDigestibilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodDigestibilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          findMany: {
            args: Prisma.FoodDigestibilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>[]
          }
          create: {
            args: Prisma.FoodDigestibilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          createMany: {
            args: Prisma.FoodDigestibilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodDigestibilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>[]
          }
          delete: {
            args: Prisma.FoodDigestibilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          update: {
            args: Prisma.FoodDigestibilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          deleteMany: {
            args: Prisma.FoodDigestibilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodDigestibilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodDigestibilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>[]
          }
          upsert: {
            args: Prisma.FoodDigestibilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodDigestibilityPayload>
          }
          aggregate: {
            args: Prisma.FoodDigestibilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodDigestibility>
          }
          groupBy: {
            args: Prisma.FoodDigestibilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodDigestibilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodDigestibilityCountArgs<ExtArgs>
            result: $Utils.Optional<FoodDigestibilityCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeIngredient: {
        payload: Prisma.$RecipeIngredientPayload<ExtArgs>
        fields: Prisma.RecipeIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findFirst: {
            args: Prisma.RecipeIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findMany: {
            args: Prisma.RecipeIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          create: {
            args: Prisma.RecipeIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          createMany: {
            args: Prisma.RecipeIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          delete: {
            args: Prisma.RecipeIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          update: {
            args: Prisma.RecipeIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          deleteMany: {
            args: Prisma.RecipeIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          upsert: {
            args: Prisma.RecipeIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          aggregate: {
            args: Prisma.RecipeIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeIngredient>
          }
          groupBy: {
            args: Prisma.RecipeIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientCountAggregateOutputType> | number
          }
        }
      }
      DietChart: {
        payload: Prisma.$DietChartPayload<ExtArgs>
        fields: Prisma.DietChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          findFirst: {
            args: Prisma.DietChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          findMany: {
            args: Prisma.DietChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>[]
          }
          create: {
            args: Prisma.DietChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          createMany: {
            args: Prisma.DietChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietChartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>[]
          }
          delete: {
            args: Prisma.DietChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          update: {
            args: Prisma.DietChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          deleteMany: {
            args: Prisma.DietChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DietChartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>[]
          }
          upsert: {
            args: Prisma.DietChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartPayload>
          }
          aggregate: {
            args: Prisma.DietChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietChart>
          }
          groupBy: {
            args: Prisma.DietChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietChartCountArgs<ExtArgs>
            result: $Utils.Optional<DietChartCountAggregateOutputType> | number
          }
        }
      }
      DietChartRecipe: {
        payload: Prisma.$DietChartRecipePayload<ExtArgs>
        fields: Prisma.DietChartRecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietChartRecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietChartRecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          findFirst: {
            args: Prisma.DietChartRecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietChartRecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          findMany: {
            args: Prisma.DietChartRecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>[]
          }
          create: {
            args: Prisma.DietChartRecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          createMany: {
            args: Prisma.DietChartRecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietChartRecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>[]
          }
          delete: {
            args: Prisma.DietChartRecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          update: {
            args: Prisma.DietChartRecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          deleteMany: {
            args: Prisma.DietChartRecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietChartRecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DietChartRecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>[]
          }
          upsert: {
            args: Prisma.DietChartRecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietChartRecipePayload>
          }
          aggregate: {
            args: Prisma.DietChartRecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietChartRecipe>
          }
          groupBy: {
            args: Prisma.DietChartRecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietChartRecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietChartRecipeCountArgs<ExtArgs>
            result: $Utils.Optional<DietChartRecipeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    doctor?: DoctorOmit
    patient?: PatientOmit
    doctorPatient?: DoctorPatientOmit
    cuisine?: CuisineOmit
    food?: FoodOmit
    nutrient?: NutrientOmit
    rasa?: RasaOmit
    guna?: GunaOmit
    dosha?: DoshaOmit
    virya?: ViryaOmit
    vipaka?: VipakaOmit
    digestibility?: DigestibilityOmit
    rda?: RdaOmit
    foodNutrient?: FoodNutrientOmit
    foodRasa?: FoodRasaOmit
    foodGuna?: FoodGunaOmit
    foodDosha?: FoodDoshaOmit
    patientDosha?: PatientDoshaOmit
    foodVirya?: FoodViryaOmit
    foodVipaka?: FoodVipakaOmit
    foodDigestibility?: FoodDigestibilityOmit
    recipe?: RecipeOmit
    recipeIngredient?: RecipeIngredientOmit
    dietChart?: DietChartOmit
    dietChartRecipe?: DietChartRecipeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    DoctorPatient: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DoctorPatient?: boolean | DoctorCountOutputTypeCountDoctorPatientArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountDoctorPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPatientWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    PatientDosha: number
    DoctorPatient: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientDosha?: boolean | PatientCountOutputTypeCountPatientDoshaArgs
    DoctorPatient?: boolean | PatientCountOutputTypeCountDoctorPatientArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPatientDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDoshaWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDoctorPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPatientWhereInput
  }


  /**
   * Count Type CuisineCountOutputType
   */

  export type CuisineCountOutputType = {
    Recipe: number
  }

  export type CuisineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | CuisineCountOutputTypeCountRecipeArgs
  }

  // Custom InputTypes
  /**
   * CuisineCountOutputType without action
   */
  export type CuisineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CuisineCountOutputType
     */
    select?: CuisineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CuisineCountOutputType without action
   */
  export type CuisineCountOutputTypeCountRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * Count Type FoodCountOutputType
   */

  export type FoodCountOutputType = {
    FoodNutrient: number
    FoodRasa: number
    FoodGuna: number
    FoodDosha: number
    FoodVirya: number
    FoodVipaka: number
    FoodDigestibility: number
    RecipeIngredient: number
    DietChartRecipe: number
  }

  export type FoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodNutrient?: boolean | FoodCountOutputTypeCountFoodNutrientArgs
    FoodRasa?: boolean | FoodCountOutputTypeCountFoodRasaArgs
    FoodGuna?: boolean | FoodCountOutputTypeCountFoodGunaArgs
    FoodDosha?: boolean | FoodCountOutputTypeCountFoodDoshaArgs
    FoodVirya?: boolean | FoodCountOutputTypeCountFoodViryaArgs
    FoodVipaka?: boolean | FoodCountOutputTypeCountFoodVipakaArgs
    FoodDigestibility?: boolean | FoodCountOutputTypeCountFoodDigestibilityArgs
    RecipeIngredient?: boolean | FoodCountOutputTypeCountRecipeIngredientArgs
    DietChartRecipe?: boolean | FoodCountOutputTypeCountDietChartRecipeArgs
  }

  // Custom InputTypes
  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCountOutputType
     */
    select?: FoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodNutrientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodNutrientWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodRasaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRasaWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodGunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodGunaWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDoshaWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodViryaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodViryaWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodVipakaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodVipakaWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFoodDigestibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDigestibilityWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountRecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountDietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietChartRecipeWhereInput
  }


  /**
   * Count Type NutrientCountOutputType
   */

  export type NutrientCountOutputType = {
    FoodNutrient: number
    Rda: number
  }

  export type NutrientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodNutrient?: boolean | NutrientCountOutputTypeCountFoodNutrientArgs
    Rda?: boolean | NutrientCountOutputTypeCountRdaArgs
  }

  // Custom InputTypes
  /**
   * NutrientCountOutputType without action
   */
  export type NutrientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutrientCountOutputType
     */
    select?: NutrientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NutrientCountOutputType without action
   */
  export type NutrientCountOutputTypeCountFoodNutrientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodNutrientWhereInput
  }

  /**
   * NutrientCountOutputType without action
   */
  export type NutrientCountOutputTypeCountRdaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RdaWhereInput
  }


  /**
   * Count Type RasaCountOutputType
   */

  export type RasaCountOutputType = {
    FoodRasa: number
  }

  export type RasaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodRasa?: boolean | RasaCountOutputTypeCountFoodRasaArgs
  }

  // Custom InputTypes
  /**
   * RasaCountOutputType without action
   */
  export type RasaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RasaCountOutputType
     */
    select?: RasaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RasaCountOutputType without action
   */
  export type RasaCountOutputTypeCountFoodRasaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRasaWhereInput
  }


  /**
   * Count Type GunaCountOutputType
   */

  export type GunaCountOutputType = {
    FoodGuna: number
  }

  export type GunaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodGuna?: boolean | GunaCountOutputTypeCountFoodGunaArgs
  }

  // Custom InputTypes
  /**
   * GunaCountOutputType without action
   */
  export type GunaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GunaCountOutputType
     */
    select?: GunaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GunaCountOutputType without action
   */
  export type GunaCountOutputTypeCountFoodGunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodGunaWhereInput
  }


  /**
   * Count Type DoshaCountOutputType
   */

  export type DoshaCountOutputType = {
    FoodDosha: number
    PatientDosha: number
  }

  export type DoshaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodDosha?: boolean | DoshaCountOutputTypeCountFoodDoshaArgs
    PatientDosha?: boolean | DoshaCountOutputTypeCountPatientDoshaArgs
  }

  // Custom InputTypes
  /**
   * DoshaCountOutputType without action
   */
  export type DoshaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoshaCountOutputType
     */
    select?: DoshaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoshaCountOutputType without action
   */
  export type DoshaCountOutputTypeCountFoodDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDoshaWhereInput
  }

  /**
   * DoshaCountOutputType without action
   */
  export type DoshaCountOutputTypeCountPatientDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDoshaWhereInput
  }


  /**
   * Count Type ViryaCountOutputType
   */

  export type ViryaCountOutputType = {
    FoodVirya: number
  }

  export type ViryaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodVirya?: boolean | ViryaCountOutputTypeCountFoodViryaArgs
  }

  // Custom InputTypes
  /**
   * ViryaCountOutputType without action
   */
  export type ViryaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViryaCountOutputType
     */
    select?: ViryaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViryaCountOutputType without action
   */
  export type ViryaCountOutputTypeCountFoodViryaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodViryaWhereInput
  }


  /**
   * Count Type VipakaCountOutputType
   */

  export type VipakaCountOutputType = {
    FoodVipaka: number
  }

  export type VipakaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodVipaka?: boolean | VipakaCountOutputTypeCountFoodVipakaArgs
  }

  // Custom InputTypes
  /**
   * VipakaCountOutputType without action
   */
  export type VipakaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipakaCountOutputType
     */
    select?: VipakaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VipakaCountOutputType without action
   */
  export type VipakaCountOutputTypeCountFoodVipakaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodVipakaWhereInput
  }


  /**
   * Count Type DigestibilityCountOutputType
   */

  export type DigestibilityCountOutputType = {
    FoodDigestibility: number
  }

  export type DigestibilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodDigestibility?: boolean | DigestibilityCountOutputTypeCountFoodDigestibilityArgs
  }

  // Custom InputTypes
  /**
   * DigestibilityCountOutputType without action
   */
  export type DigestibilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigestibilityCountOutputType
     */
    select?: DigestibilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DigestibilityCountOutputType without action
   */
  export type DigestibilityCountOutputTypeCountFoodDigestibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDigestibilityWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    RecipeIngredient: number
    DietChartRecipe: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecipeIngredient?: boolean | RecipeCountOutputTypeCountRecipeIngredientArgs
    DietChartRecipe?: boolean | RecipeCountOutputTypeCountDietChartRecipeArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountRecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountDietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietChartRecipeWhereInput
  }


  /**
   * Count Type DietChartCountOutputType
   */

  export type DietChartCountOutputType = {
    DietChartRecipe: number
  }

  export type DietChartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DietChartRecipe?: boolean | DietChartCountOutputTypeCountDietChartRecipeArgs
  }

  // Custom InputTypes
  /**
   * DietChartCountOutputType without action
   */
  export type DietChartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartCountOutputType
     */
    select?: DietChartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DietChartCountOutputType without action
   */
  export type DietChartCountOutputTypeCountDietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietChartRecipeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DoctorMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password: string
    createdAt: Date
    updatedAt: Date
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DoctorPatient?: boolean | Doctor$DoctorPatientArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DoctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["doctor"]>
  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DoctorPatient?: boolean | Doctor$DoctorPatientArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DoctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      DoctorPatient: Prisma.$DoctorPatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DoctorPatient<T extends Doctor$DoctorPatientArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$DoctorPatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'String'>
    readonly email: FieldRef<"Doctor", 'String'>
    readonly name: FieldRef<"Doctor", 'String'>
    readonly password: FieldRef<"Doctor", 'String'>
    readonly createdAt: FieldRef<"Doctor", 'DateTime'>
    readonly updatedAt: FieldRef<"Doctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor updateManyAndReturn
   */
  export type DoctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number
  }

  /**
   * Doctor.DoctorPatient
   */
  export type Doctor$DoctorPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    where?: DoctorPatientWhereInput
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    cursor?: DoctorPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorPatientScalarFieldEnum | DoctorPatientScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    height: number | null
    weight: number | null
    mealFrequency: number | null
    waterIntake: number | null
  }

  export type PatientSumAggregateOutputType = {
    height: number | null
    weight: number | null
    mealFrequency: number | null
    waterIntake: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    gender: $Enums.Gender | null
    dob: Date | null
    height: number | null
    weight: number | null
    dietary_habits: $Enums.DietaryHabits | null
    mealFrequency: number | null
    waterIntake: number | null
    digestionQuality: $Enums.DigestionQuality | null
    bowelMovement: $Enums.BowelMovement | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    gender: $Enums.Gender | null
    dob: Date | null
    height: number | null
    weight: number | null
    dietary_habits: $Enums.DietaryHabits | null
    mealFrequency: number | null
    waterIntake: number | null
    digestionQuality: $Enums.DigestionQuality | null
    bowelMovement: $Enums.BowelMovement | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    updatedAt: number
    gender: number
    dob: number
    height: number
    weight: number
    dietary_habits: number
    mealFrequency: number
    waterIntake: number
    digestionQuality: number
    bowelMovement: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    height?: true
    weight?: true
    mealFrequency?: true
    waterIntake?: true
  }

  export type PatientSumAggregateInputType = {
    height?: true
    weight?: true
    mealFrequency?: true
    waterIntake?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
    dob?: true
    height?: true
    weight?: true
    dietary_habits?: true
    mealFrequency?: true
    waterIntake?: true
    digestionQuality?: true
    bowelMovement?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
    dob?: true
    height?: true
    weight?: true
    dietary_habits?: true
    mealFrequency?: true
    waterIntake?: true
    digestionQuality?: true
    bowelMovement?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
    dob?: true
    height?: true
    weight?: true
    dietary_habits?: true
    mealFrequency?: true
    waterIntake?: true
    digestionQuality?: true
    bowelMovement?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password: string
    createdAt: Date
    updatedAt: Date
    gender: $Enums.Gender | null
    dob: Date | null
    height: number | null
    weight: number | null
    dietary_habits: $Enums.DietaryHabits
    mealFrequency: number
    waterIntake: number
    digestionQuality: $Enums.DigestionQuality
    bowelMovement: $Enums.BowelMovement
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    dob?: boolean
    height?: boolean
    weight?: boolean
    dietary_habits?: boolean
    mealFrequency?: boolean
    waterIntake?: boolean
    digestionQuality?: boolean
    bowelMovement?: boolean
    PatientDosha?: boolean | Patient$PatientDoshaArgs<ExtArgs>
    DoctorPatient?: boolean | Patient$DoctorPatientArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    dob?: boolean
    height?: boolean
    weight?: boolean
    dietary_habits?: boolean
    mealFrequency?: boolean
    waterIntake?: boolean
    digestionQuality?: boolean
    bowelMovement?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    dob?: boolean
    height?: boolean
    weight?: boolean
    dietary_habits?: boolean
    mealFrequency?: boolean
    waterIntake?: boolean
    digestionQuality?: boolean
    bowelMovement?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    dob?: boolean
    height?: boolean
    weight?: boolean
    dietary_habits?: boolean
    mealFrequency?: boolean
    waterIntake?: boolean
    digestionQuality?: boolean
    bowelMovement?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt" | "updatedAt" | "gender" | "dob" | "height" | "weight" | "dietary_habits" | "mealFrequency" | "waterIntake" | "digestionQuality" | "bowelMovement", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientDosha?: boolean | Patient$PatientDoshaArgs<ExtArgs>
    DoctorPatient?: boolean | Patient$DoctorPatientArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      PatientDosha: Prisma.$PatientDoshaPayload<ExtArgs>[]
      DoctorPatient: Prisma.$DoctorPatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password: string
      createdAt: Date
      updatedAt: Date
      gender: $Enums.Gender | null
      dob: Date | null
      height: number | null
      weight: number | null
      dietary_habits: $Enums.DietaryHabits
      mealFrequency: number
      waterIntake: number
      digestionQuality: $Enums.DigestionQuality
      bowelMovement: $Enums.BowelMovement
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PatientDosha<T extends Patient$PatientDoshaArgs<ExtArgs> = {}>(args?: Subset<T, Patient$PatientDoshaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DoctorPatient<T extends Patient$DoctorPatientArgs<ExtArgs> = {}>(args?: Subset<T, Patient$DoctorPatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly password: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly dietary_habits: FieldRef<"Patient", 'DietaryHabits'>
    readonly mealFrequency: FieldRef<"Patient", 'Int'>
    readonly waterIntake: FieldRef<"Patient", 'Float'>
    readonly digestionQuality: FieldRef<"Patient", 'DigestionQuality'>
    readonly bowelMovement: FieldRef<"Patient", 'BowelMovement'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.PatientDosha
   */
  export type Patient$PatientDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    where?: PatientDoshaWhereInput
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    cursor?: PatientDoshaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientDoshaScalarFieldEnum | PatientDoshaScalarFieldEnum[]
  }

  /**
   * Patient.DoctorPatient
   */
  export type Patient$DoctorPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    where?: DoctorPatientWhereInput
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    cursor?: DoctorPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorPatientScalarFieldEnum | DoctorPatientScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model DoctorPatient
   */

  export type AggregateDoctorPatient = {
    _count: DoctorPatientCountAggregateOutputType | null
    _min: DoctorPatientMinAggregateOutputType | null
    _max: DoctorPatientMaxAggregateOutputType | null
  }

  export type DoctorPatientMinAggregateOutputType = {
    doctor_id: string | null
    patient_id: string | null
  }

  export type DoctorPatientMaxAggregateOutputType = {
    doctor_id: string | null
    patient_id: string | null
  }

  export type DoctorPatientCountAggregateOutputType = {
    doctor_id: number
    patient_id: number
    _all: number
  }


  export type DoctorPatientMinAggregateInputType = {
    doctor_id?: true
    patient_id?: true
  }

  export type DoctorPatientMaxAggregateInputType = {
    doctor_id?: true
    patient_id?: true
  }

  export type DoctorPatientCountAggregateInputType = {
    doctor_id?: true
    patient_id?: true
    _all?: true
  }

  export type DoctorPatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPatient to aggregate.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorPatients
    **/
    _count?: true | DoctorPatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorPatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorPatientMaxAggregateInputType
  }

  export type GetDoctorPatientAggregateType<T extends DoctorPatientAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorPatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorPatient[P]>
      : GetScalarType<T[P], AggregateDoctorPatient[P]>
  }




  export type DoctorPatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPatientWhereInput
    orderBy?: DoctorPatientOrderByWithAggregationInput | DoctorPatientOrderByWithAggregationInput[]
    by: DoctorPatientScalarFieldEnum[] | DoctorPatientScalarFieldEnum
    having?: DoctorPatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorPatientCountAggregateInputType | true
    _min?: DoctorPatientMinAggregateInputType
    _max?: DoctorPatientMaxAggregateInputType
  }

  export type DoctorPatientGroupByOutputType = {
    doctor_id: string
    patient_id: string
    _count: DoctorPatientCountAggregateOutputType | null
    _min: DoctorPatientMinAggregateOutputType | null
    _max: DoctorPatientMaxAggregateOutputType | null
  }

  type GetDoctorPatientGroupByPayload<T extends DoctorPatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorPatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorPatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorPatientGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorPatientGroupByOutputType[P]>
        }
      >
    >


  export type DoctorPatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctor_id?: boolean
    patient_id?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPatient"]>

  export type DoctorPatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctor_id?: boolean
    patient_id?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPatient"]>

  export type DoctorPatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctor_id?: boolean
    patient_id?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPatient"]>

  export type DoctorPatientSelectScalar = {
    doctor_id?: boolean
    patient_id?: boolean
  }

  export type DoctorPatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"doctor_id" | "patient_id", ExtArgs["result"]["doctorPatient"]>
  export type DoctorPatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DoctorPatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DoctorPatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DoctorPatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorPatient"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      doctor_id: string
      patient_id: string
    }, ExtArgs["result"]["doctorPatient"]>
    composites: {}
  }

  type DoctorPatientGetPayload<S extends boolean | null | undefined | DoctorPatientDefaultArgs> = $Result.GetResult<Prisma.$DoctorPatientPayload, S>

  type DoctorPatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorPatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorPatientCountAggregateInputType | true
    }

  export interface DoctorPatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorPatient'], meta: { name: 'DoctorPatient' } }
    /**
     * Find zero or one DoctorPatient that matches the filter.
     * @param {DoctorPatientFindUniqueArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorPatientFindUniqueArgs>(args: SelectSubset<T, DoctorPatientFindUniqueArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DoctorPatient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorPatientFindUniqueOrThrowArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorPatientFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorPatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorPatient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindFirstArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorPatientFindFirstArgs>(args?: SelectSubset<T, DoctorPatientFindFirstArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorPatient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindFirstOrThrowArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorPatientFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorPatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DoctorPatients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorPatients
     * const doctorPatients = await prisma.doctorPatient.findMany()
     * 
     * // Get first 10 DoctorPatients
     * const doctorPatients = await prisma.doctorPatient.findMany({ take: 10 })
     * 
     * // Only select the `doctor_id`
     * const doctorPatientWithDoctor_idOnly = await prisma.doctorPatient.findMany({ select: { doctor_id: true } })
     * 
     */
    findMany<T extends DoctorPatientFindManyArgs>(args?: SelectSubset<T, DoctorPatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DoctorPatient.
     * @param {DoctorPatientCreateArgs} args - Arguments to create a DoctorPatient.
     * @example
     * // Create one DoctorPatient
     * const DoctorPatient = await prisma.doctorPatient.create({
     *   data: {
     *     // ... data to create a DoctorPatient
     *   }
     * })
     * 
     */
    create<T extends DoctorPatientCreateArgs>(args: SelectSubset<T, DoctorPatientCreateArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DoctorPatients.
     * @param {DoctorPatientCreateManyArgs} args - Arguments to create many DoctorPatients.
     * @example
     * // Create many DoctorPatients
     * const doctorPatient = await prisma.doctorPatient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorPatientCreateManyArgs>(args?: SelectSubset<T, DoctorPatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorPatients and returns the data saved in the database.
     * @param {DoctorPatientCreateManyAndReturnArgs} args - Arguments to create many DoctorPatients.
     * @example
     * // Create many DoctorPatients
     * const doctorPatient = await prisma.doctorPatient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorPatients and only return the `doctor_id`
     * const doctorPatientWithDoctor_idOnly = await prisma.doctorPatient.createManyAndReturn({
     *   select: { doctor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorPatientCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorPatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DoctorPatient.
     * @param {DoctorPatientDeleteArgs} args - Arguments to delete one DoctorPatient.
     * @example
     * // Delete one DoctorPatient
     * const DoctorPatient = await prisma.doctorPatient.delete({
     *   where: {
     *     // ... filter to delete one DoctorPatient
     *   }
     * })
     * 
     */
    delete<T extends DoctorPatientDeleteArgs>(args: SelectSubset<T, DoctorPatientDeleteArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DoctorPatient.
     * @param {DoctorPatientUpdateArgs} args - Arguments to update one DoctorPatient.
     * @example
     * // Update one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorPatientUpdateArgs>(args: SelectSubset<T, DoctorPatientUpdateArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DoctorPatients.
     * @param {DoctorPatientDeleteManyArgs} args - Arguments to filter DoctorPatients to delete.
     * @example
     * // Delete a few DoctorPatients
     * const { count } = await prisma.doctorPatient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorPatientDeleteManyArgs>(args?: SelectSubset<T, DoctorPatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorPatients
     * const doctorPatient = await prisma.doctorPatient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorPatientUpdateManyArgs>(args: SelectSubset<T, DoctorPatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorPatients and returns the data updated in the database.
     * @param {DoctorPatientUpdateManyAndReturnArgs} args - Arguments to update many DoctorPatients.
     * @example
     * // Update many DoctorPatients
     * const doctorPatient = await prisma.doctorPatient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DoctorPatients and only return the `doctor_id`
     * const doctorPatientWithDoctor_idOnly = await prisma.doctorPatient.updateManyAndReturn({
     *   select: { doctor_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorPatientUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorPatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DoctorPatient.
     * @param {DoctorPatientUpsertArgs} args - Arguments to update or create a DoctorPatient.
     * @example
     * // Update or create a DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.upsert({
     *   create: {
     *     // ... data to create a DoctorPatient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorPatient we want to update
     *   }
     * })
     */
    upsert<T extends DoctorPatientUpsertArgs>(args: SelectSubset<T, DoctorPatientUpsertArgs<ExtArgs>>): Prisma__DoctorPatientClient<$Result.GetResult<Prisma.$DoctorPatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DoctorPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientCountArgs} args - Arguments to filter DoctorPatients to count.
     * @example
     * // Count the number of DoctorPatients
     * const count = await prisma.doctorPatient.count({
     *   where: {
     *     // ... the filter for the DoctorPatients we want to count
     *   }
     * })
    **/
    count<T extends DoctorPatientCountArgs>(
      args?: Subset<T, DoctorPatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorPatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorPatientAggregateArgs>(args: Subset<T, DoctorPatientAggregateArgs>): Prisma.PrismaPromise<GetDoctorPatientAggregateType<T>>

    /**
     * Group by DoctorPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorPatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorPatientGroupByArgs['orderBy'] }
        : { orderBy?: DoctorPatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorPatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorPatient model
   */
  readonly fields: DoctorPatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorPatient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorPatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorPatient model
   */
  interface DoctorPatientFieldRefs {
    readonly doctor_id: FieldRef<"DoctorPatient", 'String'>
    readonly patient_id: FieldRef<"DoctorPatient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoctorPatient findUnique
   */
  export type DoctorPatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where: DoctorPatientWhereUniqueInput
  }

  /**
   * DoctorPatient findUniqueOrThrow
   */
  export type DoctorPatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where: DoctorPatientWhereUniqueInput
  }

  /**
   * DoctorPatient findFirst
   */
  export type DoctorPatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPatients.
     */
    distinct?: DoctorPatientScalarFieldEnum | DoctorPatientScalarFieldEnum[]
  }

  /**
   * DoctorPatient findFirstOrThrow
   */
  export type DoctorPatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPatients.
     */
    distinct?: DoctorPatientScalarFieldEnum | DoctorPatientScalarFieldEnum[]
  }

  /**
   * DoctorPatient findMany
   */
  export type DoctorPatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatients to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: DoctorPatientOrderByWithRelationInput | DoctorPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    distinct?: DoctorPatientScalarFieldEnum | DoctorPatientScalarFieldEnum[]
  }

  /**
   * DoctorPatient create
   */
  export type DoctorPatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorPatient.
     */
    data: XOR<DoctorPatientCreateInput, DoctorPatientUncheckedCreateInput>
  }

  /**
   * DoctorPatient createMany
   */
  export type DoctorPatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorPatients.
     */
    data: DoctorPatientCreateManyInput | DoctorPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorPatient createManyAndReturn
   */
  export type DoctorPatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * The data used to create many DoctorPatients.
     */
    data: DoctorPatientCreateManyInput | DoctorPatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorPatient update
   */
  export type DoctorPatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorPatient.
     */
    data: XOR<DoctorPatientUpdateInput, DoctorPatientUncheckedUpdateInput>
    /**
     * Choose, which DoctorPatient to update.
     */
    where: DoctorPatientWhereUniqueInput
  }

  /**
   * DoctorPatient updateMany
   */
  export type DoctorPatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorPatients.
     */
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyInput>
    /**
     * Filter which DoctorPatients to update
     */
    where?: DoctorPatientWhereInput
    /**
     * Limit how many DoctorPatients to update.
     */
    limit?: number
  }

  /**
   * DoctorPatient updateManyAndReturn
   */
  export type DoctorPatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * The data used to update DoctorPatients.
     */
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyInput>
    /**
     * Filter which DoctorPatients to update
     */
    where?: DoctorPatientWhereInput
    /**
     * Limit how many DoctorPatients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorPatient upsert
   */
  export type DoctorPatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorPatient to update in case it exists.
     */
    where: DoctorPatientWhereUniqueInput
    /**
     * In case the DoctorPatient found by the `where` argument doesn't exist, create a new DoctorPatient with this data.
     */
    create: XOR<DoctorPatientCreateInput, DoctorPatientUncheckedCreateInput>
    /**
     * In case the DoctorPatient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorPatientUpdateInput, DoctorPatientUncheckedUpdateInput>
  }

  /**
   * DoctorPatient delete
   */
  export type DoctorPatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter which DoctorPatient to delete.
     */
    where: DoctorPatientWhereUniqueInput
  }

  /**
   * DoctorPatient deleteMany
   */
  export type DoctorPatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPatients to delete
     */
    where?: DoctorPatientWhereInput
    /**
     * Limit how many DoctorPatients to delete.
     */
    limit?: number
  }

  /**
   * DoctorPatient without action
   */
  export type DoctorPatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorPatient
     */
    omit?: DoctorPatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPatientInclude<ExtArgs> | null
  }


  /**
   * Model Cuisine
   */

  export type AggregateCuisine = {
    _count: CuisineCountAggregateOutputType | null
    _min: CuisineMinAggregateOutputType | null
    _max: CuisineMaxAggregateOutputType | null
  }

  export type CuisineMinAggregateOutputType = {
    cuisine_id: string | null
    name: string | null
  }

  export type CuisineMaxAggregateOutputType = {
    cuisine_id: string | null
    name: string | null
  }

  export type CuisineCountAggregateOutputType = {
    cuisine_id: number
    name: number
    _all: number
  }


  export type CuisineMinAggregateInputType = {
    cuisine_id?: true
    name?: true
  }

  export type CuisineMaxAggregateInputType = {
    cuisine_id?: true
    name?: true
  }

  export type CuisineCountAggregateInputType = {
    cuisine_id?: true
    name?: true
    _all?: true
  }

  export type CuisineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuisine to aggregate.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuisines
    **/
    _count?: true | CuisineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuisineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuisineMaxAggregateInputType
  }

  export type GetCuisineAggregateType<T extends CuisineAggregateArgs> = {
        [P in keyof T & keyof AggregateCuisine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuisine[P]>
      : GetScalarType<T[P], AggregateCuisine[P]>
  }




  export type CuisineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuisineWhereInput
    orderBy?: CuisineOrderByWithAggregationInput | CuisineOrderByWithAggregationInput[]
    by: CuisineScalarFieldEnum[] | CuisineScalarFieldEnum
    having?: CuisineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuisineCountAggregateInputType | true
    _min?: CuisineMinAggregateInputType
    _max?: CuisineMaxAggregateInputType
  }

  export type CuisineGroupByOutputType = {
    cuisine_id: string
    name: string
    _count: CuisineCountAggregateOutputType | null
    _min: CuisineMinAggregateOutputType | null
    _max: CuisineMaxAggregateOutputType | null
  }

  type GetCuisineGroupByPayload<T extends CuisineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuisineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuisineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuisineGroupByOutputType[P]>
            : GetScalarType<T[P], CuisineGroupByOutputType[P]>
        }
      >
    >


  export type CuisineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cuisine_id?: boolean
    name?: boolean
    Recipe?: boolean | Cuisine$RecipeArgs<ExtArgs>
    _count?: boolean | CuisineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuisine"]>

  export type CuisineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cuisine_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["cuisine"]>

  export type CuisineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cuisine_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["cuisine"]>

  export type CuisineSelectScalar = {
    cuisine_id?: boolean
    name?: boolean
  }

  export type CuisineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cuisine_id" | "name", ExtArgs["result"]["cuisine"]>
  export type CuisineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Recipe?: boolean | Cuisine$RecipeArgs<ExtArgs>
    _count?: boolean | CuisineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CuisineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CuisineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CuisinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cuisine"
    objects: {
      Recipe: Prisma.$RecipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cuisine_id: string
      name: string
    }, ExtArgs["result"]["cuisine"]>
    composites: {}
  }

  type CuisineGetPayload<S extends boolean | null | undefined | CuisineDefaultArgs> = $Result.GetResult<Prisma.$CuisinePayload, S>

  type CuisineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CuisineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CuisineCountAggregateInputType | true
    }

  export interface CuisineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuisine'], meta: { name: 'Cuisine' } }
    /**
     * Find zero or one Cuisine that matches the filter.
     * @param {CuisineFindUniqueArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CuisineFindUniqueArgs>(args: SelectSubset<T, CuisineFindUniqueArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cuisine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CuisineFindUniqueOrThrowArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CuisineFindUniqueOrThrowArgs>(args: SelectSubset<T, CuisineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cuisine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindFirstArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CuisineFindFirstArgs>(args?: SelectSubset<T, CuisineFindFirstArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cuisine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindFirstOrThrowArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CuisineFindFirstOrThrowArgs>(args?: SelectSubset<T, CuisineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cuisines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuisines
     * const cuisines = await prisma.cuisine.findMany()
     * 
     * // Get first 10 Cuisines
     * const cuisines = await prisma.cuisine.findMany({ take: 10 })
     * 
     * // Only select the `cuisine_id`
     * const cuisineWithCuisine_idOnly = await prisma.cuisine.findMany({ select: { cuisine_id: true } })
     * 
     */
    findMany<T extends CuisineFindManyArgs>(args?: SelectSubset<T, CuisineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cuisine.
     * @param {CuisineCreateArgs} args - Arguments to create a Cuisine.
     * @example
     * // Create one Cuisine
     * const Cuisine = await prisma.cuisine.create({
     *   data: {
     *     // ... data to create a Cuisine
     *   }
     * })
     * 
     */
    create<T extends CuisineCreateArgs>(args: SelectSubset<T, CuisineCreateArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cuisines.
     * @param {CuisineCreateManyArgs} args - Arguments to create many Cuisines.
     * @example
     * // Create many Cuisines
     * const cuisine = await prisma.cuisine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CuisineCreateManyArgs>(args?: SelectSubset<T, CuisineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cuisines and returns the data saved in the database.
     * @param {CuisineCreateManyAndReturnArgs} args - Arguments to create many Cuisines.
     * @example
     * // Create many Cuisines
     * const cuisine = await prisma.cuisine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cuisines and only return the `cuisine_id`
     * const cuisineWithCuisine_idOnly = await prisma.cuisine.createManyAndReturn({
     *   select: { cuisine_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CuisineCreateManyAndReturnArgs>(args?: SelectSubset<T, CuisineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cuisine.
     * @param {CuisineDeleteArgs} args - Arguments to delete one Cuisine.
     * @example
     * // Delete one Cuisine
     * const Cuisine = await prisma.cuisine.delete({
     *   where: {
     *     // ... filter to delete one Cuisine
     *   }
     * })
     * 
     */
    delete<T extends CuisineDeleteArgs>(args: SelectSubset<T, CuisineDeleteArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cuisine.
     * @param {CuisineUpdateArgs} args - Arguments to update one Cuisine.
     * @example
     * // Update one Cuisine
     * const cuisine = await prisma.cuisine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CuisineUpdateArgs>(args: SelectSubset<T, CuisineUpdateArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cuisines.
     * @param {CuisineDeleteManyArgs} args - Arguments to filter Cuisines to delete.
     * @example
     * // Delete a few Cuisines
     * const { count } = await prisma.cuisine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CuisineDeleteManyArgs>(args?: SelectSubset<T, CuisineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuisines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuisines
     * const cuisine = await prisma.cuisine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CuisineUpdateManyArgs>(args: SelectSubset<T, CuisineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuisines and returns the data updated in the database.
     * @param {CuisineUpdateManyAndReturnArgs} args - Arguments to update many Cuisines.
     * @example
     * // Update many Cuisines
     * const cuisine = await prisma.cuisine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cuisines and only return the `cuisine_id`
     * const cuisineWithCuisine_idOnly = await prisma.cuisine.updateManyAndReturn({
     *   select: { cuisine_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CuisineUpdateManyAndReturnArgs>(args: SelectSubset<T, CuisineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cuisine.
     * @param {CuisineUpsertArgs} args - Arguments to update or create a Cuisine.
     * @example
     * // Update or create a Cuisine
     * const cuisine = await prisma.cuisine.upsert({
     *   create: {
     *     // ... data to create a Cuisine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuisine we want to update
     *   }
     * })
     */
    upsert<T extends CuisineUpsertArgs>(args: SelectSubset<T, CuisineUpsertArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cuisines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineCountArgs} args - Arguments to filter Cuisines to count.
     * @example
     * // Count the number of Cuisines
     * const count = await prisma.cuisine.count({
     *   where: {
     *     // ... the filter for the Cuisines we want to count
     *   }
     * })
    **/
    count<T extends CuisineCountArgs>(
      args?: Subset<T, CuisineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuisineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuisine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuisineAggregateArgs>(args: Subset<T, CuisineAggregateArgs>): Prisma.PrismaPromise<GetCuisineAggregateType<T>>

    /**
     * Group by Cuisine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuisineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuisineGroupByArgs['orderBy'] }
        : { orderBy?: CuisineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuisineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuisineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cuisine model
   */
  readonly fields: CuisineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuisine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CuisineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Recipe<T extends Cuisine$RecipeArgs<ExtArgs> = {}>(args?: Subset<T, Cuisine$RecipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cuisine model
   */
  interface CuisineFieldRefs {
    readonly cuisine_id: FieldRef<"Cuisine", 'String'>
    readonly name: FieldRef<"Cuisine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cuisine findUnique
   */
  export type CuisineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine findUniqueOrThrow
   */
  export type CuisineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine findFirst
   */
  export type CuisineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuisines.
     */
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine findFirstOrThrow
   */
  export type CuisineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuisines.
     */
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine findMany
   */
  export type CuisineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter, which Cuisines to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine create
   */
  export type CuisineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * The data needed to create a Cuisine.
     */
    data: XOR<CuisineCreateInput, CuisineUncheckedCreateInput>
  }

  /**
   * Cuisine createMany
   */
  export type CuisineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuisines.
     */
    data: CuisineCreateManyInput | CuisineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuisine createManyAndReturn
   */
  export type CuisineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * The data used to create many Cuisines.
     */
    data: CuisineCreateManyInput | CuisineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuisine update
   */
  export type CuisineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * The data needed to update a Cuisine.
     */
    data: XOR<CuisineUpdateInput, CuisineUncheckedUpdateInput>
    /**
     * Choose, which Cuisine to update.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine updateMany
   */
  export type CuisineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuisines.
     */
    data: XOR<CuisineUpdateManyMutationInput, CuisineUncheckedUpdateManyInput>
    /**
     * Filter which Cuisines to update
     */
    where?: CuisineWhereInput
    /**
     * Limit how many Cuisines to update.
     */
    limit?: number
  }

  /**
   * Cuisine updateManyAndReturn
   */
  export type CuisineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * The data used to update Cuisines.
     */
    data: XOR<CuisineUpdateManyMutationInput, CuisineUncheckedUpdateManyInput>
    /**
     * Filter which Cuisines to update
     */
    where?: CuisineWhereInput
    /**
     * Limit how many Cuisines to update.
     */
    limit?: number
  }

  /**
   * Cuisine upsert
   */
  export type CuisineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * The filter to search for the Cuisine to update in case it exists.
     */
    where: CuisineWhereUniqueInput
    /**
     * In case the Cuisine found by the `where` argument doesn't exist, create a new Cuisine with this data.
     */
    create: XOR<CuisineCreateInput, CuisineUncheckedCreateInput>
    /**
     * In case the Cuisine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuisineUpdateInput, CuisineUncheckedUpdateInput>
  }

  /**
   * Cuisine delete
   */
  export type CuisineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
    /**
     * Filter which Cuisine to delete.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine deleteMany
   */
  export type CuisineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuisines to delete
     */
    where?: CuisineWhereInput
    /**
     * Limit how many Cuisines to delete.
     */
    limit?: number
  }

  /**
   * Cuisine.Recipe
   */
  export type Cuisine$RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Cuisine without action
   */
  export type CuisineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuisine
     */
    omit?: CuisineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuisineInclude<ExtArgs> | null
  }


  /**
   * Model Food
   */

  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodMinAggregateOutputType = {
    food_id: string | null
    name: string | null
    hindi_name: string | null
  }

  export type FoodMaxAggregateOutputType = {
    food_id: string | null
    name: string | null
    hindi_name: string | null
  }

  export type FoodCountAggregateOutputType = {
    food_id: number
    name: number
    hindi_name: number
    _all: number
  }


  export type FoodMinAggregateInputType = {
    food_id?: true
    name?: true
    hindi_name?: true
  }

  export type FoodMaxAggregateInputType = {
    food_id?: true
    name?: true
    hindi_name?: true
  }

  export type FoodCountAggregateInputType = {
    food_id?: true
    name?: true
    hindi_name?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Food to aggregate.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithAggregationInput | FoodOrderByWithAggregationInput[]
    by: FoodScalarFieldEnum[] | FoodScalarFieldEnum
    having?: FoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }

  export type FoodGroupByOutputType = {
    food_id: string
    name: string
    hindi_name: string | null
    _count: FoodCountAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    name?: boolean
    hindi_name?: boolean
    FoodNutrient?: boolean | Food$FoodNutrientArgs<ExtArgs>
    FoodRasa?: boolean | Food$FoodRasaArgs<ExtArgs>
    FoodGuna?: boolean | Food$FoodGunaArgs<ExtArgs>
    FoodDosha?: boolean | Food$FoodDoshaArgs<ExtArgs>
    FoodVirya?: boolean | Food$FoodViryaArgs<ExtArgs>
    FoodVipaka?: boolean | Food$FoodVipakaArgs<ExtArgs>
    FoodDigestibility?: boolean | Food$FoodDigestibilityArgs<ExtArgs>
    RecipeIngredient?: boolean | Food$RecipeIngredientArgs<ExtArgs>
    DietChartRecipe?: boolean | Food$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    name?: boolean
    hindi_name?: boolean
  }, ExtArgs["result"]["food"]>

  export type FoodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    name?: boolean
    hindi_name?: boolean
  }, ExtArgs["result"]["food"]>

  export type FoodSelectScalar = {
    food_id?: boolean
    name?: boolean
    hindi_name?: boolean
  }

  export type FoodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "name" | "hindi_name", ExtArgs["result"]["food"]>
  export type FoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodNutrient?: boolean | Food$FoodNutrientArgs<ExtArgs>
    FoodRasa?: boolean | Food$FoodRasaArgs<ExtArgs>
    FoodGuna?: boolean | Food$FoodGunaArgs<ExtArgs>
    FoodDosha?: boolean | Food$FoodDoshaArgs<ExtArgs>
    FoodVirya?: boolean | Food$FoodViryaArgs<ExtArgs>
    FoodVipaka?: boolean | Food$FoodVipakaArgs<ExtArgs>
    FoodDigestibility?: boolean | Food$FoodDigestibilityArgs<ExtArgs>
    RecipeIngredient?: boolean | Food$RecipeIngredientArgs<ExtArgs>
    DietChartRecipe?: boolean | Food$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FoodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Food"
    objects: {
      FoodNutrient: Prisma.$FoodNutrientPayload<ExtArgs>[]
      FoodRasa: Prisma.$FoodRasaPayload<ExtArgs>[]
      FoodGuna: Prisma.$FoodGunaPayload<ExtArgs>[]
      FoodDosha: Prisma.$FoodDoshaPayload<ExtArgs>[]
      FoodVirya: Prisma.$FoodViryaPayload<ExtArgs>[]
      FoodVipaka: Prisma.$FoodVipakaPayload<ExtArgs>[]
      FoodDigestibility: Prisma.$FoodDigestibilityPayload<ExtArgs>[]
      RecipeIngredient: Prisma.$RecipeIngredientPayload<ExtArgs>[]
      DietChartRecipe: Prisma.$DietChartRecipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      name: string
      hindi_name: string | null
    }, ExtArgs["result"]["food"]>
    composites: {}
  }

  type FoodGetPayload<S extends boolean | null | undefined | FoodDefaultArgs> = $Result.GetResult<Prisma.$FoodPayload, S>

  type FoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface FoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Food'], meta: { name: 'Food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {FoodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodFindUniqueArgs>(args: SelectSubset<T, FoodFindUniqueArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Food that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodFindFirstArgs>(args?: SelectSubset<T, FoodFindFirstArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodWithFood_idOnly = await prisma.food.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodFindManyArgs>(args?: SelectSubset<T, FoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Food.
     * @param {FoodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
     */
    create<T extends FoodCreateArgs>(args: SelectSubset<T, FoodCreateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Foods.
     * @param {FoodCreateManyArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCreateManyArgs>(args?: SelectSubset<T, FoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Foods and returns the data saved in the database.
     * @param {FoodCreateManyAndReturnArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Foods and only return the `food_id`
     * const foodWithFood_idOnly = await prisma.food.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Food.
     * @param {FoodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
     */
    delete<T extends FoodDeleteArgs>(args: SelectSubset<T, FoodDeleteArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Food.
     * @param {FoodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodUpdateArgs>(args: SelectSubset<T, FoodUpdateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Foods.
     * @param {FoodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDeleteManyArgs>(args?: SelectSubset<T, FoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodUpdateManyArgs>(args: SelectSubset<T, FoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods and returns the data updated in the database.
     * @param {FoodUpdateManyAndReturnArgs} args - Arguments to update many Foods.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Foods and only return the `food_id`
     * const foodWithFood_idOnly = await prisma.food.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Food.
     * @param {FoodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
     */
    upsert<T extends FoodUpsertArgs>(args: SelectSubset<T, FoodUpsertArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends FoodCountArgs>(
      args?: Subset<T, FoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Food model
   */
  readonly fields: FoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodNutrient<T extends Food$FoodNutrientArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodNutrientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodRasa<T extends Food$FoodRasaArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodRasaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodGuna<T extends Food$FoodGunaArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodGunaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodDosha<T extends Food$FoodDoshaArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodDoshaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodVirya<T extends Food$FoodViryaArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodViryaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodVipaka<T extends Food$FoodVipakaArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodVipakaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodDigestibility<T extends Food$FoodDigestibilityArgs<ExtArgs> = {}>(args?: Subset<T, Food$FoodDigestibilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RecipeIngredient<T extends Food$RecipeIngredientArgs<ExtArgs> = {}>(args?: Subset<T, Food$RecipeIngredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DietChartRecipe<T extends Food$DietChartRecipeArgs<ExtArgs> = {}>(args?: Subset<T, Food$DietChartRecipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Food model
   */
  interface FoodFieldRefs {
    readonly food_id: FieldRef<"Food", 'String'>
    readonly name: FieldRef<"Food", 'String'>
    readonly hindi_name: FieldRef<"Food", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Food findUnique
   */
  export type FoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findUniqueOrThrow
   */
  export type FoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findFirst
   */
  export type FoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findFirstOrThrow
   */
  export type FoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findMany
   */
  export type FoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Foods to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food create
   */
  export type FoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Food.
     */
    data: XOR<FoodCreateInput, FoodUncheckedCreateInput>
  }

  /**
   * Food createMany
   */
  export type FoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Food createManyAndReturn
   */
  export type FoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Food update
   */
  export type FoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Food.
     */
    data: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
    /**
     * Choose, which Food to update.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food updateMany
   */
  export type FoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to update.
     */
    limit?: number
  }

  /**
   * Food updateManyAndReturn
   */
  export type FoodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to update.
     */
    limit?: number
  }

  /**
   * Food upsert
   */
  export type FoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Food to update in case it exists.
     */
    where: FoodWhereUniqueInput
    /**
     * In case the Food found by the `where` argument doesn't exist, create a new Food with this data.
     */
    create: XOR<FoodCreateInput, FoodUncheckedCreateInput>
    /**
     * In case the Food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
  }

  /**
   * Food delete
   */
  export type FoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter which Food to delete.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food deleteMany
   */
  export type FoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foods to delete
     */
    where?: FoodWhereInput
    /**
     * Limit how many Foods to delete.
     */
    limit?: number
  }

  /**
   * Food.FoodNutrient
   */
  export type Food$FoodNutrientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    where?: FoodNutrientWhereInput
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    cursor?: FoodNutrientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodNutrientScalarFieldEnum | FoodNutrientScalarFieldEnum[]
  }

  /**
   * Food.FoodRasa
   */
  export type Food$FoodRasaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    where?: FoodRasaWhereInput
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    cursor?: FoodRasaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRasaScalarFieldEnum | FoodRasaScalarFieldEnum[]
  }

  /**
   * Food.FoodGuna
   */
  export type Food$FoodGunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    where?: FoodGunaWhereInput
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    cursor?: FoodGunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodGunaScalarFieldEnum | FoodGunaScalarFieldEnum[]
  }

  /**
   * Food.FoodDosha
   */
  export type Food$FoodDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    where?: FoodDoshaWhereInput
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    cursor?: FoodDoshaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodDoshaScalarFieldEnum | FoodDoshaScalarFieldEnum[]
  }

  /**
   * Food.FoodVirya
   */
  export type Food$FoodViryaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    where?: FoodViryaWhereInput
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    cursor?: FoodViryaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodViryaScalarFieldEnum | FoodViryaScalarFieldEnum[]
  }

  /**
   * Food.FoodVipaka
   */
  export type Food$FoodVipakaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    where?: FoodVipakaWhereInput
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    cursor?: FoodVipakaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodVipakaScalarFieldEnum | FoodVipakaScalarFieldEnum[]
  }

  /**
   * Food.FoodDigestibility
   */
  export type Food$FoodDigestibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    where?: FoodDigestibilityWhereInput
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    cursor?: FoodDigestibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodDigestibilityScalarFieldEnum | FoodDigestibilityScalarFieldEnum[]
  }

  /**
   * Food.RecipeIngredient
   */
  export type Food$RecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * Food.DietChartRecipe
   */
  export type Food$DietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    where?: DietChartRecipeWhereInput
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    cursor?: DietChartRecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * Food without action
   */
  export type FoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
  }


  /**
   * Model Nutrient
   */

  export type AggregateNutrient = {
    _count: NutrientCountAggregateOutputType | null
    _min: NutrientMinAggregateOutputType | null
    _max: NutrientMaxAggregateOutputType | null
  }

  export type NutrientMinAggregateOutputType = {
    nutrient_id: string | null
    name: string | null
    unit: string | null
  }

  export type NutrientMaxAggregateOutputType = {
    nutrient_id: string | null
    name: string | null
    unit: string | null
  }

  export type NutrientCountAggregateOutputType = {
    nutrient_id: number
    name: number
    unit: number
    _all: number
  }


  export type NutrientMinAggregateInputType = {
    nutrient_id?: true
    name?: true
    unit?: true
  }

  export type NutrientMaxAggregateInputType = {
    nutrient_id?: true
    name?: true
    unit?: true
  }

  export type NutrientCountAggregateInputType = {
    nutrient_id?: true
    name?: true
    unit?: true
    _all?: true
  }

  export type NutrientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nutrient to aggregate.
     */
    where?: NutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nutrients to fetch.
     */
    orderBy?: NutrientOrderByWithRelationInput | NutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nutrients
    **/
    _count?: true | NutrientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutrientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutrientMaxAggregateInputType
  }

  export type GetNutrientAggregateType<T extends NutrientAggregateArgs> = {
        [P in keyof T & keyof AggregateNutrient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutrient[P]>
      : GetScalarType<T[P], AggregateNutrient[P]>
  }




  export type NutrientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutrientWhereInput
    orderBy?: NutrientOrderByWithAggregationInput | NutrientOrderByWithAggregationInput[]
    by: NutrientScalarFieldEnum[] | NutrientScalarFieldEnum
    having?: NutrientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutrientCountAggregateInputType | true
    _min?: NutrientMinAggregateInputType
    _max?: NutrientMaxAggregateInputType
  }

  export type NutrientGroupByOutputType = {
    nutrient_id: string
    name: string
    unit: string
    _count: NutrientCountAggregateOutputType | null
    _min: NutrientMinAggregateOutputType | null
    _max: NutrientMaxAggregateOutputType | null
  }

  type GetNutrientGroupByPayload<T extends NutrientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutrientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutrientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutrientGroupByOutputType[P]>
            : GetScalarType<T[P], NutrientGroupByOutputType[P]>
        }
      >
    >


  export type NutrientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nutrient_id?: boolean
    name?: boolean
    unit?: boolean
    FoodNutrient?: boolean | Nutrient$FoodNutrientArgs<ExtArgs>
    Rda?: boolean | Nutrient$RdaArgs<ExtArgs>
    _count?: boolean | NutrientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutrient"]>

  export type NutrientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nutrient_id?: boolean
    name?: boolean
    unit?: boolean
  }, ExtArgs["result"]["nutrient"]>

  export type NutrientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nutrient_id?: boolean
    name?: boolean
    unit?: boolean
  }, ExtArgs["result"]["nutrient"]>

  export type NutrientSelectScalar = {
    nutrient_id?: boolean
    name?: boolean
    unit?: boolean
  }

  export type NutrientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nutrient_id" | "name" | "unit", ExtArgs["result"]["nutrient"]>
  export type NutrientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodNutrient?: boolean | Nutrient$FoodNutrientArgs<ExtArgs>
    Rda?: boolean | Nutrient$RdaArgs<ExtArgs>
    _count?: boolean | NutrientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NutrientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NutrientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NutrientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nutrient"
    objects: {
      FoodNutrient: Prisma.$FoodNutrientPayload<ExtArgs>[]
      Rda: Prisma.$RdaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      nutrient_id: string
      name: string
      unit: string
    }, ExtArgs["result"]["nutrient"]>
    composites: {}
  }

  type NutrientGetPayload<S extends boolean | null | undefined | NutrientDefaultArgs> = $Result.GetResult<Prisma.$NutrientPayload, S>

  type NutrientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutrientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutrientCountAggregateInputType | true
    }

  export interface NutrientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nutrient'], meta: { name: 'Nutrient' } }
    /**
     * Find zero or one Nutrient that matches the filter.
     * @param {NutrientFindUniqueArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutrientFindUniqueArgs>(args: SelectSubset<T, NutrientFindUniqueArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nutrient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutrientFindUniqueOrThrowArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutrientFindUniqueOrThrowArgs>(args: SelectSubset<T, NutrientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nutrient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientFindFirstArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutrientFindFirstArgs>(args?: SelectSubset<T, NutrientFindFirstArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nutrient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientFindFirstOrThrowArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutrientFindFirstOrThrowArgs>(args?: SelectSubset<T, NutrientFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nutrients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nutrients
     * const nutrients = await prisma.nutrient.findMany()
     * 
     * // Get first 10 Nutrients
     * const nutrients = await prisma.nutrient.findMany({ take: 10 })
     * 
     * // Only select the `nutrient_id`
     * const nutrientWithNutrient_idOnly = await prisma.nutrient.findMany({ select: { nutrient_id: true } })
     * 
     */
    findMany<T extends NutrientFindManyArgs>(args?: SelectSubset<T, NutrientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nutrient.
     * @param {NutrientCreateArgs} args - Arguments to create a Nutrient.
     * @example
     * // Create one Nutrient
     * const Nutrient = await prisma.nutrient.create({
     *   data: {
     *     // ... data to create a Nutrient
     *   }
     * })
     * 
     */
    create<T extends NutrientCreateArgs>(args: SelectSubset<T, NutrientCreateArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nutrients.
     * @param {NutrientCreateManyArgs} args - Arguments to create many Nutrients.
     * @example
     * // Create many Nutrients
     * const nutrient = await prisma.nutrient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutrientCreateManyArgs>(args?: SelectSubset<T, NutrientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nutrients and returns the data saved in the database.
     * @param {NutrientCreateManyAndReturnArgs} args - Arguments to create many Nutrients.
     * @example
     * // Create many Nutrients
     * const nutrient = await prisma.nutrient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nutrients and only return the `nutrient_id`
     * const nutrientWithNutrient_idOnly = await prisma.nutrient.createManyAndReturn({
     *   select: { nutrient_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutrientCreateManyAndReturnArgs>(args?: SelectSubset<T, NutrientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nutrient.
     * @param {NutrientDeleteArgs} args - Arguments to delete one Nutrient.
     * @example
     * // Delete one Nutrient
     * const Nutrient = await prisma.nutrient.delete({
     *   where: {
     *     // ... filter to delete one Nutrient
     *   }
     * })
     * 
     */
    delete<T extends NutrientDeleteArgs>(args: SelectSubset<T, NutrientDeleteArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nutrient.
     * @param {NutrientUpdateArgs} args - Arguments to update one Nutrient.
     * @example
     * // Update one Nutrient
     * const nutrient = await prisma.nutrient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutrientUpdateArgs>(args: SelectSubset<T, NutrientUpdateArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nutrients.
     * @param {NutrientDeleteManyArgs} args - Arguments to filter Nutrients to delete.
     * @example
     * // Delete a few Nutrients
     * const { count } = await prisma.nutrient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutrientDeleteManyArgs>(args?: SelectSubset<T, NutrientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nutrients
     * const nutrient = await prisma.nutrient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutrientUpdateManyArgs>(args: SelectSubset<T, NutrientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nutrients and returns the data updated in the database.
     * @param {NutrientUpdateManyAndReturnArgs} args - Arguments to update many Nutrients.
     * @example
     * // Update many Nutrients
     * const nutrient = await prisma.nutrient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nutrients and only return the `nutrient_id`
     * const nutrientWithNutrient_idOnly = await prisma.nutrient.updateManyAndReturn({
     *   select: { nutrient_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutrientUpdateManyAndReturnArgs>(args: SelectSubset<T, NutrientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nutrient.
     * @param {NutrientUpsertArgs} args - Arguments to update or create a Nutrient.
     * @example
     * // Update or create a Nutrient
     * const nutrient = await prisma.nutrient.upsert({
     *   create: {
     *     // ... data to create a Nutrient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nutrient we want to update
     *   }
     * })
     */
    upsert<T extends NutrientUpsertArgs>(args: SelectSubset<T, NutrientUpsertArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientCountArgs} args - Arguments to filter Nutrients to count.
     * @example
     * // Count the number of Nutrients
     * const count = await prisma.nutrient.count({
     *   where: {
     *     // ... the filter for the Nutrients we want to count
     *   }
     * })
    **/
    count<T extends NutrientCountArgs>(
      args?: Subset<T, NutrientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutrientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutrientAggregateArgs>(args: Subset<T, NutrientAggregateArgs>): Prisma.PrismaPromise<GetNutrientAggregateType<T>>

    /**
     * Group by Nutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutrientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutrientGroupByArgs['orderBy'] }
        : { orderBy?: NutrientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutrientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutrientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nutrient model
   */
  readonly fields: NutrientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nutrient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutrientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodNutrient<T extends Nutrient$FoodNutrientArgs<ExtArgs> = {}>(args?: Subset<T, Nutrient$FoodNutrientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Rda<T extends Nutrient$RdaArgs<ExtArgs> = {}>(args?: Subset<T, Nutrient$RdaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nutrient model
   */
  interface NutrientFieldRefs {
    readonly nutrient_id: FieldRef<"Nutrient", 'String'>
    readonly name: FieldRef<"Nutrient", 'String'>
    readonly unit: FieldRef<"Nutrient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nutrient findUnique
   */
  export type NutrientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter, which Nutrient to fetch.
     */
    where: NutrientWhereUniqueInput
  }

  /**
   * Nutrient findUniqueOrThrow
   */
  export type NutrientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter, which Nutrient to fetch.
     */
    where: NutrientWhereUniqueInput
  }

  /**
   * Nutrient findFirst
   */
  export type NutrientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter, which Nutrient to fetch.
     */
    where?: NutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nutrients to fetch.
     */
    orderBy?: NutrientOrderByWithRelationInput | NutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nutrients.
     */
    cursor?: NutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nutrients.
     */
    distinct?: NutrientScalarFieldEnum | NutrientScalarFieldEnum[]
  }

  /**
   * Nutrient findFirstOrThrow
   */
  export type NutrientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter, which Nutrient to fetch.
     */
    where?: NutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nutrients to fetch.
     */
    orderBy?: NutrientOrderByWithRelationInput | NutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nutrients.
     */
    cursor?: NutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nutrients.
     */
    distinct?: NutrientScalarFieldEnum | NutrientScalarFieldEnum[]
  }

  /**
   * Nutrient findMany
   */
  export type NutrientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter, which Nutrients to fetch.
     */
    where?: NutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nutrients to fetch.
     */
    orderBy?: NutrientOrderByWithRelationInput | NutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nutrients.
     */
    cursor?: NutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nutrients.
     */
    skip?: number
    distinct?: NutrientScalarFieldEnum | NutrientScalarFieldEnum[]
  }

  /**
   * Nutrient create
   */
  export type NutrientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * The data needed to create a Nutrient.
     */
    data: XOR<NutrientCreateInput, NutrientUncheckedCreateInput>
  }

  /**
   * Nutrient createMany
   */
  export type NutrientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nutrients.
     */
    data: NutrientCreateManyInput | NutrientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nutrient createManyAndReturn
   */
  export type NutrientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * The data used to create many Nutrients.
     */
    data: NutrientCreateManyInput | NutrientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nutrient update
   */
  export type NutrientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * The data needed to update a Nutrient.
     */
    data: XOR<NutrientUpdateInput, NutrientUncheckedUpdateInput>
    /**
     * Choose, which Nutrient to update.
     */
    where: NutrientWhereUniqueInput
  }

  /**
   * Nutrient updateMany
   */
  export type NutrientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nutrients.
     */
    data: XOR<NutrientUpdateManyMutationInput, NutrientUncheckedUpdateManyInput>
    /**
     * Filter which Nutrients to update
     */
    where?: NutrientWhereInput
    /**
     * Limit how many Nutrients to update.
     */
    limit?: number
  }

  /**
   * Nutrient updateManyAndReturn
   */
  export type NutrientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * The data used to update Nutrients.
     */
    data: XOR<NutrientUpdateManyMutationInput, NutrientUncheckedUpdateManyInput>
    /**
     * Filter which Nutrients to update
     */
    where?: NutrientWhereInput
    /**
     * Limit how many Nutrients to update.
     */
    limit?: number
  }

  /**
   * Nutrient upsert
   */
  export type NutrientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * The filter to search for the Nutrient to update in case it exists.
     */
    where: NutrientWhereUniqueInput
    /**
     * In case the Nutrient found by the `where` argument doesn't exist, create a new Nutrient with this data.
     */
    create: XOR<NutrientCreateInput, NutrientUncheckedCreateInput>
    /**
     * In case the Nutrient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutrientUpdateInput, NutrientUncheckedUpdateInput>
  }

  /**
   * Nutrient delete
   */
  export type NutrientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
    /**
     * Filter which Nutrient to delete.
     */
    where: NutrientWhereUniqueInput
  }

  /**
   * Nutrient deleteMany
   */
  export type NutrientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nutrients to delete
     */
    where?: NutrientWhereInput
    /**
     * Limit how many Nutrients to delete.
     */
    limit?: number
  }

  /**
   * Nutrient.FoodNutrient
   */
  export type Nutrient$FoodNutrientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    where?: FoodNutrientWhereInput
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    cursor?: FoodNutrientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodNutrientScalarFieldEnum | FoodNutrientScalarFieldEnum[]
  }

  /**
   * Nutrient.Rda
   */
  export type Nutrient$RdaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    where?: RdaWhereInput
    orderBy?: RdaOrderByWithRelationInput | RdaOrderByWithRelationInput[]
    cursor?: RdaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RdaScalarFieldEnum | RdaScalarFieldEnum[]
  }

  /**
   * Nutrient without action
   */
  export type NutrientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nutrient
     */
    select?: NutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nutrient
     */
    omit?: NutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutrientInclude<ExtArgs> | null
  }


  /**
   * Model Rasa
   */

  export type AggregateRasa = {
    _count: RasaCountAggregateOutputType | null
    _min: RasaMinAggregateOutputType | null
    _max: RasaMaxAggregateOutputType | null
  }

  export type RasaMinAggregateOutputType = {
    rasa_id: string | null
    name: string | null
  }

  export type RasaMaxAggregateOutputType = {
    rasa_id: string | null
    name: string | null
  }

  export type RasaCountAggregateOutputType = {
    rasa_id: number
    name: number
    _all: number
  }


  export type RasaMinAggregateInputType = {
    rasa_id?: true
    name?: true
  }

  export type RasaMaxAggregateInputType = {
    rasa_id?: true
    name?: true
  }

  export type RasaCountAggregateInputType = {
    rasa_id?: true
    name?: true
    _all?: true
  }

  export type RasaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rasa to aggregate.
     */
    where?: RasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rasas to fetch.
     */
    orderBy?: RasaOrderByWithRelationInput | RasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rasas
    **/
    _count?: true | RasaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RasaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RasaMaxAggregateInputType
  }

  export type GetRasaAggregateType<T extends RasaAggregateArgs> = {
        [P in keyof T & keyof AggregateRasa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRasa[P]>
      : GetScalarType<T[P], AggregateRasa[P]>
  }




  export type RasaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RasaWhereInput
    orderBy?: RasaOrderByWithAggregationInput | RasaOrderByWithAggregationInput[]
    by: RasaScalarFieldEnum[] | RasaScalarFieldEnum
    having?: RasaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RasaCountAggregateInputType | true
    _min?: RasaMinAggregateInputType
    _max?: RasaMaxAggregateInputType
  }

  export type RasaGroupByOutputType = {
    rasa_id: string
    name: string
    _count: RasaCountAggregateOutputType | null
    _min: RasaMinAggregateOutputType | null
    _max: RasaMaxAggregateOutputType | null
  }

  type GetRasaGroupByPayload<T extends RasaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RasaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RasaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RasaGroupByOutputType[P]>
            : GetScalarType<T[P], RasaGroupByOutputType[P]>
        }
      >
    >


  export type RasaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rasa_id?: boolean
    name?: boolean
    FoodRasa?: boolean | Rasa$FoodRasaArgs<ExtArgs>
    _count?: boolean | RasaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rasa"]>

  export type RasaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rasa_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["rasa"]>

  export type RasaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rasa_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["rasa"]>

  export type RasaSelectScalar = {
    rasa_id?: boolean
    name?: boolean
  }

  export type RasaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"rasa_id" | "name", ExtArgs["result"]["rasa"]>
  export type RasaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodRasa?: boolean | Rasa$FoodRasaArgs<ExtArgs>
    _count?: boolean | RasaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RasaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RasaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RasaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rasa"
    objects: {
      FoodRasa: Prisma.$FoodRasaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      rasa_id: string
      name: string
    }, ExtArgs["result"]["rasa"]>
    composites: {}
  }

  type RasaGetPayload<S extends boolean | null | undefined | RasaDefaultArgs> = $Result.GetResult<Prisma.$RasaPayload, S>

  type RasaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RasaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RasaCountAggregateInputType | true
    }

  export interface RasaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rasa'], meta: { name: 'Rasa' } }
    /**
     * Find zero or one Rasa that matches the filter.
     * @param {RasaFindUniqueArgs} args - Arguments to find a Rasa
     * @example
     * // Get one Rasa
     * const rasa = await prisma.rasa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RasaFindUniqueArgs>(args: SelectSubset<T, RasaFindUniqueArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rasa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RasaFindUniqueOrThrowArgs} args - Arguments to find a Rasa
     * @example
     * // Get one Rasa
     * const rasa = await prisma.rasa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RasaFindUniqueOrThrowArgs>(args: SelectSubset<T, RasaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rasa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaFindFirstArgs} args - Arguments to find a Rasa
     * @example
     * // Get one Rasa
     * const rasa = await prisma.rasa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RasaFindFirstArgs>(args?: SelectSubset<T, RasaFindFirstArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rasa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaFindFirstOrThrowArgs} args - Arguments to find a Rasa
     * @example
     * // Get one Rasa
     * const rasa = await prisma.rasa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RasaFindFirstOrThrowArgs>(args?: SelectSubset<T, RasaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rasas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rasas
     * const rasas = await prisma.rasa.findMany()
     * 
     * // Get first 10 Rasas
     * const rasas = await prisma.rasa.findMany({ take: 10 })
     * 
     * // Only select the `rasa_id`
     * const rasaWithRasa_idOnly = await prisma.rasa.findMany({ select: { rasa_id: true } })
     * 
     */
    findMany<T extends RasaFindManyArgs>(args?: SelectSubset<T, RasaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rasa.
     * @param {RasaCreateArgs} args - Arguments to create a Rasa.
     * @example
     * // Create one Rasa
     * const Rasa = await prisma.rasa.create({
     *   data: {
     *     // ... data to create a Rasa
     *   }
     * })
     * 
     */
    create<T extends RasaCreateArgs>(args: SelectSubset<T, RasaCreateArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rasas.
     * @param {RasaCreateManyArgs} args - Arguments to create many Rasas.
     * @example
     * // Create many Rasas
     * const rasa = await prisma.rasa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RasaCreateManyArgs>(args?: SelectSubset<T, RasaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rasas and returns the data saved in the database.
     * @param {RasaCreateManyAndReturnArgs} args - Arguments to create many Rasas.
     * @example
     * // Create many Rasas
     * const rasa = await prisma.rasa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rasas and only return the `rasa_id`
     * const rasaWithRasa_idOnly = await prisma.rasa.createManyAndReturn({
     *   select: { rasa_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RasaCreateManyAndReturnArgs>(args?: SelectSubset<T, RasaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rasa.
     * @param {RasaDeleteArgs} args - Arguments to delete one Rasa.
     * @example
     * // Delete one Rasa
     * const Rasa = await prisma.rasa.delete({
     *   where: {
     *     // ... filter to delete one Rasa
     *   }
     * })
     * 
     */
    delete<T extends RasaDeleteArgs>(args: SelectSubset<T, RasaDeleteArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rasa.
     * @param {RasaUpdateArgs} args - Arguments to update one Rasa.
     * @example
     * // Update one Rasa
     * const rasa = await prisma.rasa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RasaUpdateArgs>(args: SelectSubset<T, RasaUpdateArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rasas.
     * @param {RasaDeleteManyArgs} args - Arguments to filter Rasas to delete.
     * @example
     * // Delete a few Rasas
     * const { count } = await prisma.rasa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RasaDeleteManyArgs>(args?: SelectSubset<T, RasaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rasas
     * const rasa = await prisma.rasa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RasaUpdateManyArgs>(args: SelectSubset<T, RasaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rasas and returns the data updated in the database.
     * @param {RasaUpdateManyAndReturnArgs} args - Arguments to update many Rasas.
     * @example
     * // Update many Rasas
     * const rasa = await prisma.rasa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rasas and only return the `rasa_id`
     * const rasaWithRasa_idOnly = await prisma.rasa.updateManyAndReturn({
     *   select: { rasa_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RasaUpdateManyAndReturnArgs>(args: SelectSubset<T, RasaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rasa.
     * @param {RasaUpsertArgs} args - Arguments to update or create a Rasa.
     * @example
     * // Update or create a Rasa
     * const rasa = await prisma.rasa.upsert({
     *   create: {
     *     // ... data to create a Rasa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rasa we want to update
     *   }
     * })
     */
    upsert<T extends RasaUpsertArgs>(args: SelectSubset<T, RasaUpsertArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaCountArgs} args - Arguments to filter Rasas to count.
     * @example
     * // Count the number of Rasas
     * const count = await prisma.rasa.count({
     *   where: {
     *     // ... the filter for the Rasas we want to count
     *   }
     * })
    **/
    count<T extends RasaCountArgs>(
      args?: Subset<T, RasaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RasaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rasa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RasaAggregateArgs>(args: Subset<T, RasaAggregateArgs>): Prisma.PrismaPromise<GetRasaAggregateType<T>>

    /**
     * Group by Rasa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RasaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RasaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RasaGroupByArgs['orderBy'] }
        : { orderBy?: RasaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RasaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRasaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rasa model
   */
  readonly fields: RasaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rasa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RasaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodRasa<T extends Rasa$FoodRasaArgs<ExtArgs> = {}>(args?: Subset<T, Rasa$FoodRasaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rasa model
   */
  interface RasaFieldRefs {
    readonly rasa_id: FieldRef<"Rasa", 'String'>
    readonly name: FieldRef<"Rasa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rasa findUnique
   */
  export type RasaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter, which Rasa to fetch.
     */
    where: RasaWhereUniqueInput
  }

  /**
   * Rasa findUniqueOrThrow
   */
  export type RasaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter, which Rasa to fetch.
     */
    where: RasaWhereUniqueInput
  }

  /**
   * Rasa findFirst
   */
  export type RasaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter, which Rasa to fetch.
     */
    where?: RasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rasas to fetch.
     */
    orderBy?: RasaOrderByWithRelationInput | RasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rasas.
     */
    cursor?: RasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rasas.
     */
    distinct?: RasaScalarFieldEnum | RasaScalarFieldEnum[]
  }

  /**
   * Rasa findFirstOrThrow
   */
  export type RasaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter, which Rasa to fetch.
     */
    where?: RasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rasas to fetch.
     */
    orderBy?: RasaOrderByWithRelationInput | RasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rasas.
     */
    cursor?: RasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rasas.
     */
    distinct?: RasaScalarFieldEnum | RasaScalarFieldEnum[]
  }

  /**
   * Rasa findMany
   */
  export type RasaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter, which Rasas to fetch.
     */
    where?: RasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rasas to fetch.
     */
    orderBy?: RasaOrderByWithRelationInput | RasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rasas.
     */
    cursor?: RasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rasas.
     */
    skip?: number
    distinct?: RasaScalarFieldEnum | RasaScalarFieldEnum[]
  }

  /**
   * Rasa create
   */
  export type RasaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * The data needed to create a Rasa.
     */
    data: XOR<RasaCreateInput, RasaUncheckedCreateInput>
  }

  /**
   * Rasa createMany
   */
  export type RasaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rasas.
     */
    data: RasaCreateManyInput | RasaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rasa createManyAndReturn
   */
  export type RasaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * The data used to create many Rasas.
     */
    data: RasaCreateManyInput | RasaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rasa update
   */
  export type RasaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * The data needed to update a Rasa.
     */
    data: XOR<RasaUpdateInput, RasaUncheckedUpdateInput>
    /**
     * Choose, which Rasa to update.
     */
    where: RasaWhereUniqueInput
  }

  /**
   * Rasa updateMany
   */
  export type RasaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rasas.
     */
    data: XOR<RasaUpdateManyMutationInput, RasaUncheckedUpdateManyInput>
    /**
     * Filter which Rasas to update
     */
    where?: RasaWhereInput
    /**
     * Limit how many Rasas to update.
     */
    limit?: number
  }

  /**
   * Rasa updateManyAndReturn
   */
  export type RasaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * The data used to update Rasas.
     */
    data: XOR<RasaUpdateManyMutationInput, RasaUncheckedUpdateManyInput>
    /**
     * Filter which Rasas to update
     */
    where?: RasaWhereInput
    /**
     * Limit how many Rasas to update.
     */
    limit?: number
  }

  /**
   * Rasa upsert
   */
  export type RasaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * The filter to search for the Rasa to update in case it exists.
     */
    where: RasaWhereUniqueInput
    /**
     * In case the Rasa found by the `where` argument doesn't exist, create a new Rasa with this data.
     */
    create: XOR<RasaCreateInput, RasaUncheckedCreateInput>
    /**
     * In case the Rasa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RasaUpdateInput, RasaUncheckedUpdateInput>
  }

  /**
   * Rasa delete
   */
  export type RasaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
    /**
     * Filter which Rasa to delete.
     */
    where: RasaWhereUniqueInput
  }

  /**
   * Rasa deleteMany
   */
  export type RasaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rasas to delete
     */
    where?: RasaWhereInput
    /**
     * Limit how many Rasas to delete.
     */
    limit?: number
  }

  /**
   * Rasa.FoodRasa
   */
  export type Rasa$FoodRasaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    where?: FoodRasaWhereInput
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    cursor?: FoodRasaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRasaScalarFieldEnum | FoodRasaScalarFieldEnum[]
  }

  /**
   * Rasa without action
   */
  export type RasaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rasa
     */
    select?: RasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rasa
     */
    omit?: RasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RasaInclude<ExtArgs> | null
  }


  /**
   * Model Guna
   */

  export type AggregateGuna = {
    _count: GunaCountAggregateOutputType | null
    _min: GunaMinAggregateOutputType | null
    _max: GunaMaxAggregateOutputType | null
  }

  export type GunaMinAggregateOutputType = {
    guna_id: string | null
    name: string | null
  }

  export type GunaMaxAggregateOutputType = {
    guna_id: string | null
    name: string | null
  }

  export type GunaCountAggregateOutputType = {
    guna_id: number
    name: number
    _all: number
  }


  export type GunaMinAggregateInputType = {
    guna_id?: true
    name?: true
  }

  export type GunaMaxAggregateInputType = {
    guna_id?: true
    name?: true
  }

  export type GunaCountAggregateInputType = {
    guna_id?: true
    name?: true
    _all?: true
  }

  export type GunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guna to aggregate.
     */
    where?: GunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gunas to fetch.
     */
    orderBy?: GunaOrderByWithRelationInput | GunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gunas
    **/
    _count?: true | GunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GunaMaxAggregateInputType
  }

  export type GetGunaAggregateType<T extends GunaAggregateArgs> = {
        [P in keyof T & keyof AggregateGuna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuna[P]>
      : GetScalarType<T[P], AggregateGuna[P]>
  }




  export type GunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GunaWhereInput
    orderBy?: GunaOrderByWithAggregationInput | GunaOrderByWithAggregationInput[]
    by: GunaScalarFieldEnum[] | GunaScalarFieldEnum
    having?: GunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GunaCountAggregateInputType | true
    _min?: GunaMinAggregateInputType
    _max?: GunaMaxAggregateInputType
  }

  export type GunaGroupByOutputType = {
    guna_id: string
    name: string
    _count: GunaCountAggregateOutputType | null
    _min: GunaMinAggregateOutputType | null
    _max: GunaMaxAggregateOutputType | null
  }

  type GetGunaGroupByPayload<T extends GunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GunaGroupByOutputType[P]>
            : GetScalarType<T[P], GunaGroupByOutputType[P]>
        }
      >
    >


  export type GunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guna_id?: boolean
    name?: boolean
    FoodGuna?: boolean | Guna$FoodGunaArgs<ExtArgs>
    _count?: boolean | GunaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guna"]>

  export type GunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guna_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["guna"]>

  export type GunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guna_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["guna"]>

  export type GunaSelectScalar = {
    guna_id?: boolean
    name?: boolean
  }

  export type GunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"guna_id" | "name", ExtArgs["result"]["guna"]>
  export type GunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodGuna?: boolean | Guna$FoodGunaArgs<ExtArgs>
    _count?: boolean | GunaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guna"
    objects: {
      FoodGuna: Prisma.$FoodGunaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      guna_id: string
      name: string
    }, ExtArgs["result"]["guna"]>
    composites: {}
  }

  type GunaGetPayload<S extends boolean | null | undefined | GunaDefaultArgs> = $Result.GetResult<Prisma.$GunaPayload, S>

  type GunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GunaCountAggregateInputType | true
    }

  export interface GunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guna'], meta: { name: 'Guna' } }
    /**
     * Find zero or one Guna that matches the filter.
     * @param {GunaFindUniqueArgs} args - Arguments to find a Guna
     * @example
     * // Get one Guna
     * const guna = await prisma.guna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GunaFindUniqueArgs>(args: SelectSubset<T, GunaFindUniqueArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GunaFindUniqueOrThrowArgs} args - Arguments to find a Guna
     * @example
     * // Get one Guna
     * const guna = await prisma.guna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GunaFindUniqueOrThrowArgs>(args: SelectSubset<T, GunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaFindFirstArgs} args - Arguments to find a Guna
     * @example
     * // Get one Guna
     * const guna = await prisma.guna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GunaFindFirstArgs>(args?: SelectSubset<T, GunaFindFirstArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaFindFirstOrThrowArgs} args - Arguments to find a Guna
     * @example
     * // Get one Guna
     * const guna = await prisma.guna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GunaFindFirstOrThrowArgs>(args?: SelectSubset<T, GunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gunas
     * const gunas = await prisma.guna.findMany()
     * 
     * // Get first 10 Gunas
     * const gunas = await prisma.guna.findMany({ take: 10 })
     * 
     * // Only select the `guna_id`
     * const gunaWithGuna_idOnly = await prisma.guna.findMany({ select: { guna_id: true } })
     * 
     */
    findMany<T extends GunaFindManyArgs>(args?: SelectSubset<T, GunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guna.
     * @param {GunaCreateArgs} args - Arguments to create a Guna.
     * @example
     * // Create one Guna
     * const Guna = await prisma.guna.create({
     *   data: {
     *     // ... data to create a Guna
     *   }
     * })
     * 
     */
    create<T extends GunaCreateArgs>(args: SelectSubset<T, GunaCreateArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gunas.
     * @param {GunaCreateManyArgs} args - Arguments to create many Gunas.
     * @example
     * // Create many Gunas
     * const guna = await prisma.guna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GunaCreateManyArgs>(args?: SelectSubset<T, GunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gunas and returns the data saved in the database.
     * @param {GunaCreateManyAndReturnArgs} args - Arguments to create many Gunas.
     * @example
     * // Create many Gunas
     * const guna = await prisma.guna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gunas and only return the `guna_id`
     * const gunaWithGuna_idOnly = await prisma.guna.createManyAndReturn({
     *   select: { guna_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GunaCreateManyAndReturnArgs>(args?: SelectSubset<T, GunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guna.
     * @param {GunaDeleteArgs} args - Arguments to delete one Guna.
     * @example
     * // Delete one Guna
     * const Guna = await prisma.guna.delete({
     *   where: {
     *     // ... filter to delete one Guna
     *   }
     * })
     * 
     */
    delete<T extends GunaDeleteArgs>(args: SelectSubset<T, GunaDeleteArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guna.
     * @param {GunaUpdateArgs} args - Arguments to update one Guna.
     * @example
     * // Update one Guna
     * const guna = await prisma.guna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GunaUpdateArgs>(args: SelectSubset<T, GunaUpdateArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gunas.
     * @param {GunaDeleteManyArgs} args - Arguments to filter Gunas to delete.
     * @example
     * // Delete a few Gunas
     * const { count } = await prisma.guna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GunaDeleteManyArgs>(args?: SelectSubset<T, GunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gunas
     * const guna = await prisma.guna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GunaUpdateManyArgs>(args: SelectSubset<T, GunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gunas and returns the data updated in the database.
     * @param {GunaUpdateManyAndReturnArgs} args - Arguments to update many Gunas.
     * @example
     * // Update many Gunas
     * const guna = await prisma.guna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gunas and only return the `guna_id`
     * const gunaWithGuna_idOnly = await prisma.guna.updateManyAndReturn({
     *   select: { guna_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GunaUpdateManyAndReturnArgs>(args: SelectSubset<T, GunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guna.
     * @param {GunaUpsertArgs} args - Arguments to update or create a Guna.
     * @example
     * // Update or create a Guna
     * const guna = await prisma.guna.upsert({
     *   create: {
     *     // ... data to create a Guna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guna we want to update
     *   }
     * })
     */
    upsert<T extends GunaUpsertArgs>(args: SelectSubset<T, GunaUpsertArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaCountArgs} args - Arguments to filter Gunas to count.
     * @example
     * // Count the number of Gunas
     * const count = await prisma.guna.count({
     *   where: {
     *     // ... the filter for the Gunas we want to count
     *   }
     * })
    **/
    count<T extends GunaCountArgs>(
      args?: Subset<T, GunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GunaAggregateArgs>(args: Subset<T, GunaAggregateArgs>): Prisma.PrismaPromise<GetGunaAggregateType<T>>

    /**
     * Group by Guna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GunaGroupByArgs['orderBy'] }
        : { orderBy?: GunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guna model
   */
  readonly fields: GunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodGuna<T extends Guna$FoodGunaArgs<ExtArgs> = {}>(args?: Subset<T, Guna$FoodGunaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guna model
   */
  interface GunaFieldRefs {
    readonly guna_id: FieldRef<"Guna", 'String'>
    readonly name: FieldRef<"Guna", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Guna findUnique
   */
  export type GunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter, which Guna to fetch.
     */
    where: GunaWhereUniqueInput
  }

  /**
   * Guna findUniqueOrThrow
   */
  export type GunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter, which Guna to fetch.
     */
    where: GunaWhereUniqueInput
  }

  /**
   * Guna findFirst
   */
  export type GunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter, which Guna to fetch.
     */
    where?: GunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gunas to fetch.
     */
    orderBy?: GunaOrderByWithRelationInput | GunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gunas.
     */
    cursor?: GunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gunas.
     */
    distinct?: GunaScalarFieldEnum | GunaScalarFieldEnum[]
  }

  /**
   * Guna findFirstOrThrow
   */
  export type GunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter, which Guna to fetch.
     */
    where?: GunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gunas to fetch.
     */
    orderBy?: GunaOrderByWithRelationInput | GunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gunas.
     */
    cursor?: GunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gunas.
     */
    distinct?: GunaScalarFieldEnum | GunaScalarFieldEnum[]
  }

  /**
   * Guna findMany
   */
  export type GunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter, which Gunas to fetch.
     */
    where?: GunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gunas to fetch.
     */
    orderBy?: GunaOrderByWithRelationInput | GunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gunas.
     */
    cursor?: GunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gunas.
     */
    skip?: number
    distinct?: GunaScalarFieldEnum | GunaScalarFieldEnum[]
  }

  /**
   * Guna create
   */
  export type GunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * The data needed to create a Guna.
     */
    data: XOR<GunaCreateInput, GunaUncheckedCreateInput>
  }

  /**
   * Guna createMany
   */
  export type GunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gunas.
     */
    data: GunaCreateManyInput | GunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guna createManyAndReturn
   */
  export type GunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * The data used to create many Gunas.
     */
    data: GunaCreateManyInput | GunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guna update
   */
  export type GunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * The data needed to update a Guna.
     */
    data: XOR<GunaUpdateInput, GunaUncheckedUpdateInput>
    /**
     * Choose, which Guna to update.
     */
    where: GunaWhereUniqueInput
  }

  /**
   * Guna updateMany
   */
  export type GunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gunas.
     */
    data: XOR<GunaUpdateManyMutationInput, GunaUncheckedUpdateManyInput>
    /**
     * Filter which Gunas to update
     */
    where?: GunaWhereInput
    /**
     * Limit how many Gunas to update.
     */
    limit?: number
  }

  /**
   * Guna updateManyAndReturn
   */
  export type GunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * The data used to update Gunas.
     */
    data: XOR<GunaUpdateManyMutationInput, GunaUncheckedUpdateManyInput>
    /**
     * Filter which Gunas to update
     */
    where?: GunaWhereInput
    /**
     * Limit how many Gunas to update.
     */
    limit?: number
  }

  /**
   * Guna upsert
   */
  export type GunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * The filter to search for the Guna to update in case it exists.
     */
    where: GunaWhereUniqueInput
    /**
     * In case the Guna found by the `where` argument doesn't exist, create a new Guna with this data.
     */
    create: XOR<GunaCreateInput, GunaUncheckedCreateInput>
    /**
     * In case the Guna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GunaUpdateInput, GunaUncheckedUpdateInput>
  }

  /**
   * Guna delete
   */
  export type GunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
    /**
     * Filter which Guna to delete.
     */
    where: GunaWhereUniqueInput
  }

  /**
   * Guna deleteMany
   */
  export type GunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gunas to delete
     */
    where?: GunaWhereInput
    /**
     * Limit how many Gunas to delete.
     */
    limit?: number
  }

  /**
   * Guna.FoodGuna
   */
  export type Guna$FoodGunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    where?: FoodGunaWhereInput
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    cursor?: FoodGunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodGunaScalarFieldEnum | FoodGunaScalarFieldEnum[]
  }

  /**
   * Guna without action
   */
  export type GunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guna
     */
    select?: GunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guna
     */
    omit?: GunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GunaInclude<ExtArgs> | null
  }


  /**
   * Model Dosha
   */

  export type AggregateDosha = {
    _count: DoshaCountAggregateOutputType | null
    _min: DoshaMinAggregateOutputType | null
    _max: DoshaMaxAggregateOutputType | null
  }

  export type DoshaMinAggregateOutputType = {
    dosha_id: string | null
    name: string | null
  }

  export type DoshaMaxAggregateOutputType = {
    dosha_id: string | null
    name: string | null
  }

  export type DoshaCountAggregateOutputType = {
    dosha_id: number
    name: number
    _all: number
  }


  export type DoshaMinAggregateInputType = {
    dosha_id?: true
    name?: true
  }

  export type DoshaMaxAggregateInputType = {
    dosha_id?: true
    name?: true
  }

  export type DoshaCountAggregateInputType = {
    dosha_id?: true
    name?: true
    _all?: true
  }

  export type DoshaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dosha to aggregate.
     */
    where?: DoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doshas to fetch.
     */
    orderBy?: DoshaOrderByWithRelationInput | DoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doshas
    **/
    _count?: true | DoshaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoshaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoshaMaxAggregateInputType
  }

  export type GetDoshaAggregateType<T extends DoshaAggregateArgs> = {
        [P in keyof T & keyof AggregateDosha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDosha[P]>
      : GetScalarType<T[P], AggregateDosha[P]>
  }




  export type DoshaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoshaWhereInput
    orderBy?: DoshaOrderByWithAggregationInput | DoshaOrderByWithAggregationInput[]
    by: DoshaScalarFieldEnum[] | DoshaScalarFieldEnum
    having?: DoshaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoshaCountAggregateInputType | true
    _min?: DoshaMinAggregateInputType
    _max?: DoshaMaxAggregateInputType
  }

  export type DoshaGroupByOutputType = {
    dosha_id: string
    name: string
    _count: DoshaCountAggregateOutputType | null
    _min: DoshaMinAggregateOutputType | null
    _max: DoshaMaxAggregateOutputType | null
  }

  type GetDoshaGroupByPayload<T extends DoshaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoshaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoshaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoshaGroupByOutputType[P]>
            : GetScalarType<T[P], DoshaGroupByOutputType[P]>
        }
      >
    >


  export type DoshaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dosha_id?: boolean
    name?: boolean
    FoodDosha?: boolean | Dosha$FoodDoshaArgs<ExtArgs>
    PatientDosha?: boolean | Dosha$PatientDoshaArgs<ExtArgs>
    _count?: boolean | DoshaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dosha"]>

  export type DoshaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dosha_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["dosha"]>

  export type DoshaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dosha_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["dosha"]>

  export type DoshaSelectScalar = {
    dosha_id?: boolean
    name?: boolean
  }

  export type DoshaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dosha_id" | "name", ExtArgs["result"]["dosha"]>
  export type DoshaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodDosha?: boolean | Dosha$FoodDoshaArgs<ExtArgs>
    PatientDosha?: boolean | Dosha$PatientDoshaArgs<ExtArgs>
    _count?: boolean | DoshaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoshaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DoshaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DoshaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dosha"
    objects: {
      FoodDosha: Prisma.$FoodDoshaPayload<ExtArgs>[]
      PatientDosha: Prisma.$PatientDoshaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      dosha_id: string
      name: string
    }, ExtArgs["result"]["dosha"]>
    composites: {}
  }

  type DoshaGetPayload<S extends boolean | null | undefined | DoshaDefaultArgs> = $Result.GetResult<Prisma.$DoshaPayload, S>

  type DoshaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoshaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoshaCountAggregateInputType | true
    }

  export interface DoshaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dosha'], meta: { name: 'Dosha' } }
    /**
     * Find zero or one Dosha that matches the filter.
     * @param {DoshaFindUniqueArgs} args - Arguments to find a Dosha
     * @example
     * // Get one Dosha
     * const dosha = await prisma.dosha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoshaFindUniqueArgs>(args: SelectSubset<T, DoshaFindUniqueArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dosha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoshaFindUniqueOrThrowArgs} args - Arguments to find a Dosha
     * @example
     * // Get one Dosha
     * const dosha = await prisma.dosha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoshaFindUniqueOrThrowArgs>(args: SelectSubset<T, DoshaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dosha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaFindFirstArgs} args - Arguments to find a Dosha
     * @example
     * // Get one Dosha
     * const dosha = await prisma.dosha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoshaFindFirstArgs>(args?: SelectSubset<T, DoshaFindFirstArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dosha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaFindFirstOrThrowArgs} args - Arguments to find a Dosha
     * @example
     * // Get one Dosha
     * const dosha = await prisma.dosha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoshaFindFirstOrThrowArgs>(args?: SelectSubset<T, DoshaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doshas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doshas
     * const doshas = await prisma.dosha.findMany()
     * 
     * // Get first 10 Doshas
     * const doshas = await prisma.dosha.findMany({ take: 10 })
     * 
     * // Only select the `dosha_id`
     * const doshaWithDosha_idOnly = await prisma.dosha.findMany({ select: { dosha_id: true } })
     * 
     */
    findMany<T extends DoshaFindManyArgs>(args?: SelectSubset<T, DoshaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dosha.
     * @param {DoshaCreateArgs} args - Arguments to create a Dosha.
     * @example
     * // Create one Dosha
     * const Dosha = await prisma.dosha.create({
     *   data: {
     *     // ... data to create a Dosha
     *   }
     * })
     * 
     */
    create<T extends DoshaCreateArgs>(args: SelectSubset<T, DoshaCreateArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doshas.
     * @param {DoshaCreateManyArgs} args - Arguments to create many Doshas.
     * @example
     * // Create many Doshas
     * const dosha = await prisma.dosha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoshaCreateManyArgs>(args?: SelectSubset<T, DoshaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doshas and returns the data saved in the database.
     * @param {DoshaCreateManyAndReturnArgs} args - Arguments to create many Doshas.
     * @example
     * // Create many Doshas
     * const dosha = await prisma.dosha.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doshas and only return the `dosha_id`
     * const doshaWithDosha_idOnly = await prisma.dosha.createManyAndReturn({
     *   select: { dosha_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoshaCreateManyAndReturnArgs>(args?: SelectSubset<T, DoshaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dosha.
     * @param {DoshaDeleteArgs} args - Arguments to delete one Dosha.
     * @example
     * // Delete one Dosha
     * const Dosha = await prisma.dosha.delete({
     *   where: {
     *     // ... filter to delete one Dosha
     *   }
     * })
     * 
     */
    delete<T extends DoshaDeleteArgs>(args: SelectSubset<T, DoshaDeleteArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dosha.
     * @param {DoshaUpdateArgs} args - Arguments to update one Dosha.
     * @example
     * // Update one Dosha
     * const dosha = await prisma.dosha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoshaUpdateArgs>(args: SelectSubset<T, DoshaUpdateArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doshas.
     * @param {DoshaDeleteManyArgs} args - Arguments to filter Doshas to delete.
     * @example
     * // Delete a few Doshas
     * const { count } = await prisma.dosha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoshaDeleteManyArgs>(args?: SelectSubset<T, DoshaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doshas
     * const dosha = await prisma.dosha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoshaUpdateManyArgs>(args: SelectSubset<T, DoshaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doshas and returns the data updated in the database.
     * @param {DoshaUpdateManyAndReturnArgs} args - Arguments to update many Doshas.
     * @example
     * // Update many Doshas
     * const dosha = await prisma.dosha.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doshas and only return the `dosha_id`
     * const doshaWithDosha_idOnly = await prisma.dosha.updateManyAndReturn({
     *   select: { dosha_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoshaUpdateManyAndReturnArgs>(args: SelectSubset<T, DoshaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dosha.
     * @param {DoshaUpsertArgs} args - Arguments to update or create a Dosha.
     * @example
     * // Update or create a Dosha
     * const dosha = await prisma.dosha.upsert({
     *   create: {
     *     // ... data to create a Dosha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dosha we want to update
     *   }
     * })
     */
    upsert<T extends DoshaUpsertArgs>(args: SelectSubset<T, DoshaUpsertArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaCountArgs} args - Arguments to filter Doshas to count.
     * @example
     * // Count the number of Doshas
     * const count = await prisma.dosha.count({
     *   where: {
     *     // ... the filter for the Doshas we want to count
     *   }
     * })
    **/
    count<T extends DoshaCountArgs>(
      args?: Subset<T, DoshaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoshaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoshaAggregateArgs>(args: Subset<T, DoshaAggregateArgs>): Prisma.PrismaPromise<GetDoshaAggregateType<T>>

    /**
     * Group by Dosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoshaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoshaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoshaGroupByArgs['orderBy'] }
        : { orderBy?: DoshaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoshaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoshaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dosha model
   */
  readonly fields: DoshaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dosha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoshaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodDosha<T extends Dosha$FoodDoshaArgs<ExtArgs> = {}>(args?: Subset<T, Dosha$FoodDoshaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PatientDosha<T extends Dosha$PatientDoshaArgs<ExtArgs> = {}>(args?: Subset<T, Dosha$PatientDoshaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dosha model
   */
  interface DoshaFieldRefs {
    readonly dosha_id: FieldRef<"Dosha", 'String'>
    readonly name: FieldRef<"Dosha", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dosha findUnique
   */
  export type DoshaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter, which Dosha to fetch.
     */
    where: DoshaWhereUniqueInput
  }

  /**
   * Dosha findUniqueOrThrow
   */
  export type DoshaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter, which Dosha to fetch.
     */
    where: DoshaWhereUniqueInput
  }

  /**
   * Dosha findFirst
   */
  export type DoshaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter, which Dosha to fetch.
     */
    where?: DoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doshas to fetch.
     */
    orderBy?: DoshaOrderByWithRelationInput | DoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doshas.
     */
    cursor?: DoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doshas.
     */
    distinct?: DoshaScalarFieldEnum | DoshaScalarFieldEnum[]
  }

  /**
   * Dosha findFirstOrThrow
   */
  export type DoshaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter, which Dosha to fetch.
     */
    where?: DoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doshas to fetch.
     */
    orderBy?: DoshaOrderByWithRelationInput | DoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doshas.
     */
    cursor?: DoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doshas.
     */
    distinct?: DoshaScalarFieldEnum | DoshaScalarFieldEnum[]
  }

  /**
   * Dosha findMany
   */
  export type DoshaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter, which Doshas to fetch.
     */
    where?: DoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doshas to fetch.
     */
    orderBy?: DoshaOrderByWithRelationInput | DoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doshas.
     */
    cursor?: DoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doshas.
     */
    skip?: number
    distinct?: DoshaScalarFieldEnum | DoshaScalarFieldEnum[]
  }

  /**
   * Dosha create
   */
  export type DoshaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * The data needed to create a Dosha.
     */
    data: XOR<DoshaCreateInput, DoshaUncheckedCreateInput>
  }

  /**
   * Dosha createMany
   */
  export type DoshaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doshas.
     */
    data: DoshaCreateManyInput | DoshaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dosha createManyAndReturn
   */
  export type DoshaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * The data used to create many Doshas.
     */
    data: DoshaCreateManyInput | DoshaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dosha update
   */
  export type DoshaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * The data needed to update a Dosha.
     */
    data: XOR<DoshaUpdateInput, DoshaUncheckedUpdateInput>
    /**
     * Choose, which Dosha to update.
     */
    where: DoshaWhereUniqueInput
  }

  /**
   * Dosha updateMany
   */
  export type DoshaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doshas.
     */
    data: XOR<DoshaUpdateManyMutationInput, DoshaUncheckedUpdateManyInput>
    /**
     * Filter which Doshas to update
     */
    where?: DoshaWhereInput
    /**
     * Limit how many Doshas to update.
     */
    limit?: number
  }

  /**
   * Dosha updateManyAndReturn
   */
  export type DoshaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * The data used to update Doshas.
     */
    data: XOR<DoshaUpdateManyMutationInput, DoshaUncheckedUpdateManyInput>
    /**
     * Filter which Doshas to update
     */
    where?: DoshaWhereInput
    /**
     * Limit how many Doshas to update.
     */
    limit?: number
  }

  /**
   * Dosha upsert
   */
  export type DoshaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * The filter to search for the Dosha to update in case it exists.
     */
    where: DoshaWhereUniqueInput
    /**
     * In case the Dosha found by the `where` argument doesn't exist, create a new Dosha with this data.
     */
    create: XOR<DoshaCreateInput, DoshaUncheckedCreateInput>
    /**
     * In case the Dosha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoshaUpdateInput, DoshaUncheckedUpdateInput>
  }

  /**
   * Dosha delete
   */
  export type DoshaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
    /**
     * Filter which Dosha to delete.
     */
    where: DoshaWhereUniqueInput
  }

  /**
   * Dosha deleteMany
   */
  export type DoshaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doshas to delete
     */
    where?: DoshaWhereInput
    /**
     * Limit how many Doshas to delete.
     */
    limit?: number
  }

  /**
   * Dosha.FoodDosha
   */
  export type Dosha$FoodDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    where?: FoodDoshaWhereInput
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    cursor?: FoodDoshaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodDoshaScalarFieldEnum | FoodDoshaScalarFieldEnum[]
  }

  /**
   * Dosha.PatientDosha
   */
  export type Dosha$PatientDoshaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    where?: PatientDoshaWhereInput
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    cursor?: PatientDoshaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientDoshaScalarFieldEnum | PatientDoshaScalarFieldEnum[]
  }

  /**
   * Dosha without action
   */
  export type DoshaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosha
     */
    select?: DoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dosha
     */
    omit?: DoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoshaInclude<ExtArgs> | null
  }


  /**
   * Model Virya
   */

  export type AggregateVirya = {
    _count: ViryaCountAggregateOutputType | null
    _min: ViryaMinAggregateOutputType | null
    _max: ViryaMaxAggregateOutputType | null
  }

  export type ViryaMinAggregateOutputType = {
    virya_id: string | null
    name: string | null
  }

  export type ViryaMaxAggregateOutputType = {
    virya_id: string | null
    name: string | null
  }

  export type ViryaCountAggregateOutputType = {
    virya_id: number
    name: number
    _all: number
  }


  export type ViryaMinAggregateInputType = {
    virya_id?: true
    name?: true
  }

  export type ViryaMaxAggregateInputType = {
    virya_id?: true
    name?: true
  }

  export type ViryaCountAggregateInputType = {
    virya_id?: true
    name?: true
    _all?: true
  }

  export type ViryaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Virya to aggregate.
     */
    where?: ViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viryas to fetch.
     */
    orderBy?: ViryaOrderByWithRelationInput | ViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Viryas
    **/
    _count?: true | ViryaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViryaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViryaMaxAggregateInputType
  }

  export type GetViryaAggregateType<T extends ViryaAggregateArgs> = {
        [P in keyof T & keyof AggregateVirya]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirya[P]>
      : GetScalarType<T[P], AggregateVirya[P]>
  }




  export type ViryaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViryaWhereInput
    orderBy?: ViryaOrderByWithAggregationInput | ViryaOrderByWithAggregationInput[]
    by: ViryaScalarFieldEnum[] | ViryaScalarFieldEnum
    having?: ViryaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViryaCountAggregateInputType | true
    _min?: ViryaMinAggregateInputType
    _max?: ViryaMaxAggregateInputType
  }

  export type ViryaGroupByOutputType = {
    virya_id: string
    name: string
    _count: ViryaCountAggregateOutputType | null
    _min: ViryaMinAggregateOutputType | null
    _max: ViryaMaxAggregateOutputType | null
  }

  type GetViryaGroupByPayload<T extends ViryaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViryaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViryaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViryaGroupByOutputType[P]>
            : GetScalarType<T[P], ViryaGroupByOutputType[P]>
        }
      >
    >


  export type ViryaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    virya_id?: boolean
    name?: boolean
    FoodVirya?: boolean | Virya$FoodViryaArgs<ExtArgs>
    _count?: boolean | ViryaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virya"]>

  export type ViryaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    virya_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["virya"]>

  export type ViryaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    virya_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["virya"]>

  export type ViryaSelectScalar = {
    virya_id?: boolean
    name?: boolean
  }

  export type ViryaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"virya_id" | "name", ExtArgs["result"]["virya"]>
  export type ViryaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodVirya?: boolean | Virya$FoodViryaArgs<ExtArgs>
    _count?: boolean | ViryaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViryaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ViryaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ViryaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Virya"
    objects: {
      FoodVirya: Prisma.$FoodViryaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      virya_id: string
      name: string
    }, ExtArgs["result"]["virya"]>
    composites: {}
  }

  type ViryaGetPayload<S extends boolean | null | undefined | ViryaDefaultArgs> = $Result.GetResult<Prisma.$ViryaPayload, S>

  type ViryaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViryaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViryaCountAggregateInputType | true
    }

  export interface ViryaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Virya'], meta: { name: 'Virya' } }
    /**
     * Find zero or one Virya that matches the filter.
     * @param {ViryaFindUniqueArgs} args - Arguments to find a Virya
     * @example
     * // Get one Virya
     * const virya = await prisma.virya.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViryaFindUniqueArgs>(args: SelectSubset<T, ViryaFindUniqueArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Virya that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViryaFindUniqueOrThrowArgs} args - Arguments to find a Virya
     * @example
     * // Get one Virya
     * const virya = await prisma.virya.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViryaFindUniqueOrThrowArgs>(args: SelectSubset<T, ViryaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virya that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaFindFirstArgs} args - Arguments to find a Virya
     * @example
     * // Get one Virya
     * const virya = await prisma.virya.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViryaFindFirstArgs>(args?: SelectSubset<T, ViryaFindFirstArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virya that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaFindFirstOrThrowArgs} args - Arguments to find a Virya
     * @example
     * // Get one Virya
     * const virya = await prisma.virya.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViryaFindFirstOrThrowArgs>(args?: SelectSubset<T, ViryaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viryas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viryas
     * const viryas = await prisma.virya.findMany()
     * 
     * // Get first 10 Viryas
     * const viryas = await prisma.virya.findMany({ take: 10 })
     * 
     * // Only select the `virya_id`
     * const viryaWithVirya_idOnly = await prisma.virya.findMany({ select: { virya_id: true } })
     * 
     */
    findMany<T extends ViryaFindManyArgs>(args?: SelectSubset<T, ViryaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Virya.
     * @param {ViryaCreateArgs} args - Arguments to create a Virya.
     * @example
     * // Create one Virya
     * const Virya = await prisma.virya.create({
     *   data: {
     *     // ... data to create a Virya
     *   }
     * })
     * 
     */
    create<T extends ViryaCreateArgs>(args: SelectSubset<T, ViryaCreateArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viryas.
     * @param {ViryaCreateManyArgs} args - Arguments to create many Viryas.
     * @example
     * // Create many Viryas
     * const virya = await prisma.virya.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViryaCreateManyArgs>(args?: SelectSubset<T, ViryaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viryas and returns the data saved in the database.
     * @param {ViryaCreateManyAndReturnArgs} args - Arguments to create many Viryas.
     * @example
     * // Create many Viryas
     * const virya = await prisma.virya.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viryas and only return the `virya_id`
     * const viryaWithVirya_idOnly = await prisma.virya.createManyAndReturn({
     *   select: { virya_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViryaCreateManyAndReturnArgs>(args?: SelectSubset<T, ViryaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Virya.
     * @param {ViryaDeleteArgs} args - Arguments to delete one Virya.
     * @example
     * // Delete one Virya
     * const Virya = await prisma.virya.delete({
     *   where: {
     *     // ... filter to delete one Virya
     *   }
     * })
     * 
     */
    delete<T extends ViryaDeleteArgs>(args: SelectSubset<T, ViryaDeleteArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Virya.
     * @param {ViryaUpdateArgs} args - Arguments to update one Virya.
     * @example
     * // Update one Virya
     * const virya = await prisma.virya.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViryaUpdateArgs>(args: SelectSubset<T, ViryaUpdateArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viryas.
     * @param {ViryaDeleteManyArgs} args - Arguments to filter Viryas to delete.
     * @example
     * // Delete a few Viryas
     * const { count } = await prisma.virya.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViryaDeleteManyArgs>(args?: SelectSubset<T, ViryaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viryas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viryas
     * const virya = await prisma.virya.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViryaUpdateManyArgs>(args: SelectSubset<T, ViryaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viryas and returns the data updated in the database.
     * @param {ViryaUpdateManyAndReturnArgs} args - Arguments to update many Viryas.
     * @example
     * // Update many Viryas
     * const virya = await prisma.virya.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viryas and only return the `virya_id`
     * const viryaWithVirya_idOnly = await prisma.virya.updateManyAndReturn({
     *   select: { virya_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViryaUpdateManyAndReturnArgs>(args: SelectSubset<T, ViryaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Virya.
     * @param {ViryaUpsertArgs} args - Arguments to update or create a Virya.
     * @example
     * // Update or create a Virya
     * const virya = await prisma.virya.upsert({
     *   create: {
     *     // ... data to create a Virya
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Virya we want to update
     *   }
     * })
     */
    upsert<T extends ViryaUpsertArgs>(args: SelectSubset<T, ViryaUpsertArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viryas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaCountArgs} args - Arguments to filter Viryas to count.
     * @example
     * // Count the number of Viryas
     * const count = await prisma.virya.count({
     *   where: {
     *     // ... the filter for the Viryas we want to count
     *   }
     * })
    **/
    count<T extends ViryaCountArgs>(
      args?: Subset<T, ViryaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViryaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Virya.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViryaAggregateArgs>(args: Subset<T, ViryaAggregateArgs>): Prisma.PrismaPromise<GetViryaAggregateType<T>>

    /**
     * Group by Virya.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViryaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViryaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViryaGroupByArgs['orderBy'] }
        : { orderBy?: ViryaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViryaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViryaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Virya model
   */
  readonly fields: ViryaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Virya.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViryaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodVirya<T extends Virya$FoodViryaArgs<ExtArgs> = {}>(args?: Subset<T, Virya$FoodViryaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Virya model
   */
  interface ViryaFieldRefs {
    readonly virya_id: FieldRef<"Virya", 'String'>
    readonly name: FieldRef<"Virya", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Virya findUnique
   */
  export type ViryaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter, which Virya to fetch.
     */
    where: ViryaWhereUniqueInput
  }

  /**
   * Virya findUniqueOrThrow
   */
  export type ViryaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter, which Virya to fetch.
     */
    where: ViryaWhereUniqueInput
  }

  /**
   * Virya findFirst
   */
  export type ViryaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter, which Virya to fetch.
     */
    where?: ViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viryas to fetch.
     */
    orderBy?: ViryaOrderByWithRelationInput | ViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viryas.
     */
    cursor?: ViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viryas.
     */
    distinct?: ViryaScalarFieldEnum | ViryaScalarFieldEnum[]
  }

  /**
   * Virya findFirstOrThrow
   */
  export type ViryaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter, which Virya to fetch.
     */
    where?: ViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viryas to fetch.
     */
    orderBy?: ViryaOrderByWithRelationInput | ViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viryas.
     */
    cursor?: ViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viryas.
     */
    distinct?: ViryaScalarFieldEnum | ViryaScalarFieldEnum[]
  }

  /**
   * Virya findMany
   */
  export type ViryaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter, which Viryas to fetch.
     */
    where?: ViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viryas to fetch.
     */
    orderBy?: ViryaOrderByWithRelationInput | ViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Viryas.
     */
    cursor?: ViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viryas.
     */
    skip?: number
    distinct?: ViryaScalarFieldEnum | ViryaScalarFieldEnum[]
  }

  /**
   * Virya create
   */
  export type ViryaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * The data needed to create a Virya.
     */
    data: XOR<ViryaCreateInput, ViryaUncheckedCreateInput>
  }

  /**
   * Virya createMany
   */
  export type ViryaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Viryas.
     */
    data: ViryaCreateManyInput | ViryaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Virya createManyAndReturn
   */
  export type ViryaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * The data used to create many Viryas.
     */
    data: ViryaCreateManyInput | ViryaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Virya update
   */
  export type ViryaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * The data needed to update a Virya.
     */
    data: XOR<ViryaUpdateInput, ViryaUncheckedUpdateInput>
    /**
     * Choose, which Virya to update.
     */
    where: ViryaWhereUniqueInput
  }

  /**
   * Virya updateMany
   */
  export type ViryaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Viryas.
     */
    data: XOR<ViryaUpdateManyMutationInput, ViryaUncheckedUpdateManyInput>
    /**
     * Filter which Viryas to update
     */
    where?: ViryaWhereInput
    /**
     * Limit how many Viryas to update.
     */
    limit?: number
  }

  /**
   * Virya updateManyAndReturn
   */
  export type ViryaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * The data used to update Viryas.
     */
    data: XOR<ViryaUpdateManyMutationInput, ViryaUncheckedUpdateManyInput>
    /**
     * Filter which Viryas to update
     */
    where?: ViryaWhereInput
    /**
     * Limit how many Viryas to update.
     */
    limit?: number
  }

  /**
   * Virya upsert
   */
  export type ViryaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * The filter to search for the Virya to update in case it exists.
     */
    where: ViryaWhereUniqueInput
    /**
     * In case the Virya found by the `where` argument doesn't exist, create a new Virya with this data.
     */
    create: XOR<ViryaCreateInput, ViryaUncheckedCreateInput>
    /**
     * In case the Virya was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViryaUpdateInput, ViryaUncheckedUpdateInput>
  }

  /**
   * Virya delete
   */
  export type ViryaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
    /**
     * Filter which Virya to delete.
     */
    where: ViryaWhereUniqueInput
  }

  /**
   * Virya deleteMany
   */
  export type ViryaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viryas to delete
     */
    where?: ViryaWhereInput
    /**
     * Limit how many Viryas to delete.
     */
    limit?: number
  }

  /**
   * Virya.FoodVirya
   */
  export type Virya$FoodViryaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    where?: FoodViryaWhereInput
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    cursor?: FoodViryaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodViryaScalarFieldEnum | FoodViryaScalarFieldEnum[]
  }

  /**
   * Virya without action
   */
  export type ViryaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virya
     */
    select?: ViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Virya
     */
    omit?: ViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViryaInclude<ExtArgs> | null
  }


  /**
   * Model Vipaka
   */

  export type AggregateVipaka = {
    _count: VipakaCountAggregateOutputType | null
    _min: VipakaMinAggregateOutputType | null
    _max: VipakaMaxAggregateOutputType | null
  }

  export type VipakaMinAggregateOutputType = {
    vipaka_id: string | null
    name: string | null
  }

  export type VipakaMaxAggregateOutputType = {
    vipaka_id: string | null
    name: string | null
  }

  export type VipakaCountAggregateOutputType = {
    vipaka_id: number
    name: number
    _all: number
  }


  export type VipakaMinAggregateInputType = {
    vipaka_id?: true
    name?: true
  }

  export type VipakaMaxAggregateInputType = {
    vipaka_id?: true
    name?: true
  }

  export type VipakaCountAggregateInputType = {
    vipaka_id?: true
    name?: true
    _all?: true
  }

  export type VipakaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vipaka to aggregate.
     */
    where?: VipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vipakas to fetch.
     */
    orderBy?: VipakaOrderByWithRelationInput | VipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vipakas
    **/
    _count?: true | VipakaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VipakaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VipakaMaxAggregateInputType
  }

  export type GetVipakaAggregateType<T extends VipakaAggregateArgs> = {
        [P in keyof T & keyof AggregateVipaka]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVipaka[P]>
      : GetScalarType<T[P], AggregateVipaka[P]>
  }




  export type VipakaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipakaWhereInput
    orderBy?: VipakaOrderByWithAggregationInput | VipakaOrderByWithAggregationInput[]
    by: VipakaScalarFieldEnum[] | VipakaScalarFieldEnum
    having?: VipakaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VipakaCountAggregateInputType | true
    _min?: VipakaMinAggregateInputType
    _max?: VipakaMaxAggregateInputType
  }

  export type VipakaGroupByOutputType = {
    vipaka_id: string
    name: string
    _count: VipakaCountAggregateOutputType | null
    _min: VipakaMinAggregateOutputType | null
    _max: VipakaMaxAggregateOutputType | null
  }

  type GetVipakaGroupByPayload<T extends VipakaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VipakaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VipakaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VipakaGroupByOutputType[P]>
            : GetScalarType<T[P], VipakaGroupByOutputType[P]>
        }
      >
    >


  export type VipakaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vipaka_id?: boolean
    name?: boolean
    FoodVipaka?: boolean | Vipaka$FoodVipakaArgs<ExtArgs>
    _count?: boolean | VipakaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipaka"]>

  export type VipakaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vipaka_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["vipaka"]>

  export type VipakaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vipaka_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["vipaka"]>

  export type VipakaSelectScalar = {
    vipaka_id?: boolean
    name?: boolean
  }

  export type VipakaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vipaka_id" | "name", ExtArgs["result"]["vipaka"]>
  export type VipakaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodVipaka?: boolean | Vipaka$FoodVipakaArgs<ExtArgs>
    _count?: boolean | VipakaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VipakaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VipakaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VipakaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vipaka"
    objects: {
      FoodVipaka: Prisma.$FoodVipakaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      vipaka_id: string
      name: string
    }, ExtArgs["result"]["vipaka"]>
    composites: {}
  }

  type VipakaGetPayload<S extends boolean | null | undefined | VipakaDefaultArgs> = $Result.GetResult<Prisma.$VipakaPayload, S>

  type VipakaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VipakaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VipakaCountAggregateInputType | true
    }

  export interface VipakaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vipaka'], meta: { name: 'Vipaka' } }
    /**
     * Find zero or one Vipaka that matches the filter.
     * @param {VipakaFindUniqueArgs} args - Arguments to find a Vipaka
     * @example
     * // Get one Vipaka
     * const vipaka = await prisma.vipaka.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VipakaFindUniqueArgs>(args: SelectSubset<T, VipakaFindUniqueArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vipaka that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VipakaFindUniqueOrThrowArgs} args - Arguments to find a Vipaka
     * @example
     * // Get one Vipaka
     * const vipaka = await prisma.vipaka.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VipakaFindUniqueOrThrowArgs>(args: SelectSubset<T, VipakaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vipaka that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaFindFirstArgs} args - Arguments to find a Vipaka
     * @example
     * // Get one Vipaka
     * const vipaka = await prisma.vipaka.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VipakaFindFirstArgs>(args?: SelectSubset<T, VipakaFindFirstArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vipaka that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaFindFirstOrThrowArgs} args - Arguments to find a Vipaka
     * @example
     * // Get one Vipaka
     * const vipaka = await prisma.vipaka.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VipakaFindFirstOrThrowArgs>(args?: SelectSubset<T, VipakaFindFirstOrThrowArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vipakas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vipakas
     * const vipakas = await prisma.vipaka.findMany()
     * 
     * // Get first 10 Vipakas
     * const vipakas = await prisma.vipaka.findMany({ take: 10 })
     * 
     * // Only select the `vipaka_id`
     * const vipakaWithVipaka_idOnly = await prisma.vipaka.findMany({ select: { vipaka_id: true } })
     * 
     */
    findMany<T extends VipakaFindManyArgs>(args?: SelectSubset<T, VipakaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vipaka.
     * @param {VipakaCreateArgs} args - Arguments to create a Vipaka.
     * @example
     * // Create one Vipaka
     * const Vipaka = await prisma.vipaka.create({
     *   data: {
     *     // ... data to create a Vipaka
     *   }
     * })
     * 
     */
    create<T extends VipakaCreateArgs>(args: SelectSubset<T, VipakaCreateArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vipakas.
     * @param {VipakaCreateManyArgs} args - Arguments to create many Vipakas.
     * @example
     * // Create many Vipakas
     * const vipaka = await prisma.vipaka.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VipakaCreateManyArgs>(args?: SelectSubset<T, VipakaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vipakas and returns the data saved in the database.
     * @param {VipakaCreateManyAndReturnArgs} args - Arguments to create many Vipakas.
     * @example
     * // Create many Vipakas
     * const vipaka = await prisma.vipaka.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vipakas and only return the `vipaka_id`
     * const vipakaWithVipaka_idOnly = await prisma.vipaka.createManyAndReturn({
     *   select: { vipaka_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VipakaCreateManyAndReturnArgs>(args?: SelectSubset<T, VipakaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vipaka.
     * @param {VipakaDeleteArgs} args - Arguments to delete one Vipaka.
     * @example
     * // Delete one Vipaka
     * const Vipaka = await prisma.vipaka.delete({
     *   where: {
     *     // ... filter to delete one Vipaka
     *   }
     * })
     * 
     */
    delete<T extends VipakaDeleteArgs>(args: SelectSubset<T, VipakaDeleteArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vipaka.
     * @param {VipakaUpdateArgs} args - Arguments to update one Vipaka.
     * @example
     * // Update one Vipaka
     * const vipaka = await prisma.vipaka.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VipakaUpdateArgs>(args: SelectSubset<T, VipakaUpdateArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vipakas.
     * @param {VipakaDeleteManyArgs} args - Arguments to filter Vipakas to delete.
     * @example
     * // Delete a few Vipakas
     * const { count } = await prisma.vipaka.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VipakaDeleteManyArgs>(args?: SelectSubset<T, VipakaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vipakas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vipakas
     * const vipaka = await prisma.vipaka.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VipakaUpdateManyArgs>(args: SelectSubset<T, VipakaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vipakas and returns the data updated in the database.
     * @param {VipakaUpdateManyAndReturnArgs} args - Arguments to update many Vipakas.
     * @example
     * // Update many Vipakas
     * const vipaka = await prisma.vipaka.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vipakas and only return the `vipaka_id`
     * const vipakaWithVipaka_idOnly = await prisma.vipaka.updateManyAndReturn({
     *   select: { vipaka_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VipakaUpdateManyAndReturnArgs>(args: SelectSubset<T, VipakaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vipaka.
     * @param {VipakaUpsertArgs} args - Arguments to update or create a Vipaka.
     * @example
     * // Update or create a Vipaka
     * const vipaka = await prisma.vipaka.upsert({
     *   create: {
     *     // ... data to create a Vipaka
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vipaka we want to update
     *   }
     * })
     */
    upsert<T extends VipakaUpsertArgs>(args: SelectSubset<T, VipakaUpsertArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vipakas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaCountArgs} args - Arguments to filter Vipakas to count.
     * @example
     * // Count the number of Vipakas
     * const count = await prisma.vipaka.count({
     *   where: {
     *     // ... the filter for the Vipakas we want to count
     *   }
     * })
    **/
    count<T extends VipakaCountArgs>(
      args?: Subset<T, VipakaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VipakaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vipaka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VipakaAggregateArgs>(args: Subset<T, VipakaAggregateArgs>): Prisma.PrismaPromise<GetVipakaAggregateType<T>>

    /**
     * Group by Vipaka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipakaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VipakaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VipakaGroupByArgs['orderBy'] }
        : { orderBy?: VipakaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VipakaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVipakaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vipaka model
   */
  readonly fields: VipakaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vipaka.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VipakaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodVipaka<T extends Vipaka$FoodVipakaArgs<ExtArgs> = {}>(args?: Subset<T, Vipaka$FoodVipakaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vipaka model
   */
  interface VipakaFieldRefs {
    readonly vipaka_id: FieldRef<"Vipaka", 'String'>
    readonly name: FieldRef<"Vipaka", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vipaka findUnique
   */
  export type VipakaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter, which Vipaka to fetch.
     */
    where: VipakaWhereUniqueInput
  }

  /**
   * Vipaka findUniqueOrThrow
   */
  export type VipakaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter, which Vipaka to fetch.
     */
    where: VipakaWhereUniqueInput
  }

  /**
   * Vipaka findFirst
   */
  export type VipakaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter, which Vipaka to fetch.
     */
    where?: VipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vipakas to fetch.
     */
    orderBy?: VipakaOrderByWithRelationInput | VipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vipakas.
     */
    cursor?: VipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vipakas.
     */
    distinct?: VipakaScalarFieldEnum | VipakaScalarFieldEnum[]
  }

  /**
   * Vipaka findFirstOrThrow
   */
  export type VipakaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter, which Vipaka to fetch.
     */
    where?: VipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vipakas to fetch.
     */
    orderBy?: VipakaOrderByWithRelationInput | VipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vipakas.
     */
    cursor?: VipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vipakas.
     */
    distinct?: VipakaScalarFieldEnum | VipakaScalarFieldEnum[]
  }

  /**
   * Vipaka findMany
   */
  export type VipakaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter, which Vipakas to fetch.
     */
    where?: VipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vipakas to fetch.
     */
    orderBy?: VipakaOrderByWithRelationInput | VipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vipakas.
     */
    cursor?: VipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vipakas.
     */
    skip?: number
    distinct?: VipakaScalarFieldEnum | VipakaScalarFieldEnum[]
  }

  /**
   * Vipaka create
   */
  export type VipakaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * The data needed to create a Vipaka.
     */
    data: XOR<VipakaCreateInput, VipakaUncheckedCreateInput>
  }

  /**
   * Vipaka createMany
   */
  export type VipakaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vipakas.
     */
    data: VipakaCreateManyInput | VipakaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vipaka createManyAndReturn
   */
  export type VipakaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * The data used to create many Vipakas.
     */
    data: VipakaCreateManyInput | VipakaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vipaka update
   */
  export type VipakaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * The data needed to update a Vipaka.
     */
    data: XOR<VipakaUpdateInput, VipakaUncheckedUpdateInput>
    /**
     * Choose, which Vipaka to update.
     */
    where: VipakaWhereUniqueInput
  }

  /**
   * Vipaka updateMany
   */
  export type VipakaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vipakas.
     */
    data: XOR<VipakaUpdateManyMutationInput, VipakaUncheckedUpdateManyInput>
    /**
     * Filter which Vipakas to update
     */
    where?: VipakaWhereInput
    /**
     * Limit how many Vipakas to update.
     */
    limit?: number
  }

  /**
   * Vipaka updateManyAndReturn
   */
  export type VipakaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * The data used to update Vipakas.
     */
    data: XOR<VipakaUpdateManyMutationInput, VipakaUncheckedUpdateManyInput>
    /**
     * Filter which Vipakas to update
     */
    where?: VipakaWhereInput
    /**
     * Limit how many Vipakas to update.
     */
    limit?: number
  }

  /**
   * Vipaka upsert
   */
  export type VipakaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * The filter to search for the Vipaka to update in case it exists.
     */
    where: VipakaWhereUniqueInput
    /**
     * In case the Vipaka found by the `where` argument doesn't exist, create a new Vipaka with this data.
     */
    create: XOR<VipakaCreateInput, VipakaUncheckedCreateInput>
    /**
     * In case the Vipaka was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VipakaUpdateInput, VipakaUncheckedUpdateInput>
  }

  /**
   * Vipaka delete
   */
  export type VipakaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
    /**
     * Filter which Vipaka to delete.
     */
    where: VipakaWhereUniqueInput
  }

  /**
   * Vipaka deleteMany
   */
  export type VipakaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vipakas to delete
     */
    where?: VipakaWhereInput
    /**
     * Limit how many Vipakas to delete.
     */
    limit?: number
  }

  /**
   * Vipaka.FoodVipaka
   */
  export type Vipaka$FoodVipakaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    where?: FoodVipakaWhereInput
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    cursor?: FoodVipakaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodVipakaScalarFieldEnum | FoodVipakaScalarFieldEnum[]
  }

  /**
   * Vipaka without action
   */
  export type VipakaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vipaka
     */
    select?: VipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vipaka
     */
    omit?: VipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipakaInclude<ExtArgs> | null
  }


  /**
   * Model Digestibility
   */

  export type AggregateDigestibility = {
    _count: DigestibilityCountAggregateOutputType | null
    _min: DigestibilityMinAggregateOutputType | null
    _max: DigestibilityMaxAggregateOutputType | null
  }

  export type DigestibilityMinAggregateOutputType = {
    digestibility_id: string | null
    name: string | null
  }

  export type DigestibilityMaxAggregateOutputType = {
    digestibility_id: string | null
    name: string | null
  }

  export type DigestibilityCountAggregateOutputType = {
    digestibility_id: number
    name: number
    _all: number
  }


  export type DigestibilityMinAggregateInputType = {
    digestibility_id?: true
    name?: true
  }

  export type DigestibilityMaxAggregateInputType = {
    digestibility_id?: true
    name?: true
  }

  export type DigestibilityCountAggregateInputType = {
    digestibility_id?: true
    name?: true
    _all?: true
  }

  export type DigestibilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Digestibility to aggregate.
     */
    where?: DigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Digestibilities to fetch.
     */
    orderBy?: DigestibilityOrderByWithRelationInput | DigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Digestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Digestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Digestibilities
    **/
    _count?: true | DigestibilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigestibilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigestibilityMaxAggregateInputType
  }

  export type GetDigestibilityAggregateType<T extends DigestibilityAggregateArgs> = {
        [P in keyof T & keyof AggregateDigestibility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigestibility[P]>
      : GetScalarType<T[P], AggregateDigestibility[P]>
  }




  export type DigestibilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigestibilityWhereInput
    orderBy?: DigestibilityOrderByWithAggregationInput | DigestibilityOrderByWithAggregationInput[]
    by: DigestibilityScalarFieldEnum[] | DigestibilityScalarFieldEnum
    having?: DigestibilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigestibilityCountAggregateInputType | true
    _min?: DigestibilityMinAggregateInputType
    _max?: DigestibilityMaxAggregateInputType
  }

  export type DigestibilityGroupByOutputType = {
    digestibility_id: string
    name: string
    _count: DigestibilityCountAggregateOutputType | null
    _min: DigestibilityMinAggregateOutputType | null
    _max: DigestibilityMaxAggregateOutputType | null
  }

  type GetDigestibilityGroupByPayload<T extends DigestibilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigestibilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigestibilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigestibilityGroupByOutputType[P]>
            : GetScalarType<T[P], DigestibilityGroupByOutputType[P]>
        }
      >
    >


  export type DigestibilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    digestibility_id?: boolean
    name?: boolean
    FoodDigestibility?: boolean | Digestibility$FoodDigestibilityArgs<ExtArgs>
    _count?: boolean | DigestibilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["digestibility"]>

  export type DigestibilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    digestibility_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["digestibility"]>

  export type DigestibilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    digestibility_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["digestibility"]>

  export type DigestibilitySelectScalar = {
    digestibility_id?: boolean
    name?: boolean
  }

  export type DigestibilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"digestibility_id" | "name", ExtArgs["result"]["digestibility"]>
  export type DigestibilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodDigestibility?: boolean | Digestibility$FoodDigestibilityArgs<ExtArgs>
    _count?: boolean | DigestibilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DigestibilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DigestibilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DigestibilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Digestibility"
    objects: {
      FoodDigestibility: Prisma.$FoodDigestibilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      digestibility_id: string
      name: string
    }, ExtArgs["result"]["digestibility"]>
    composites: {}
  }

  type DigestibilityGetPayload<S extends boolean | null | undefined | DigestibilityDefaultArgs> = $Result.GetResult<Prisma.$DigestibilityPayload, S>

  type DigestibilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DigestibilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DigestibilityCountAggregateInputType | true
    }

  export interface DigestibilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Digestibility'], meta: { name: 'Digestibility' } }
    /**
     * Find zero or one Digestibility that matches the filter.
     * @param {DigestibilityFindUniqueArgs} args - Arguments to find a Digestibility
     * @example
     * // Get one Digestibility
     * const digestibility = await prisma.digestibility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DigestibilityFindUniqueArgs>(args: SelectSubset<T, DigestibilityFindUniqueArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Digestibility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DigestibilityFindUniqueOrThrowArgs} args - Arguments to find a Digestibility
     * @example
     * // Get one Digestibility
     * const digestibility = await prisma.digestibility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DigestibilityFindUniqueOrThrowArgs>(args: SelectSubset<T, DigestibilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Digestibility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityFindFirstArgs} args - Arguments to find a Digestibility
     * @example
     * // Get one Digestibility
     * const digestibility = await prisma.digestibility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DigestibilityFindFirstArgs>(args?: SelectSubset<T, DigestibilityFindFirstArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Digestibility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityFindFirstOrThrowArgs} args - Arguments to find a Digestibility
     * @example
     * // Get one Digestibility
     * const digestibility = await prisma.digestibility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DigestibilityFindFirstOrThrowArgs>(args?: SelectSubset<T, DigestibilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Digestibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Digestibilities
     * const digestibilities = await prisma.digestibility.findMany()
     * 
     * // Get first 10 Digestibilities
     * const digestibilities = await prisma.digestibility.findMany({ take: 10 })
     * 
     * // Only select the `digestibility_id`
     * const digestibilityWithDigestibility_idOnly = await prisma.digestibility.findMany({ select: { digestibility_id: true } })
     * 
     */
    findMany<T extends DigestibilityFindManyArgs>(args?: SelectSubset<T, DigestibilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Digestibility.
     * @param {DigestibilityCreateArgs} args - Arguments to create a Digestibility.
     * @example
     * // Create one Digestibility
     * const Digestibility = await prisma.digestibility.create({
     *   data: {
     *     // ... data to create a Digestibility
     *   }
     * })
     * 
     */
    create<T extends DigestibilityCreateArgs>(args: SelectSubset<T, DigestibilityCreateArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Digestibilities.
     * @param {DigestibilityCreateManyArgs} args - Arguments to create many Digestibilities.
     * @example
     * // Create many Digestibilities
     * const digestibility = await prisma.digestibility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DigestibilityCreateManyArgs>(args?: SelectSubset<T, DigestibilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Digestibilities and returns the data saved in the database.
     * @param {DigestibilityCreateManyAndReturnArgs} args - Arguments to create many Digestibilities.
     * @example
     * // Create many Digestibilities
     * const digestibility = await prisma.digestibility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Digestibilities and only return the `digestibility_id`
     * const digestibilityWithDigestibility_idOnly = await prisma.digestibility.createManyAndReturn({
     *   select: { digestibility_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DigestibilityCreateManyAndReturnArgs>(args?: SelectSubset<T, DigestibilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Digestibility.
     * @param {DigestibilityDeleteArgs} args - Arguments to delete one Digestibility.
     * @example
     * // Delete one Digestibility
     * const Digestibility = await prisma.digestibility.delete({
     *   where: {
     *     // ... filter to delete one Digestibility
     *   }
     * })
     * 
     */
    delete<T extends DigestibilityDeleteArgs>(args: SelectSubset<T, DigestibilityDeleteArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Digestibility.
     * @param {DigestibilityUpdateArgs} args - Arguments to update one Digestibility.
     * @example
     * // Update one Digestibility
     * const digestibility = await prisma.digestibility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DigestibilityUpdateArgs>(args: SelectSubset<T, DigestibilityUpdateArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Digestibilities.
     * @param {DigestibilityDeleteManyArgs} args - Arguments to filter Digestibilities to delete.
     * @example
     * // Delete a few Digestibilities
     * const { count } = await prisma.digestibility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DigestibilityDeleteManyArgs>(args?: SelectSubset<T, DigestibilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Digestibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Digestibilities
     * const digestibility = await prisma.digestibility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DigestibilityUpdateManyArgs>(args: SelectSubset<T, DigestibilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Digestibilities and returns the data updated in the database.
     * @param {DigestibilityUpdateManyAndReturnArgs} args - Arguments to update many Digestibilities.
     * @example
     * // Update many Digestibilities
     * const digestibility = await prisma.digestibility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Digestibilities and only return the `digestibility_id`
     * const digestibilityWithDigestibility_idOnly = await prisma.digestibility.updateManyAndReturn({
     *   select: { digestibility_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DigestibilityUpdateManyAndReturnArgs>(args: SelectSubset<T, DigestibilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Digestibility.
     * @param {DigestibilityUpsertArgs} args - Arguments to update or create a Digestibility.
     * @example
     * // Update or create a Digestibility
     * const digestibility = await prisma.digestibility.upsert({
     *   create: {
     *     // ... data to create a Digestibility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Digestibility we want to update
     *   }
     * })
     */
    upsert<T extends DigestibilityUpsertArgs>(args: SelectSubset<T, DigestibilityUpsertArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Digestibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityCountArgs} args - Arguments to filter Digestibilities to count.
     * @example
     * // Count the number of Digestibilities
     * const count = await prisma.digestibility.count({
     *   where: {
     *     // ... the filter for the Digestibilities we want to count
     *   }
     * })
    **/
    count<T extends DigestibilityCountArgs>(
      args?: Subset<T, DigestibilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigestibilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Digestibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigestibilityAggregateArgs>(args: Subset<T, DigestibilityAggregateArgs>): Prisma.PrismaPromise<GetDigestibilityAggregateType<T>>

    /**
     * Group by Digestibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigestibilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigestibilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigestibilityGroupByArgs['orderBy'] }
        : { orderBy?: DigestibilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigestibilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigestibilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Digestibility model
   */
  readonly fields: DigestibilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Digestibility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigestibilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodDigestibility<T extends Digestibility$FoodDigestibilityArgs<ExtArgs> = {}>(args?: Subset<T, Digestibility$FoodDigestibilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Digestibility model
   */
  interface DigestibilityFieldRefs {
    readonly digestibility_id: FieldRef<"Digestibility", 'String'>
    readonly name: FieldRef<"Digestibility", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Digestibility findUnique
   */
  export type DigestibilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which Digestibility to fetch.
     */
    where: DigestibilityWhereUniqueInput
  }

  /**
   * Digestibility findUniqueOrThrow
   */
  export type DigestibilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which Digestibility to fetch.
     */
    where: DigestibilityWhereUniqueInput
  }

  /**
   * Digestibility findFirst
   */
  export type DigestibilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which Digestibility to fetch.
     */
    where?: DigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Digestibilities to fetch.
     */
    orderBy?: DigestibilityOrderByWithRelationInput | DigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Digestibilities.
     */
    cursor?: DigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Digestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Digestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Digestibilities.
     */
    distinct?: DigestibilityScalarFieldEnum | DigestibilityScalarFieldEnum[]
  }

  /**
   * Digestibility findFirstOrThrow
   */
  export type DigestibilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which Digestibility to fetch.
     */
    where?: DigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Digestibilities to fetch.
     */
    orderBy?: DigestibilityOrderByWithRelationInput | DigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Digestibilities.
     */
    cursor?: DigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Digestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Digestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Digestibilities.
     */
    distinct?: DigestibilityScalarFieldEnum | DigestibilityScalarFieldEnum[]
  }

  /**
   * Digestibility findMany
   */
  export type DigestibilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which Digestibilities to fetch.
     */
    where?: DigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Digestibilities to fetch.
     */
    orderBy?: DigestibilityOrderByWithRelationInput | DigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Digestibilities.
     */
    cursor?: DigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Digestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Digestibilities.
     */
    skip?: number
    distinct?: DigestibilityScalarFieldEnum | DigestibilityScalarFieldEnum[]
  }

  /**
   * Digestibility create
   */
  export type DigestibilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Digestibility.
     */
    data: XOR<DigestibilityCreateInput, DigestibilityUncheckedCreateInput>
  }

  /**
   * Digestibility createMany
   */
  export type DigestibilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Digestibilities.
     */
    data: DigestibilityCreateManyInput | DigestibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Digestibility createManyAndReturn
   */
  export type DigestibilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * The data used to create many Digestibilities.
     */
    data: DigestibilityCreateManyInput | DigestibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Digestibility update
   */
  export type DigestibilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Digestibility.
     */
    data: XOR<DigestibilityUpdateInput, DigestibilityUncheckedUpdateInput>
    /**
     * Choose, which Digestibility to update.
     */
    where: DigestibilityWhereUniqueInput
  }

  /**
   * Digestibility updateMany
   */
  export type DigestibilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Digestibilities.
     */
    data: XOR<DigestibilityUpdateManyMutationInput, DigestibilityUncheckedUpdateManyInput>
    /**
     * Filter which Digestibilities to update
     */
    where?: DigestibilityWhereInput
    /**
     * Limit how many Digestibilities to update.
     */
    limit?: number
  }

  /**
   * Digestibility updateManyAndReturn
   */
  export type DigestibilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * The data used to update Digestibilities.
     */
    data: XOR<DigestibilityUpdateManyMutationInput, DigestibilityUncheckedUpdateManyInput>
    /**
     * Filter which Digestibilities to update
     */
    where?: DigestibilityWhereInput
    /**
     * Limit how many Digestibilities to update.
     */
    limit?: number
  }

  /**
   * Digestibility upsert
   */
  export type DigestibilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Digestibility to update in case it exists.
     */
    where: DigestibilityWhereUniqueInput
    /**
     * In case the Digestibility found by the `where` argument doesn't exist, create a new Digestibility with this data.
     */
    create: XOR<DigestibilityCreateInput, DigestibilityUncheckedCreateInput>
    /**
     * In case the Digestibility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigestibilityUpdateInput, DigestibilityUncheckedUpdateInput>
  }

  /**
   * Digestibility delete
   */
  export type DigestibilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
    /**
     * Filter which Digestibility to delete.
     */
    where: DigestibilityWhereUniqueInput
  }

  /**
   * Digestibility deleteMany
   */
  export type DigestibilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Digestibilities to delete
     */
    where?: DigestibilityWhereInput
    /**
     * Limit how many Digestibilities to delete.
     */
    limit?: number
  }

  /**
   * Digestibility.FoodDigestibility
   */
  export type Digestibility$FoodDigestibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    where?: FoodDigestibilityWhereInput
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    cursor?: FoodDigestibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodDigestibilityScalarFieldEnum | FoodDigestibilityScalarFieldEnum[]
  }

  /**
   * Digestibility without action
   */
  export type DigestibilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Digestibility
     */
    select?: DigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Digestibility
     */
    omit?: DigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigestibilityInclude<ExtArgs> | null
  }


  /**
   * Model Rda
   */

  export type AggregateRda = {
    _count: RdaCountAggregateOutputType | null
    _avg: RdaAvgAggregateOutputType | null
    _sum: RdaSumAggregateOutputType | null
    _min: RdaMinAggregateOutputType | null
    _max: RdaMaxAggregateOutputType | null
  }

  export type RdaAvgAggregateOutputType = {
    amount: number | null
  }

  export type RdaSumAggregateOutputType = {
    amount: number | null
  }

  export type RdaMinAggregateOutputType = {
    rda_id: string | null
    nutrient_id: string | null
    age_group: $Enums.AgeGroup | null
    gender: $Enums.Gender | null
    amount: number | null
  }

  export type RdaMaxAggregateOutputType = {
    rda_id: string | null
    nutrient_id: string | null
    age_group: $Enums.AgeGroup | null
    gender: $Enums.Gender | null
    amount: number | null
  }

  export type RdaCountAggregateOutputType = {
    rda_id: number
    nutrient_id: number
    age_group: number
    gender: number
    amount: number
    _all: number
  }


  export type RdaAvgAggregateInputType = {
    amount?: true
  }

  export type RdaSumAggregateInputType = {
    amount?: true
  }

  export type RdaMinAggregateInputType = {
    rda_id?: true
    nutrient_id?: true
    age_group?: true
    gender?: true
    amount?: true
  }

  export type RdaMaxAggregateInputType = {
    rda_id?: true
    nutrient_id?: true
    age_group?: true
    gender?: true
    amount?: true
  }

  export type RdaCountAggregateInputType = {
    rda_id?: true
    nutrient_id?: true
    age_group?: true
    gender?: true
    amount?: true
    _all?: true
  }

  export type RdaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rda to aggregate.
     */
    where?: RdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rdas to fetch.
     */
    orderBy?: RdaOrderByWithRelationInput | RdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rdas
    **/
    _count?: true | RdaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RdaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RdaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RdaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RdaMaxAggregateInputType
  }

  export type GetRdaAggregateType<T extends RdaAggregateArgs> = {
        [P in keyof T & keyof AggregateRda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRda[P]>
      : GetScalarType<T[P], AggregateRda[P]>
  }




  export type RdaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RdaWhereInput
    orderBy?: RdaOrderByWithAggregationInput | RdaOrderByWithAggregationInput[]
    by: RdaScalarFieldEnum[] | RdaScalarFieldEnum
    having?: RdaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RdaCountAggregateInputType | true
    _avg?: RdaAvgAggregateInputType
    _sum?: RdaSumAggregateInputType
    _min?: RdaMinAggregateInputType
    _max?: RdaMaxAggregateInputType
  }

  export type RdaGroupByOutputType = {
    rda_id: string
    nutrient_id: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
    _count: RdaCountAggregateOutputType | null
    _avg: RdaAvgAggregateOutputType | null
    _sum: RdaSumAggregateOutputType | null
    _min: RdaMinAggregateOutputType | null
    _max: RdaMaxAggregateOutputType | null
  }

  type GetRdaGroupByPayload<T extends RdaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RdaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RdaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RdaGroupByOutputType[P]>
            : GetScalarType<T[P], RdaGroupByOutputType[P]>
        }
      >
    >


  export type RdaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rda_id?: boolean
    nutrient_id?: boolean
    age_group?: boolean
    gender?: boolean
    amount?: boolean
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rda"]>

  export type RdaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rda_id?: boolean
    nutrient_id?: boolean
    age_group?: boolean
    gender?: boolean
    amount?: boolean
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rda"]>

  export type RdaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rda_id?: boolean
    nutrient_id?: boolean
    age_group?: boolean
    gender?: boolean
    amount?: boolean
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rda"]>

  export type RdaSelectScalar = {
    rda_id?: boolean
    nutrient_id?: boolean
    age_group?: boolean
    gender?: boolean
    amount?: boolean
  }

  export type RdaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"rda_id" | "nutrient_id" | "age_group" | "gender" | "amount", ExtArgs["result"]["rda"]>
  export type RdaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }
  export type RdaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }
  export type RdaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }

  export type $RdaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rda"
    objects: {
      Nutrient: Prisma.$NutrientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      rda_id: string
      nutrient_id: string
      age_group: $Enums.AgeGroup
      gender: $Enums.Gender
      amount: number
    }, ExtArgs["result"]["rda"]>
    composites: {}
  }

  type RdaGetPayload<S extends boolean | null | undefined | RdaDefaultArgs> = $Result.GetResult<Prisma.$RdaPayload, S>

  type RdaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RdaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RdaCountAggregateInputType | true
    }

  export interface RdaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rda'], meta: { name: 'Rda' } }
    /**
     * Find zero or one Rda that matches the filter.
     * @param {RdaFindUniqueArgs} args - Arguments to find a Rda
     * @example
     * // Get one Rda
     * const rda = await prisma.rda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RdaFindUniqueArgs>(args: SelectSubset<T, RdaFindUniqueArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RdaFindUniqueOrThrowArgs} args - Arguments to find a Rda
     * @example
     * // Get one Rda
     * const rda = await prisma.rda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RdaFindUniqueOrThrowArgs>(args: SelectSubset<T, RdaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaFindFirstArgs} args - Arguments to find a Rda
     * @example
     * // Get one Rda
     * const rda = await prisma.rda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RdaFindFirstArgs>(args?: SelectSubset<T, RdaFindFirstArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaFindFirstOrThrowArgs} args - Arguments to find a Rda
     * @example
     * // Get one Rda
     * const rda = await prisma.rda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RdaFindFirstOrThrowArgs>(args?: SelectSubset<T, RdaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rdas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rdas
     * const rdas = await prisma.rda.findMany()
     * 
     * // Get first 10 Rdas
     * const rdas = await prisma.rda.findMany({ take: 10 })
     * 
     * // Only select the `rda_id`
     * const rdaWithRda_idOnly = await prisma.rda.findMany({ select: { rda_id: true } })
     * 
     */
    findMany<T extends RdaFindManyArgs>(args?: SelectSubset<T, RdaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rda.
     * @param {RdaCreateArgs} args - Arguments to create a Rda.
     * @example
     * // Create one Rda
     * const Rda = await prisma.rda.create({
     *   data: {
     *     // ... data to create a Rda
     *   }
     * })
     * 
     */
    create<T extends RdaCreateArgs>(args: SelectSubset<T, RdaCreateArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rdas.
     * @param {RdaCreateManyArgs} args - Arguments to create many Rdas.
     * @example
     * // Create many Rdas
     * const rda = await prisma.rda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RdaCreateManyArgs>(args?: SelectSubset<T, RdaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rdas and returns the data saved in the database.
     * @param {RdaCreateManyAndReturnArgs} args - Arguments to create many Rdas.
     * @example
     * // Create many Rdas
     * const rda = await prisma.rda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rdas and only return the `rda_id`
     * const rdaWithRda_idOnly = await prisma.rda.createManyAndReturn({
     *   select: { rda_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RdaCreateManyAndReturnArgs>(args?: SelectSubset<T, RdaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rda.
     * @param {RdaDeleteArgs} args - Arguments to delete one Rda.
     * @example
     * // Delete one Rda
     * const Rda = await prisma.rda.delete({
     *   where: {
     *     // ... filter to delete one Rda
     *   }
     * })
     * 
     */
    delete<T extends RdaDeleteArgs>(args: SelectSubset<T, RdaDeleteArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rda.
     * @param {RdaUpdateArgs} args - Arguments to update one Rda.
     * @example
     * // Update one Rda
     * const rda = await prisma.rda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RdaUpdateArgs>(args: SelectSubset<T, RdaUpdateArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rdas.
     * @param {RdaDeleteManyArgs} args - Arguments to filter Rdas to delete.
     * @example
     * // Delete a few Rdas
     * const { count } = await prisma.rda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RdaDeleteManyArgs>(args?: SelectSubset<T, RdaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rdas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rdas
     * const rda = await prisma.rda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RdaUpdateManyArgs>(args: SelectSubset<T, RdaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rdas and returns the data updated in the database.
     * @param {RdaUpdateManyAndReturnArgs} args - Arguments to update many Rdas.
     * @example
     * // Update many Rdas
     * const rda = await prisma.rda.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rdas and only return the `rda_id`
     * const rdaWithRda_idOnly = await prisma.rda.updateManyAndReturn({
     *   select: { rda_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RdaUpdateManyAndReturnArgs>(args: SelectSubset<T, RdaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rda.
     * @param {RdaUpsertArgs} args - Arguments to update or create a Rda.
     * @example
     * // Update or create a Rda
     * const rda = await prisma.rda.upsert({
     *   create: {
     *     // ... data to create a Rda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rda we want to update
     *   }
     * })
     */
    upsert<T extends RdaUpsertArgs>(args: SelectSubset<T, RdaUpsertArgs<ExtArgs>>): Prisma__RdaClient<$Result.GetResult<Prisma.$RdaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rdas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaCountArgs} args - Arguments to filter Rdas to count.
     * @example
     * // Count the number of Rdas
     * const count = await prisma.rda.count({
     *   where: {
     *     // ... the filter for the Rdas we want to count
     *   }
     * })
    **/
    count<T extends RdaCountArgs>(
      args?: Subset<T, RdaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RdaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RdaAggregateArgs>(args: Subset<T, RdaAggregateArgs>): Prisma.PrismaPromise<GetRdaAggregateType<T>>

    /**
     * Group by Rda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RdaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RdaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RdaGroupByArgs['orderBy'] }
        : { orderBy?: RdaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RdaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRdaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rda model
   */
  readonly fields: RdaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RdaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Nutrient<T extends NutrientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NutrientDefaultArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rda model
   */
  interface RdaFieldRefs {
    readonly rda_id: FieldRef<"Rda", 'String'>
    readonly nutrient_id: FieldRef<"Rda", 'String'>
    readonly age_group: FieldRef<"Rda", 'AgeGroup'>
    readonly gender: FieldRef<"Rda", 'Gender'>
    readonly amount: FieldRef<"Rda", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Rda findUnique
   */
  export type RdaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter, which Rda to fetch.
     */
    where: RdaWhereUniqueInput
  }

  /**
   * Rda findUniqueOrThrow
   */
  export type RdaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter, which Rda to fetch.
     */
    where: RdaWhereUniqueInput
  }

  /**
   * Rda findFirst
   */
  export type RdaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter, which Rda to fetch.
     */
    where?: RdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rdas to fetch.
     */
    orderBy?: RdaOrderByWithRelationInput | RdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rdas.
     */
    cursor?: RdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rdas.
     */
    distinct?: RdaScalarFieldEnum | RdaScalarFieldEnum[]
  }

  /**
   * Rda findFirstOrThrow
   */
  export type RdaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter, which Rda to fetch.
     */
    where?: RdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rdas to fetch.
     */
    orderBy?: RdaOrderByWithRelationInput | RdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rdas.
     */
    cursor?: RdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rdas.
     */
    distinct?: RdaScalarFieldEnum | RdaScalarFieldEnum[]
  }

  /**
   * Rda findMany
   */
  export type RdaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter, which Rdas to fetch.
     */
    where?: RdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rdas to fetch.
     */
    orderBy?: RdaOrderByWithRelationInput | RdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rdas.
     */
    cursor?: RdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rdas.
     */
    skip?: number
    distinct?: RdaScalarFieldEnum | RdaScalarFieldEnum[]
  }

  /**
   * Rda create
   */
  export type RdaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * The data needed to create a Rda.
     */
    data: XOR<RdaCreateInput, RdaUncheckedCreateInput>
  }

  /**
   * Rda createMany
   */
  export type RdaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rdas.
     */
    data: RdaCreateManyInput | RdaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rda createManyAndReturn
   */
  export type RdaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * The data used to create many Rdas.
     */
    data: RdaCreateManyInput | RdaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rda update
   */
  export type RdaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * The data needed to update a Rda.
     */
    data: XOR<RdaUpdateInput, RdaUncheckedUpdateInput>
    /**
     * Choose, which Rda to update.
     */
    where: RdaWhereUniqueInput
  }

  /**
   * Rda updateMany
   */
  export type RdaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rdas.
     */
    data: XOR<RdaUpdateManyMutationInput, RdaUncheckedUpdateManyInput>
    /**
     * Filter which Rdas to update
     */
    where?: RdaWhereInput
    /**
     * Limit how many Rdas to update.
     */
    limit?: number
  }

  /**
   * Rda updateManyAndReturn
   */
  export type RdaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * The data used to update Rdas.
     */
    data: XOR<RdaUpdateManyMutationInput, RdaUncheckedUpdateManyInput>
    /**
     * Filter which Rdas to update
     */
    where?: RdaWhereInput
    /**
     * Limit how many Rdas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rda upsert
   */
  export type RdaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * The filter to search for the Rda to update in case it exists.
     */
    where: RdaWhereUniqueInput
    /**
     * In case the Rda found by the `where` argument doesn't exist, create a new Rda with this data.
     */
    create: XOR<RdaCreateInput, RdaUncheckedCreateInput>
    /**
     * In case the Rda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RdaUpdateInput, RdaUncheckedUpdateInput>
  }

  /**
   * Rda delete
   */
  export type RdaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
    /**
     * Filter which Rda to delete.
     */
    where: RdaWhereUniqueInput
  }

  /**
   * Rda deleteMany
   */
  export type RdaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rdas to delete
     */
    where?: RdaWhereInput
    /**
     * Limit how many Rdas to delete.
     */
    limit?: number
  }

  /**
   * Rda without action
   */
  export type RdaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rda
     */
    select?: RdaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rda
     */
    omit?: RdaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RdaInclude<ExtArgs> | null
  }


  /**
   * Model FoodNutrient
   */

  export type AggregateFoodNutrient = {
    _count: FoodNutrientCountAggregateOutputType | null
    _avg: FoodNutrientAvgAggregateOutputType | null
    _sum: FoodNutrientSumAggregateOutputType | null
    _min: FoodNutrientMinAggregateOutputType | null
    _max: FoodNutrientMaxAggregateOutputType | null
  }

  export type FoodNutrientAvgAggregateOutputType = {
    amount: number | null
  }

  export type FoodNutrientSumAggregateOutputType = {
    amount: number | null
  }

  export type FoodNutrientMinAggregateOutputType = {
    food_id: string | null
    nutrient_id: string | null
    amount: number | null
  }

  export type FoodNutrientMaxAggregateOutputType = {
    food_id: string | null
    nutrient_id: string | null
    amount: number | null
  }

  export type FoodNutrientCountAggregateOutputType = {
    food_id: number
    nutrient_id: number
    amount: number
    _all: number
  }


  export type FoodNutrientAvgAggregateInputType = {
    amount?: true
  }

  export type FoodNutrientSumAggregateInputType = {
    amount?: true
  }

  export type FoodNutrientMinAggregateInputType = {
    food_id?: true
    nutrient_id?: true
    amount?: true
  }

  export type FoodNutrientMaxAggregateInputType = {
    food_id?: true
    nutrient_id?: true
    amount?: true
  }

  export type FoodNutrientCountAggregateInputType = {
    food_id?: true
    nutrient_id?: true
    amount?: true
    _all?: true
  }

  export type FoodNutrientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodNutrient to aggregate.
     */
    where?: FoodNutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodNutrients to fetch.
     */
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodNutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodNutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodNutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodNutrients
    **/
    _count?: true | FoodNutrientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodNutrientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodNutrientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodNutrientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodNutrientMaxAggregateInputType
  }

  export type GetFoodNutrientAggregateType<T extends FoodNutrientAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodNutrient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodNutrient[P]>
      : GetScalarType<T[P], AggregateFoodNutrient[P]>
  }




  export type FoodNutrientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodNutrientWhereInput
    orderBy?: FoodNutrientOrderByWithAggregationInput | FoodNutrientOrderByWithAggregationInput[]
    by: FoodNutrientScalarFieldEnum[] | FoodNutrientScalarFieldEnum
    having?: FoodNutrientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodNutrientCountAggregateInputType | true
    _avg?: FoodNutrientAvgAggregateInputType
    _sum?: FoodNutrientSumAggregateInputType
    _min?: FoodNutrientMinAggregateInputType
    _max?: FoodNutrientMaxAggregateInputType
  }

  export type FoodNutrientGroupByOutputType = {
    food_id: string
    nutrient_id: string
    amount: number
    _count: FoodNutrientCountAggregateOutputType | null
    _avg: FoodNutrientAvgAggregateOutputType | null
    _sum: FoodNutrientSumAggregateOutputType | null
    _min: FoodNutrientMinAggregateOutputType | null
    _max: FoodNutrientMaxAggregateOutputType | null
  }

  type GetFoodNutrientGroupByPayload<T extends FoodNutrientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodNutrientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodNutrientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodNutrientGroupByOutputType[P]>
            : GetScalarType<T[P], FoodNutrientGroupByOutputType[P]>
        }
      >
    >


  export type FoodNutrientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    nutrient_id?: boolean
    amount?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodNutrient"]>

  export type FoodNutrientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    nutrient_id?: boolean
    amount?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodNutrient"]>

  export type FoodNutrientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    nutrient_id?: boolean
    amount?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodNutrient"]>

  export type FoodNutrientSelectScalar = {
    food_id?: boolean
    nutrient_id?: boolean
    amount?: boolean
  }

  export type FoodNutrientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "nutrient_id" | "amount", ExtArgs["result"]["foodNutrient"]>
  export type FoodNutrientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }
  export type FoodNutrientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }
  export type FoodNutrientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    nutrient?: boolean | NutrientDefaultArgs<ExtArgs>
  }

  export type $FoodNutrientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodNutrient"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      nutrient: Prisma.$NutrientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      nutrient_id: string
      amount: number
    }, ExtArgs["result"]["foodNutrient"]>
    composites: {}
  }

  type FoodNutrientGetPayload<S extends boolean | null | undefined | FoodNutrientDefaultArgs> = $Result.GetResult<Prisma.$FoodNutrientPayload, S>

  type FoodNutrientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodNutrientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodNutrientCountAggregateInputType | true
    }

  export interface FoodNutrientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodNutrient'], meta: { name: 'FoodNutrient' } }
    /**
     * Find zero or one FoodNutrient that matches the filter.
     * @param {FoodNutrientFindUniqueArgs} args - Arguments to find a FoodNutrient
     * @example
     * // Get one FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodNutrientFindUniqueArgs>(args: SelectSubset<T, FoodNutrientFindUniqueArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodNutrient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodNutrientFindUniqueOrThrowArgs} args - Arguments to find a FoodNutrient
     * @example
     * // Get one FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodNutrientFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodNutrientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodNutrient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientFindFirstArgs} args - Arguments to find a FoodNutrient
     * @example
     * // Get one FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodNutrientFindFirstArgs>(args?: SelectSubset<T, FoodNutrientFindFirstArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodNutrient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientFindFirstOrThrowArgs} args - Arguments to find a FoodNutrient
     * @example
     * // Get one FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodNutrientFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodNutrientFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodNutrients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodNutrients
     * const foodNutrients = await prisma.foodNutrient.findMany()
     * 
     * // Get first 10 FoodNutrients
     * const foodNutrients = await prisma.foodNutrient.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodNutrientWithFood_idOnly = await prisma.foodNutrient.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodNutrientFindManyArgs>(args?: SelectSubset<T, FoodNutrientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodNutrient.
     * @param {FoodNutrientCreateArgs} args - Arguments to create a FoodNutrient.
     * @example
     * // Create one FoodNutrient
     * const FoodNutrient = await prisma.foodNutrient.create({
     *   data: {
     *     // ... data to create a FoodNutrient
     *   }
     * })
     * 
     */
    create<T extends FoodNutrientCreateArgs>(args: SelectSubset<T, FoodNutrientCreateArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodNutrients.
     * @param {FoodNutrientCreateManyArgs} args - Arguments to create many FoodNutrients.
     * @example
     * // Create many FoodNutrients
     * const foodNutrient = await prisma.foodNutrient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodNutrientCreateManyArgs>(args?: SelectSubset<T, FoodNutrientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodNutrients and returns the data saved in the database.
     * @param {FoodNutrientCreateManyAndReturnArgs} args - Arguments to create many FoodNutrients.
     * @example
     * // Create many FoodNutrients
     * const foodNutrient = await prisma.foodNutrient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodNutrients and only return the `food_id`
     * const foodNutrientWithFood_idOnly = await prisma.foodNutrient.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodNutrientCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodNutrientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodNutrient.
     * @param {FoodNutrientDeleteArgs} args - Arguments to delete one FoodNutrient.
     * @example
     * // Delete one FoodNutrient
     * const FoodNutrient = await prisma.foodNutrient.delete({
     *   where: {
     *     // ... filter to delete one FoodNutrient
     *   }
     * })
     * 
     */
    delete<T extends FoodNutrientDeleteArgs>(args: SelectSubset<T, FoodNutrientDeleteArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodNutrient.
     * @param {FoodNutrientUpdateArgs} args - Arguments to update one FoodNutrient.
     * @example
     * // Update one FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodNutrientUpdateArgs>(args: SelectSubset<T, FoodNutrientUpdateArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodNutrients.
     * @param {FoodNutrientDeleteManyArgs} args - Arguments to filter FoodNutrients to delete.
     * @example
     * // Delete a few FoodNutrients
     * const { count } = await prisma.foodNutrient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodNutrientDeleteManyArgs>(args?: SelectSubset<T, FoodNutrientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodNutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodNutrients
     * const foodNutrient = await prisma.foodNutrient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodNutrientUpdateManyArgs>(args: SelectSubset<T, FoodNutrientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodNutrients and returns the data updated in the database.
     * @param {FoodNutrientUpdateManyAndReturnArgs} args - Arguments to update many FoodNutrients.
     * @example
     * // Update many FoodNutrients
     * const foodNutrient = await prisma.foodNutrient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodNutrients and only return the `food_id`
     * const foodNutrientWithFood_idOnly = await prisma.foodNutrient.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodNutrientUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodNutrientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodNutrient.
     * @param {FoodNutrientUpsertArgs} args - Arguments to update or create a FoodNutrient.
     * @example
     * // Update or create a FoodNutrient
     * const foodNutrient = await prisma.foodNutrient.upsert({
     *   create: {
     *     // ... data to create a FoodNutrient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodNutrient we want to update
     *   }
     * })
     */
    upsert<T extends FoodNutrientUpsertArgs>(args: SelectSubset<T, FoodNutrientUpsertArgs<ExtArgs>>): Prisma__FoodNutrientClient<$Result.GetResult<Prisma.$FoodNutrientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodNutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientCountArgs} args - Arguments to filter FoodNutrients to count.
     * @example
     * // Count the number of FoodNutrients
     * const count = await prisma.foodNutrient.count({
     *   where: {
     *     // ... the filter for the FoodNutrients we want to count
     *   }
     * })
    **/
    count<T extends FoodNutrientCountArgs>(
      args?: Subset<T, FoodNutrientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodNutrientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodNutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodNutrientAggregateArgs>(args: Subset<T, FoodNutrientAggregateArgs>): Prisma.PrismaPromise<GetFoodNutrientAggregateType<T>>

    /**
     * Group by FoodNutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodNutrientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodNutrientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodNutrientGroupByArgs['orderBy'] }
        : { orderBy?: FoodNutrientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodNutrientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodNutrientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodNutrient model
   */
  readonly fields: FoodNutrientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodNutrient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodNutrientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nutrient<T extends NutrientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NutrientDefaultArgs<ExtArgs>>): Prisma__NutrientClient<$Result.GetResult<Prisma.$NutrientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodNutrient model
   */
  interface FoodNutrientFieldRefs {
    readonly food_id: FieldRef<"FoodNutrient", 'String'>
    readonly nutrient_id: FieldRef<"FoodNutrient", 'String'>
    readonly amount: FieldRef<"FoodNutrient", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * FoodNutrient findUnique
   */
  export type FoodNutrientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter, which FoodNutrient to fetch.
     */
    where: FoodNutrientWhereUniqueInput
  }

  /**
   * FoodNutrient findUniqueOrThrow
   */
  export type FoodNutrientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter, which FoodNutrient to fetch.
     */
    where: FoodNutrientWhereUniqueInput
  }

  /**
   * FoodNutrient findFirst
   */
  export type FoodNutrientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter, which FoodNutrient to fetch.
     */
    where?: FoodNutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodNutrients to fetch.
     */
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodNutrients.
     */
    cursor?: FoodNutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodNutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodNutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodNutrients.
     */
    distinct?: FoodNutrientScalarFieldEnum | FoodNutrientScalarFieldEnum[]
  }

  /**
   * FoodNutrient findFirstOrThrow
   */
  export type FoodNutrientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter, which FoodNutrient to fetch.
     */
    where?: FoodNutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodNutrients to fetch.
     */
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodNutrients.
     */
    cursor?: FoodNutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodNutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodNutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodNutrients.
     */
    distinct?: FoodNutrientScalarFieldEnum | FoodNutrientScalarFieldEnum[]
  }

  /**
   * FoodNutrient findMany
   */
  export type FoodNutrientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter, which FoodNutrients to fetch.
     */
    where?: FoodNutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodNutrients to fetch.
     */
    orderBy?: FoodNutrientOrderByWithRelationInput | FoodNutrientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodNutrients.
     */
    cursor?: FoodNutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodNutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodNutrients.
     */
    skip?: number
    distinct?: FoodNutrientScalarFieldEnum | FoodNutrientScalarFieldEnum[]
  }

  /**
   * FoodNutrient create
   */
  export type FoodNutrientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodNutrient.
     */
    data: XOR<FoodNutrientCreateInput, FoodNutrientUncheckedCreateInput>
  }

  /**
   * FoodNutrient createMany
   */
  export type FoodNutrientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodNutrients.
     */
    data: FoodNutrientCreateManyInput | FoodNutrientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodNutrient createManyAndReturn
   */
  export type FoodNutrientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * The data used to create many FoodNutrients.
     */
    data: FoodNutrientCreateManyInput | FoodNutrientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodNutrient update
   */
  export type FoodNutrientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodNutrient.
     */
    data: XOR<FoodNutrientUpdateInput, FoodNutrientUncheckedUpdateInput>
    /**
     * Choose, which FoodNutrient to update.
     */
    where: FoodNutrientWhereUniqueInput
  }

  /**
   * FoodNutrient updateMany
   */
  export type FoodNutrientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodNutrients.
     */
    data: XOR<FoodNutrientUpdateManyMutationInput, FoodNutrientUncheckedUpdateManyInput>
    /**
     * Filter which FoodNutrients to update
     */
    where?: FoodNutrientWhereInput
    /**
     * Limit how many FoodNutrients to update.
     */
    limit?: number
  }

  /**
   * FoodNutrient updateManyAndReturn
   */
  export type FoodNutrientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * The data used to update FoodNutrients.
     */
    data: XOR<FoodNutrientUpdateManyMutationInput, FoodNutrientUncheckedUpdateManyInput>
    /**
     * Filter which FoodNutrients to update
     */
    where?: FoodNutrientWhereInput
    /**
     * Limit how many FoodNutrients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodNutrient upsert
   */
  export type FoodNutrientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodNutrient to update in case it exists.
     */
    where: FoodNutrientWhereUniqueInput
    /**
     * In case the FoodNutrient found by the `where` argument doesn't exist, create a new FoodNutrient with this data.
     */
    create: XOR<FoodNutrientCreateInput, FoodNutrientUncheckedCreateInput>
    /**
     * In case the FoodNutrient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodNutrientUpdateInput, FoodNutrientUncheckedUpdateInput>
  }

  /**
   * FoodNutrient delete
   */
  export type FoodNutrientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
    /**
     * Filter which FoodNutrient to delete.
     */
    where: FoodNutrientWhereUniqueInput
  }

  /**
   * FoodNutrient deleteMany
   */
  export type FoodNutrientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodNutrients to delete
     */
    where?: FoodNutrientWhereInput
    /**
     * Limit how many FoodNutrients to delete.
     */
    limit?: number
  }

  /**
   * FoodNutrient without action
   */
  export type FoodNutrientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodNutrient
     */
    select?: FoodNutrientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodNutrient
     */
    omit?: FoodNutrientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodNutrientInclude<ExtArgs> | null
  }


  /**
   * Model FoodRasa
   */

  export type AggregateFoodRasa = {
    _count: FoodRasaCountAggregateOutputType | null
    _min: FoodRasaMinAggregateOutputType | null
    _max: FoodRasaMaxAggregateOutputType | null
  }

  export type FoodRasaMinAggregateOutputType = {
    food_id: string | null
    rasa_id: string | null
  }

  export type FoodRasaMaxAggregateOutputType = {
    food_id: string | null
    rasa_id: string | null
  }

  export type FoodRasaCountAggregateOutputType = {
    food_id: number
    rasa_id: number
    _all: number
  }


  export type FoodRasaMinAggregateInputType = {
    food_id?: true
    rasa_id?: true
  }

  export type FoodRasaMaxAggregateInputType = {
    food_id?: true
    rasa_id?: true
  }

  export type FoodRasaCountAggregateInputType = {
    food_id?: true
    rasa_id?: true
    _all?: true
  }

  export type FoodRasaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRasa to aggregate.
     */
    where?: FoodRasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRasas to fetch.
     */
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodRasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodRasas
    **/
    _count?: true | FoodRasaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodRasaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodRasaMaxAggregateInputType
  }

  export type GetFoodRasaAggregateType<T extends FoodRasaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodRasa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodRasa[P]>
      : GetScalarType<T[P], AggregateFoodRasa[P]>
  }




  export type FoodRasaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRasaWhereInput
    orderBy?: FoodRasaOrderByWithAggregationInput | FoodRasaOrderByWithAggregationInput[]
    by: FoodRasaScalarFieldEnum[] | FoodRasaScalarFieldEnum
    having?: FoodRasaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodRasaCountAggregateInputType | true
    _min?: FoodRasaMinAggregateInputType
    _max?: FoodRasaMaxAggregateInputType
  }

  export type FoodRasaGroupByOutputType = {
    food_id: string
    rasa_id: string
    _count: FoodRasaCountAggregateOutputType | null
    _min: FoodRasaMinAggregateOutputType | null
    _max: FoodRasaMaxAggregateOutputType | null
  }

  type GetFoodRasaGroupByPayload<T extends FoodRasaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodRasaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodRasaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodRasaGroupByOutputType[P]>
            : GetScalarType<T[P], FoodRasaGroupByOutputType[P]>
        }
      >
    >


  export type FoodRasaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    rasa_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRasa"]>

  export type FoodRasaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    rasa_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRasa"]>

  export type FoodRasaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    rasa_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRasa"]>

  export type FoodRasaSelectScalar = {
    food_id?: boolean
    rasa_id?: boolean
  }

  export type FoodRasaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "rasa_id", ExtArgs["result"]["foodRasa"]>
  export type FoodRasaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }
  export type FoodRasaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }
  export type FoodRasaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    rasa?: boolean | RasaDefaultArgs<ExtArgs>
  }

  export type $FoodRasaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodRasa"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      rasa: Prisma.$RasaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      rasa_id: string
    }, ExtArgs["result"]["foodRasa"]>
    composites: {}
  }

  type FoodRasaGetPayload<S extends boolean | null | undefined | FoodRasaDefaultArgs> = $Result.GetResult<Prisma.$FoodRasaPayload, S>

  type FoodRasaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodRasaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodRasaCountAggregateInputType | true
    }

  export interface FoodRasaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodRasa'], meta: { name: 'FoodRasa' } }
    /**
     * Find zero or one FoodRasa that matches the filter.
     * @param {FoodRasaFindUniqueArgs} args - Arguments to find a FoodRasa
     * @example
     * // Get one FoodRasa
     * const foodRasa = await prisma.foodRasa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodRasaFindUniqueArgs>(args: SelectSubset<T, FoodRasaFindUniqueArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodRasa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodRasaFindUniqueOrThrowArgs} args - Arguments to find a FoodRasa
     * @example
     * // Get one FoodRasa
     * const foodRasa = await prisma.foodRasa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodRasaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodRasaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRasa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaFindFirstArgs} args - Arguments to find a FoodRasa
     * @example
     * // Get one FoodRasa
     * const foodRasa = await prisma.foodRasa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodRasaFindFirstArgs>(args?: SelectSubset<T, FoodRasaFindFirstArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRasa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaFindFirstOrThrowArgs} args - Arguments to find a FoodRasa
     * @example
     * // Get one FoodRasa
     * const foodRasa = await prisma.foodRasa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodRasaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodRasaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodRasas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodRasas
     * const foodRasas = await prisma.foodRasa.findMany()
     * 
     * // Get first 10 FoodRasas
     * const foodRasas = await prisma.foodRasa.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodRasaWithFood_idOnly = await prisma.foodRasa.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodRasaFindManyArgs>(args?: SelectSubset<T, FoodRasaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodRasa.
     * @param {FoodRasaCreateArgs} args - Arguments to create a FoodRasa.
     * @example
     * // Create one FoodRasa
     * const FoodRasa = await prisma.foodRasa.create({
     *   data: {
     *     // ... data to create a FoodRasa
     *   }
     * })
     * 
     */
    create<T extends FoodRasaCreateArgs>(args: SelectSubset<T, FoodRasaCreateArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodRasas.
     * @param {FoodRasaCreateManyArgs} args - Arguments to create many FoodRasas.
     * @example
     * // Create many FoodRasas
     * const foodRasa = await prisma.foodRasa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodRasaCreateManyArgs>(args?: SelectSubset<T, FoodRasaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodRasas and returns the data saved in the database.
     * @param {FoodRasaCreateManyAndReturnArgs} args - Arguments to create many FoodRasas.
     * @example
     * // Create many FoodRasas
     * const foodRasa = await prisma.foodRasa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodRasas and only return the `food_id`
     * const foodRasaWithFood_idOnly = await prisma.foodRasa.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodRasaCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodRasaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodRasa.
     * @param {FoodRasaDeleteArgs} args - Arguments to delete one FoodRasa.
     * @example
     * // Delete one FoodRasa
     * const FoodRasa = await prisma.foodRasa.delete({
     *   where: {
     *     // ... filter to delete one FoodRasa
     *   }
     * })
     * 
     */
    delete<T extends FoodRasaDeleteArgs>(args: SelectSubset<T, FoodRasaDeleteArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodRasa.
     * @param {FoodRasaUpdateArgs} args - Arguments to update one FoodRasa.
     * @example
     * // Update one FoodRasa
     * const foodRasa = await prisma.foodRasa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodRasaUpdateArgs>(args: SelectSubset<T, FoodRasaUpdateArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodRasas.
     * @param {FoodRasaDeleteManyArgs} args - Arguments to filter FoodRasas to delete.
     * @example
     * // Delete a few FoodRasas
     * const { count } = await prisma.foodRasa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodRasaDeleteManyArgs>(args?: SelectSubset<T, FoodRasaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodRasas
     * const foodRasa = await prisma.foodRasa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodRasaUpdateManyArgs>(args: SelectSubset<T, FoodRasaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRasas and returns the data updated in the database.
     * @param {FoodRasaUpdateManyAndReturnArgs} args - Arguments to update many FoodRasas.
     * @example
     * // Update many FoodRasas
     * const foodRasa = await prisma.foodRasa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodRasas and only return the `food_id`
     * const foodRasaWithFood_idOnly = await prisma.foodRasa.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodRasaUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodRasaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodRasa.
     * @param {FoodRasaUpsertArgs} args - Arguments to update or create a FoodRasa.
     * @example
     * // Update or create a FoodRasa
     * const foodRasa = await prisma.foodRasa.upsert({
     *   create: {
     *     // ... data to create a FoodRasa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodRasa we want to update
     *   }
     * })
     */
    upsert<T extends FoodRasaUpsertArgs>(args: SelectSubset<T, FoodRasaUpsertArgs<ExtArgs>>): Prisma__FoodRasaClient<$Result.GetResult<Prisma.$FoodRasaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodRasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaCountArgs} args - Arguments to filter FoodRasas to count.
     * @example
     * // Count the number of FoodRasas
     * const count = await prisma.foodRasa.count({
     *   where: {
     *     // ... the filter for the FoodRasas we want to count
     *   }
     * })
    **/
    count<T extends FoodRasaCountArgs>(
      args?: Subset<T, FoodRasaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodRasaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodRasa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodRasaAggregateArgs>(args: Subset<T, FoodRasaAggregateArgs>): Prisma.PrismaPromise<GetFoodRasaAggregateType<T>>

    /**
     * Group by FoodRasa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRasaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodRasaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodRasaGroupByArgs['orderBy'] }
        : { orderBy?: FoodRasaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodRasaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodRasaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodRasa model
   */
  readonly fields: FoodRasaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodRasa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodRasaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rasa<T extends RasaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RasaDefaultArgs<ExtArgs>>): Prisma__RasaClient<$Result.GetResult<Prisma.$RasaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodRasa model
   */
  interface FoodRasaFieldRefs {
    readonly food_id: FieldRef<"FoodRasa", 'String'>
    readonly rasa_id: FieldRef<"FoodRasa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodRasa findUnique
   */
  export type FoodRasaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter, which FoodRasa to fetch.
     */
    where: FoodRasaWhereUniqueInput
  }

  /**
   * FoodRasa findUniqueOrThrow
   */
  export type FoodRasaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter, which FoodRasa to fetch.
     */
    where: FoodRasaWhereUniqueInput
  }

  /**
   * FoodRasa findFirst
   */
  export type FoodRasaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter, which FoodRasa to fetch.
     */
    where?: FoodRasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRasas to fetch.
     */
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRasas.
     */
    cursor?: FoodRasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRasas.
     */
    distinct?: FoodRasaScalarFieldEnum | FoodRasaScalarFieldEnum[]
  }

  /**
   * FoodRasa findFirstOrThrow
   */
  export type FoodRasaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter, which FoodRasa to fetch.
     */
    where?: FoodRasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRasas to fetch.
     */
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRasas.
     */
    cursor?: FoodRasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRasas.
     */
    distinct?: FoodRasaScalarFieldEnum | FoodRasaScalarFieldEnum[]
  }

  /**
   * FoodRasa findMany
   */
  export type FoodRasaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter, which FoodRasas to fetch.
     */
    where?: FoodRasaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRasas to fetch.
     */
    orderBy?: FoodRasaOrderByWithRelationInput | FoodRasaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodRasas.
     */
    cursor?: FoodRasaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRasas.
     */
    skip?: number
    distinct?: FoodRasaScalarFieldEnum | FoodRasaScalarFieldEnum[]
  }

  /**
   * FoodRasa create
   */
  export type FoodRasaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodRasa.
     */
    data: XOR<FoodRasaCreateInput, FoodRasaUncheckedCreateInput>
  }

  /**
   * FoodRasa createMany
   */
  export type FoodRasaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodRasas.
     */
    data: FoodRasaCreateManyInput | FoodRasaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodRasa createManyAndReturn
   */
  export type FoodRasaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * The data used to create many FoodRasas.
     */
    data: FoodRasaCreateManyInput | FoodRasaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRasa update
   */
  export type FoodRasaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodRasa.
     */
    data: XOR<FoodRasaUpdateInput, FoodRasaUncheckedUpdateInput>
    /**
     * Choose, which FoodRasa to update.
     */
    where: FoodRasaWhereUniqueInput
  }

  /**
   * FoodRasa updateMany
   */
  export type FoodRasaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodRasas.
     */
    data: XOR<FoodRasaUpdateManyMutationInput, FoodRasaUncheckedUpdateManyInput>
    /**
     * Filter which FoodRasas to update
     */
    where?: FoodRasaWhereInput
    /**
     * Limit how many FoodRasas to update.
     */
    limit?: number
  }

  /**
   * FoodRasa updateManyAndReturn
   */
  export type FoodRasaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * The data used to update FoodRasas.
     */
    data: XOR<FoodRasaUpdateManyMutationInput, FoodRasaUncheckedUpdateManyInput>
    /**
     * Filter which FoodRasas to update
     */
    where?: FoodRasaWhereInput
    /**
     * Limit how many FoodRasas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRasa upsert
   */
  export type FoodRasaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodRasa to update in case it exists.
     */
    where: FoodRasaWhereUniqueInput
    /**
     * In case the FoodRasa found by the `where` argument doesn't exist, create a new FoodRasa with this data.
     */
    create: XOR<FoodRasaCreateInput, FoodRasaUncheckedCreateInput>
    /**
     * In case the FoodRasa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodRasaUpdateInput, FoodRasaUncheckedUpdateInput>
  }

  /**
   * FoodRasa delete
   */
  export type FoodRasaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
    /**
     * Filter which FoodRasa to delete.
     */
    where: FoodRasaWhereUniqueInput
  }

  /**
   * FoodRasa deleteMany
   */
  export type FoodRasaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRasas to delete
     */
    where?: FoodRasaWhereInput
    /**
     * Limit how many FoodRasas to delete.
     */
    limit?: number
  }

  /**
   * FoodRasa without action
   */
  export type FoodRasaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRasa
     */
    select?: FoodRasaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRasa
     */
    omit?: FoodRasaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRasaInclude<ExtArgs> | null
  }


  /**
   * Model FoodGuna
   */

  export type AggregateFoodGuna = {
    _count: FoodGunaCountAggregateOutputType | null
    _min: FoodGunaMinAggregateOutputType | null
    _max: FoodGunaMaxAggregateOutputType | null
  }

  export type FoodGunaMinAggregateOutputType = {
    food_id: string | null
    guna_id: string | null
  }

  export type FoodGunaMaxAggregateOutputType = {
    food_id: string | null
    guna_id: string | null
  }

  export type FoodGunaCountAggregateOutputType = {
    food_id: number
    guna_id: number
    _all: number
  }


  export type FoodGunaMinAggregateInputType = {
    food_id?: true
    guna_id?: true
  }

  export type FoodGunaMaxAggregateInputType = {
    food_id?: true
    guna_id?: true
  }

  export type FoodGunaCountAggregateInputType = {
    food_id?: true
    guna_id?: true
    _all?: true
  }

  export type FoodGunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodGuna to aggregate.
     */
    where?: FoodGunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodGunas to fetch.
     */
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodGunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodGunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodGunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodGunas
    **/
    _count?: true | FoodGunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodGunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodGunaMaxAggregateInputType
  }

  export type GetFoodGunaAggregateType<T extends FoodGunaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodGuna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodGuna[P]>
      : GetScalarType<T[P], AggregateFoodGuna[P]>
  }




  export type FoodGunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodGunaWhereInput
    orderBy?: FoodGunaOrderByWithAggregationInput | FoodGunaOrderByWithAggregationInput[]
    by: FoodGunaScalarFieldEnum[] | FoodGunaScalarFieldEnum
    having?: FoodGunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodGunaCountAggregateInputType | true
    _min?: FoodGunaMinAggregateInputType
    _max?: FoodGunaMaxAggregateInputType
  }

  export type FoodGunaGroupByOutputType = {
    food_id: string
    guna_id: string
    _count: FoodGunaCountAggregateOutputType | null
    _min: FoodGunaMinAggregateOutputType | null
    _max: FoodGunaMaxAggregateOutputType | null
  }

  type GetFoodGunaGroupByPayload<T extends FoodGunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGunaGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGunaGroupByOutputType[P]>
        }
      >
    >


  export type FoodGunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    guna_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodGuna"]>

  export type FoodGunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    guna_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodGuna"]>

  export type FoodGunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    guna_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodGuna"]>

  export type FoodGunaSelectScalar = {
    food_id?: boolean
    guna_id?: boolean
  }

  export type FoodGunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "guna_id", ExtArgs["result"]["foodGuna"]>
  export type FoodGunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }
  export type FoodGunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }
  export type FoodGunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    guna?: boolean | GunaDefaultArgs<ExtArgs>
  }

  export type $FoodGunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodGuna"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      guna: Prisma.$GunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      guna_id: string
    }, ExtArgs["result"]["foodGuna"]>
    composites: {}
  }

  type FoodGunaGetPayload<S extends boolean | null | undefined | FoodGunaDefaultArgs> = $Result.GetResult<Prisma.$FoodGunaPayload, S>

  type FoodGunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodGunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodGunaCountAggregateInputType | true
    }

  export interface FoodGunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodGuna'], meta: { name: 'FoodGuna' } }
    /**
     * Find zero or one FoodGuna that matches the filter.
     * @param {FoodGunaFindUniqueArgs} args - Arguments to find a FoodGuna
     * @example
     * // Get one FoodGuna
     * const foodGuna = await prisma.foodGuna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodGunaFindUniqueArgs>(args: SelectSubset<T, FoodGunaFindUniqueArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodGuna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodGunaFindUniqueOrThrowArgs} args - Arguments to find a FoodGuna
     * @example
     * // Get one FoodGuna
     * const foodGuna = await prisma.foodGuna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodGunaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodGunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodGuna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaFindFirstArgs} args - Arguments to find a FoodGuna
     * @example
     * // Get one FoodGuna
     * const foodGuna = await prisma.foodGuna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodGunaFindFirstArgs>(args?: SelectSubset<T, FoodGunaFindFirstArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodGuna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaFindFirstOrThrowArgs} args - Arguments to find a FoodGuna
     * @example
     * // Get one FoodGuna
     * const foodGuna = await prisma.foodGuna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodGunaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodGunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodGunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodGunas
     * const foodGunas = await prisma.foodGuna.findMany()
     * 
     * // Get first 10 FoodGunas
     * const foodGunas = await prisma.foodGuna.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodGunaWithFood_idOnly = await prisma.foodGuna.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodGunaFindManyArgs>(args?: SelectSubset<T, FoodGunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodGuna.
     * @param {FoodGunaCreateArgs} args - Arguments to create a FoodGuna.
     * @example
     * // Create one FoodGuna
     * const FoodGuna = await prisma.foodGuna.create({
     *   data: {
     *     // ... data to create a FoodGuna
     *   }
     * })
     * 
     */
    create<T extends FoodGunaCreateArgs>(args: SelectSubset<T, FoodGunaCreateArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodGunas.
     * @param {FoodGunaCreateManyArgs} args - Arguments to create many FoodGunas.
     * @example
     * // Create many FoodGunas
     * const foodGuna = await prisma.foodGuna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodGunaCreateManyArgs>(args?: SelectSubset<T, FoodGunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodGunas and returns the data saved in the database.
     * @param {FoodGunaCreateManyAndReturnArgs} args - Arguments to create many FoodGunas.
     * @example
     * // Create many FoodGunas
     * const foodGuna = await prisma.foodGuna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodGunas and only return the `food_id`
     * const foodGunaWithFood_idOnly = await prisma.foodGuna.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodGunaCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodGunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodGuna.
     * @param {FoodGunaDeleteArgs} args - Arguments to delete one FoodGuna.
     * @example
     * // Delete one FoodGuna
     * const FoodGuna = await prisma.foodGuna.delete({
     *   where: {
     *     // ... filter to delete one FoodGuna
     *   }
     * })
     * 
     */
    delete<T extends FoodGunaDeleteArgs>(args: SelectSubset<T, FoodGunaDeleteArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodGuna.
     * @param {FoodGunaUpdateArgs} args - Arguments to update one FoodGuna.
     * @example
     * // Update one FoodGuna
     * const foodGuna = await prisma.foodGuna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodGunaUpdateArgs>(args: SelectSubset<T, FoodGunaUpdateArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodGunas.
     * @param {FoodGunaDeleteManyArgs} args - Arguments to filter FoodGunas to delete.
     * @example
     * // Delete a few FoodGunas
     * const { count } = await prisma.foodGuna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodGunaDeleteManyArgs>(args?: SelectSubset<T, FoodGunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodGunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodGunas
     * const foodGuna = await prisma.foodGuna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodGunaUpdateManyArgs>(args: SelectSubset<T, FoodGunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodGunas and returns the data updated in the database.
     * @param {FoodGunaUpdateManyAndReturnArgs} args - Arguments to update many FoodGunas.
     * @example
     * // Update many FoodGunas
     * const foodGuna = await prisma.foodGuna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodGunas and only return the `food_id`
     * const foodGunaWithFood_idOnly = await prisma.foodGuna.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodGunaUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodGunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodGuna.
     * @param {FoodGunaUpsertArgs} args - Arguments to update or create a FoodGuna.
     * @example
     * // Update or create a FoodGuna
     * const foodGuna = await prisma.foodGuna.upsert({
     *   create: {
     *     // ... data to create a FoodGuna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodGuna we want to update
     *   }
     * })
     */
    upsert<T extends FoodGunaUpsertArgs>(args: SelectSubset<T, FoodGunaUpsertArgs<ExtArgs>>): Prisma__FoodGunaClient<$Result.GetResult<Prisma.$FoodGunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodGunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaCountArgs} args - Arguments to filter FoodGunas to count.
     * @example
     * // Count the number of FoodGunas
     * const count = await prisma.foodGuna.count({
     *   where: {
     *     // ... the filter for the FoodGunas we want to count
     *   }
     * })
    **/
    count<T extends FoodGunaCountArgs>(
      args?: Subset<T, FoodGunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodGunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodGuna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodGunaAggregateArgs>(args: Subset<T, FoodGunaAggregateArgs>): Prisma.PrismaPromise<GetFoodGunaAggregateType<T>>

    /**
     * Group by FoodGuna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGunaGroupByArgs['orderBy'] }
        : { orderBy?: FoodGunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodGuna model
   */
  readonly fields: FoodGunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodGuna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodGunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guna<T extends GunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GunaDefaultArgs<ExtArgs>>): Prisma__GunaClient<$Result.GetResult<Prisma.$GunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodGuna model
   */
  interface FoodGunaFieldRefs {
    readonly food_id: FieldRef<"FoodGuna", 'String'>
    readonly guna_id: FieldRef<"FoodGuna", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodGuna findUnique
   */
  export type FoodGunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter, which FoodGuna to fetch.
     */
    where: FoodGunaWhereUniqueInput
  }

  /**
   * FoodGuna findUniqueOrThrow
   */
  export type FoodGunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter, which FoodGuna to fetch.
     */
    where: FoodGunaWhereUniqueInput
  }

  /**
   * FoodGuna findFirst
   */
  export type FoodGunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter, which FoodGuna to fetch.
     */
    where?: FoodGunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodGunas to fetch.
     */
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodGunas.
     */
    cursor?: FoodGunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodGunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodGunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodGunas.
     */
    distinct?: FoodGunaScalarFieldEnum | FoodGunaScalarFieldEnum[]
  }

  /**
   * FoodGuna findFirstOrThrow
   */
  export type FoodGunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter, which FoodGuna to fetch.
     */
    where?: FoodGunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodGunas to fetch.
     */
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodGunas.
     */
    cursor?: FoodGunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodGunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodGunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodGunas.
     */
    distinct?: FoodGunaScalarFieldEnum | FoodGunaScalarFieldEnum[]
  }

  /**
   * FoodGuna findMany
   */
  export type FoodGunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter, which FoodGunas to fetch.
     */
    where?: FoodGunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodGunas to fetch.
     */
    orderBy?: FoodGunaOrderByWithRelationInput | FoodGunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodGunas.
     */
    cursor?: FoodGunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodGunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodGunas.
     */
    skip?: number
    distinct?: FoodGunaScalarFieldEnum | FoodGunaScalarFieldEnum[]
  }

  /**
   * FoodGuna create
   */
  export type FoodGunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodGuna.
     */
    data: XOR<FoodGunaCreateInput, FoodGunaUncheckedCreateInput>
  }

  /**
   * FoodGuna createMany
   */
  export type FoodGunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodGunas.
     */
    data: FoodGunaCreateManyInput | FoodGunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodGuna createManyAndReturn
   */
  export type FoodGunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * The data used to create many FoodGunas.
     */
    data: FoodGunaCreateManyInput | FoodGunaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodGuna update
   */
  export type FoodGunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodGuna.
     */
    data: XOR<FoodGunaUpdateInput, FoodGunaUncheckedUpdateInput>
    /**
     * Choose, which FoodGuna to update.
     */
    where: FoodGunaWhereUniqueInput
  }

  /**
   * FoodGuna updateMany
   */
  export type FoodGunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodGunas.
     */
    data: XOR<FoodGunaUpdateManyMutationInput, FoodGunaUncheckedUpdateManyInput>
    /**
     * Filter which FoodGunas to update
     */
    where?: FoodGunaWhereInput
    /**
     * Limit how many FoodGunas to update.
     */
    limit?: number
  }

  /**
   * FoodGuna updateManyAndReturn
   */
  export type FoodGunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * The data used to update FoodGunas.
     */
    data: XOR<FoodGunaUpdateManyMutationInput, FoodGunaUncheckedUpdateManyInput>
    /**
     * Filter which FoodGunas to update
     */
    where?: FoodGunaWhereInput
    /**
     * Limit how many FoodGunas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodGuna upsert
   */
  export type FoodGunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodGuna to update in case it exists.
     */
    where: FoodGunaWhereUniqueInput
    /**
     * In case the FoodGuna found by the `where` argument doesn't exist, create a new FoodGuna with this data.
     */
    create: XOR<FoodGunaCreateInput, FoodGunaUncheckedCreateInput>
    /**
     * In case the FoodGuna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodGunaUpdateInput, FoodGunaUncheckedUpdateInput>
  }

  /**
   * FoodGuna delete
   */
  export type FoodGunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
    /**
     * Filter which FoodGuna to delete.
     */
    where: FoodGunaWhereUniqueInput
  }

  /**
   * FoodGuna deleteMany
   */
  export type FoodGunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodGunas to delete
     */
    where?: FoodGunaWhereInput
    /**
     * Limit how many FoodGunas to delete.
     */
    limit?: number
  }

  /**
   * FoodGuna without action
   */
  export type FoodGunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodGuna
     */
    select?: FoodGunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodGuna
     */
    omit?: FoodGunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodGunaInclude<ExtArgs> | null
  }


  /**
   * Model FoodDosha
   */

  export type AggregateFoodDosha = {
    _count: FoodDoshaCountAggregateOutputType | null
    _min: FoodDoshaMinAggregateOutputType | null
    _max: FoodDoshaMaxAggregateOutputType | null
  }

  export type FoodDoshaMinAggregateOutputType = {
    food_id: string | null
    dosha_id: string | null
  }

  export type FoodDoshaMaxAggregateOutputType = {
    food_id: string | null
    dosha_id: string | null
  }

  export type FoodDoshaCountAggregateOutputType = {
    food_id: number
    dosha_id: number
    _all: number
  }


  export type FoodDoshaMinAggregateInputType = {
    food_id?: true
    dosha_id?: true
  }

  export type FoodDoshaMaxAggregateInputType = {
    food_id?: true
    dosha_id?: true
  }

  export type FoodDoshaCountAggregateInputType = {
    food_id?: true
    dosha_id?: true
    _all?: true
  }

  export type FoodDoshaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodDosha to aggregate.
     */
    where?: FoodDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDoshas to fetch.
     */
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodDoshas
    **/
    _count?: true | FoodDoshaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodDoshaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodDoshaMaxAggregateInputType
  }

  export type GetFoodDoshaAggregateType<T extends FoodDoshaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodDosha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodDosha[P]>
      : GetScalarType<T[P], AggregateFoodDosha[P]>
  }




  export type FoodDoshaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDoshaWhereInput
    orderBy?: FoodDoshaOrderByWithAggregationInput | FoodDoshaOrderByWithAggregationInput[]
    by: FoodDoshaScalarFieldEnum[] | FoodDoshaScalarFieldEnum
    having?: FoodDoshaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodDoshaCountAggregateInputType | true
    _min?: FoodDoshaMinAggregateInputType
    _max?: FoodDoshaMaxAggregateInputType
  }

  export type FoodDoshaGroupByOutputType = {
    food_id: string
    dosha_id: string
    _count: FoodDoshaCountAggregateOutputType | null
    _min: FoodDoshaMinAggregateOutputType | null
    _max: FoodDoshaMaxAggregateOutputType | null
  }

  type GetFoodDoshaGroupByPayload<T extends FoodDoshaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodDoshaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodDoshaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodDoshaGroupByOutputType[P]>
            : GetScalarType<T[P], FoodDoshaGroupByOutputType[P]>
        }
      >
    >


  export type FoodDoshaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    dosha_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDosha"]>

  export type FoodDoshaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    dosha_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDosha"]>

  export type FoodDoshaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    dosha_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDosha"]>

  export type FoodDoshaSelectScalar = {
    food_id?: boolean
    dosha_id?: boolean
  }

  export type FoodDoshaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "dosha_id", ExtArgs["result"]["foodDosha"]>
  export type FoodDoshaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }
  export type FoodDoshaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }
  export type FoodDoshaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }

  export type $FoodDoshaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodDosha"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      dosha: Prisma.$DoshaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      dosha_id: string
    }, ExtArgs["result"]["foodDosha"]>
    composites: {}
  }

  type FoodDoshaGetPayload<S extends boolean | null | undefined | FoodDoshaDefaultArgs> = $Result.GetResult<Prisma.$FoodDoshaPayload, S>

  type FoodDoshaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodDoshaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodDoshaCountAggregateInputType | true
    }

  export interface FoodDoshaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodDosha'], meta: { name: 'FoodDosha' } }
    /**
     * Find zero or one FoodDosha that matches the filter.
     * @param {FoodDoshaFindUniqueArgs} args - Arguments to find a FoodDosha
     * @example
     * // Get one FoodDosha
     * const foodDosha = await prisma.foodDosha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodDoshaFindUniqueArgs>(args: SelectSubset<T, FoodDoshaFindUniqueArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodDosha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodDoshaFindUniqueOrThrowArgs} args - Arguments to find a FoodDosha
     * @example
     * // Get one FoodDosha
     * const foodDosha = await prisma.foodDosha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodDoshaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodDoshaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodDosha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaFindFirstArgs} args - Arguments to find a FoodDosha
     * @example
     * // Get one FoodDosha
     * const foodDosha = await prisma.foodDosha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodDoshaFindFirstArgs>(args?: SelectSubset<T, FoodDoshaFindFirstArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodDosha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaFindFirstOrThrowArgs} args - Arguments to find a FoodDosha
     * @example
     * // Get one FoodDosha
     * const foodDosha = await prisma.foodDosha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodDoshaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodDoshaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodDoshas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodDoshas
     * const foodDoshas = await prisma.foodDosha.findMany()
     * 
     * // Get first 10 FoodDoshas
     * const foodDoshas = await prisma.foodDosha.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodDoshaWithFood_idOnly = await prisma.foodDosha.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodDoshaFindManyArgs>(args?: SelectSubset<T, FoodDoshaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodDosha.
     * @param {FoodDoshaCreateArgs} args - Arguments to create a FoodDosha.
     * @example
     * // Create one FoodDosha
     * const FoodDosha = await prisma.foodDosha.create({
     *   data: {
     *     // ... data to create a FoodDosha
     *   }
     * })
     * 
     */
    create<T extends FoodDoshaCreateArgs>(args: SelectSubset<T, FoodDoshaCreateArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodDoshas.
     * @param {FoodDoshaCreateManyArgs} args - Arguments to create many FoodDoshas.
     * @example
     * // Create many FoodDoshas
     * const foodDosha = await prisma.foodDosha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodDoshaCreateManyArgs>(args?: SelectSubset<T, FoodDoshaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodDoshas and returns the data saved in the database.
     * @param {FoodDoshaCreateManyAndReturnArgs} args - Arguments to create many FoodDoshas.
     * @example
     * // Create many FoodDoshas
     * const foodDosha = await prisma.foodDosha.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodDoshas and only return the `food_id`
     * const foodDoshaWithFood_idOnly = await prisma.foodDosha.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodDoshaCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodDoshaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodDosha.
     * @param {FoodDoshaDeleteArgs} args - Arguments to delete one FoodDosha.
     * @example
     * // Delete one FoodDosha
     * const FoodDosha = await prisma.foodDosha.delete({
     *   where: {
     *     // ... filter to delete one FoodDosha
     *   }
     * })
     * 
     */
    delete<T extends FoodDoshaDeleteArgs>(args: SelectSubset<T, FoodDoshaDeleteArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodDosha.
     * @param {FoodDoshaUpdateArgs} args - Arguments to update one FoodDosha.
     * @example
     * // Update one FoodDosha
     * const foodDosha = await prisma.foodDosha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodDoshaUpdateArgs>(args: SelectSubset<T, FoodDoshaUpdateArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodDoshas.
     * @param {FoodDoshaDeleteManyArgs} args - Arguments to filter FoodDoshas to delete.
     * @example
     * // Delete a few FoodDoshas
     * const { count } = await prisma.foodDosha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDoshaDeleteManyArgs>(args?: SelectSubset<T, FoodDoshaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodDoshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodDoshas
     * const foodDosha = await prisma.foodDosha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodDoshaUpdateManyArgs>(args: SelectSubset<T, FoodDoshaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodDoshas and returns the data updated in the database.
     * @param {FoodDoshaUpdateManyAndReturnArgs} args - Arguments to update many FoodDoshas.
     * @example
     * // Update many FoodDoshas
     * const foodDosha = await prisma.foodDosha.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodDoshas and only return the `food_id`
     * const foodDoshaWithFood_idOnly = await prisma.foodDosha.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodDoshaUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodDoshaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodDosha.
     * @param {FoodDoshaUpsertArgs} args - Arguments to update or create a FoodDosha.
     * @example
     * // Update or create a FoodDosha
     * const foodDosha = await prisma.foodDosha.upsert({
     *   create: {
     *     // ... data to create a FoodDosha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodDosha we want to update
     *   }
     * })
     */
    upsert<T extends FoodDoshaUpsertArgs>(args: SelectSubset<T, FoodDoshaUpsertArgs<ExtArgs>>): Prisma__FoodDoshaClient<$Result.GetResult<Prisma.$FoodDoshaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodDoshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaCountArgs} args - Arguments to filter FoodDoshas to count.
     * @example
     * // Count the number of FoodDoshas
     * const count = await prisma.foodDosha.count({
     *   where: {
     *     // ... the filter for the FoodDoshas we want to count
     *   }
     * })
    **/
    count<T extends FoodDoshaCountArgs>(
      args?: Subset<T, FoodDoshaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodDoshaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodDosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodDoshaAggregateArgs>(args: Subset<T, FoodDoshaAggregateArgs>): Prisma.PrismaPromise<GetFoodDoshaAggregateType<T>>

    /**
     * Group by FoodDosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDoshaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodDoshaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodDoshaGroupByArgs['orderBy'] }
        : { orderBy?: FoodDoshaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodDoshaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodDoshaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodDosha model
   */
  readonly fields: FoodDoshaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodDosha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodDoshaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dosha<T extends DoshaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoshaDefaultArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodDosha model
   */
  interface FoodDoshaFieldRefs {
    readonly food_id: FieldRef<"FoodDosha", 'String'>
    readonly dosha_id: FieldRef<"FoodDosha", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodDosha findUnique
   */
  export type FoodDoshaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter, which FoodDosha to fetch.
     */
    where: FoodDoshaWhereUniqueInput
  }

  /**
   * FoodDosha findUniqueOrThrow
   */
  export type FoodDoshaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter, which FoodDosha to fetch.
     */
    where: FoodDoshaWhereUniqueInput
  }

  /**
   * FoodDosha findFirst
   */
  export type FoodDoshaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter, which FoodDosha to fetch.
     */
    where?: FoodDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDoshas to fetch.
     */
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodDoshas.
     */
    cursor?: FoodDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodDoshas.
     */
    distinct?: FoodDoshaScalarFieldEnum | FoodDoshaScalarFieldEnum[]
  }

  /**
   * FoodDosha findFirstOrThrow
   */
  export type FoodDoshaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter, which FoodDosha to fetch.
     */
    where?: FoodDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDoshas to fetch.
     */
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodDoshas.
     */
    cursor?: FoodDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodDoshas.
     */
    distinct?: FoodDoshaScalarFieldEnum | FoodDoshaScalarFieldEnum[]
  }

  /**
   * FoodDosha findMany
   */
  export type FoodDoshaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter, which FoodDoshas to fetch.
     */
    where?: FoodDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDoshas to fetch.
     */
    orderBy?: FoodDoshaOrderByWithRelationInput | FoodDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodDoshas.
     */
    cursor?: FoodDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDoshas.
     */
    skip?: number
    distinct?: FoodDoshaScalarFieldEnum | FoodDoshaScalarFieldEnum[]
  }

  /**
   * FoodDosha create
   */
  export type FoodDoshaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodDosha.
     */
    data: XOR<FoodDoshaCreateInput, FoodDoshaUncheckedCreateInput>
  }

  /**
   * FoodDosha createMany
   */
  export type FoodDoshaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodDoshas.
     */
    data: FoodDoshaCreateManyInput | FoodDoshaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodDosha createManyAndReturn
   */
  export type FoodDoshaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * The data used to create many FoodDoshas.
     */
    data: FoodDoshaCreateManyInput | FoodDoshaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodDosha update
   */
  export type FoodDoshaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodDosha.
     */
    data: XOR<FoodDoshaUpdateInput, FoodDoshaUncheckedUpdateInput>
    /**
     * Choose, which FoodDosha to update.
     */
    where: FoodDoshaWhereUniqueInput
  }

  /**
   * FoodDosha updateMany
   */
  export type FoodDoshaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodDoshas.
     */
    data: XOR<FoodDoshaUpdateManyMutationInput, FoodDoshaUncheckedUpdateManyInput>
    /**
     * Filter which FoodDoshas to update
     */
    where?: FoodDoshaWhereInput
    /**
     * Limit how many FoodDoshas to update.
     */
    limit?: number
  }

  /**
   * FoodDosha updateManyAndReturn
   */
  export type FoodDoshaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * The data used to update FoodDoshas.
     */
    data: XOR<FoodDoshaUpdateManyMutationInput, FoodDoshaUncheckedUpdateManyInput>
    /**
     * Filter which FoodDoshas to update
     */
    where?: FoodDoshaWhereInput
    /**
     * Limit how many FoodDoshas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodDosha upsert
   */
  export type FoodDoshaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodDosha to update in case it exists.
     */
    where: FoodDoshaWhereUniqueInput
    /**
     * In case the FoodDosha found by the `where` argument doesn't exist, create a new FoodDosha with this data.
     */
    create: XOR<FoodDoshaCreateInput, FoodDoshaUncheckedCreateInput>
    /**
     * In case the FoodDosha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodDoshaUpdateInput, FoodDoshaUncheckedUpdateInput>
  }

  /**
   * FoodDosha delete
   */
  export type FoodDoshaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
    /**
     * Filter which FoodDosha to delete.
     */
    where: FoodDoshaWhereUniqueInput
  }

  /**
   * FoodDosha deleteMany
   */
  export type FoodDoshaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodDoshas to delete
     */
    where?: FoodDoshaWhereInput
    /**
     * Limit how many FoodDoshas to delete.
     */
    limit?: number
  }

  /**
   * FoodDosha without action
   */
  export type FoodDoshaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDosha
     */
    select?: FoodDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDosha
     */
    omit?: FoodDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDoshaInclude<ExtArgs> | null
  }


  /**
   * Model PatientDosha
   */

  export type AggregatePatientDosha = {
    _count: PatientDoshaCountAggregateOutputType | null
    _min: PatientDoshaMinAggregateOutputType | null
    _max: PatientDoshaMaxAggregateOutputType | null
  }

  export type PatientDoshaMinAggregateOutputType = {
    patient_id: string | null
    dosha_id: string | null
  }

  export type PatientDoshaMaxAggregateOutputType = {
    patient_id: string | null
    dosha_id: string | null
  }

  export type PatientDoshaCountAggregateOutputType = {
    patient_id: number
    dosha_id: number
    _all: number
  }


  export type PatientDoshaMinAggregateInputType = {
    patient_id?: true
    dosha_id?: true
  }

  export type PatientDoshaMaxAggregateInputType = {
    patient_id?: true
    dosha_id?: true
  }

  export type PatientDoshaCountAggregateInputType = {
    patient_id?: true
    dosha_id?: true
    _all?: true
  }

  export type PatientDoshaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientDosha to aggregate.
     */
    where?: PatientDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDoshas to fetch.
     */
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientDoshas
    **/
    _count?: true | PatientDoshaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientDoshaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientDoshaMaxAggregateInputType
  }

  export type GetPatientDoshaAggregateType<T extends PatientDoshaAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientDosha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientDosha[P]>
      : GetScalarType<T[P], AggregatePatientDosha[P]>
  }




  export type PatientDoshaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDoshaWhereInput
    orderBy?: PatientDoshaOrderByWithAggregationInput | PatientDoshaOrderByWithAggregationInput[]
    by: PatientDoshaScalarFieldEnum[] | PatientDoshaScalarFieldEnum
    having?: PatientDoshaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientDoshaCountAggregateInputType | true
    _min?: PatientDoshaMinAggregateInputType
    _max?: PatientDoshaMaxAggregateInputType
  }

  export type PatientDoshaGroupByOutputType = {
    patient_id: string
    dosha_id: string
    _count: PatientDoshaCountAggregateOutputType | null
    _min: PatientDoshaMinAggregateOutputType | null
    _max: PatientDoshaMaxAggregateOutputType | null
  }

  type GetPatientDoshaGroupByPayload<T extends PatientDoshaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientDoshaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientDoshaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientDoshaGroupByOutputType[P]>
            : GetScalarType<T[P], PatientDoshaGroupByOutputType[P]>
        }
      >
    >


  export type PatientDoshaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    dosha_id?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientDosha"]>

  export type PatientDoshaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    dosha_id?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientDosha"]>

  export type PatientDoshaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    dosha_id?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientDosha"]>

  export type PatientDoshaSelectScalar = {
    patient_id?: boolean
    dosha_id?: boolean
  }

  export type PatientDoshaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"patient_id" | "dosha_id", ExtArgs["result"]["patientDosha"]>
  export type PatientDoshaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }
  export type PatientDoshaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }
  export type PatientDoshaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dosha?: boolean | DoshaDefaultArgs<ExtArgs>
  }

  export type $PatientDoshaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientDosha"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      dosha: Prisma.$DoshaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_id: string
      dosha_id: string
    }, ExtArgs["result"]["patientDosha"]>
    composites: {}
  }

  type PatientDoshaGetPayload<S extends boolean | null | undefined | PatientDoshaDefaultArgs> = $Result.GetResult<Prisma.$PatientDoshaPayload, S>

  type PatientDoshaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientDoshaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientDoshaCountAggregateInputType | true
    }

  export interface PatientDoshaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientDosha'], meta: { name: 'PatientDosha' } }
    /**
     * Find zero or one PatientDosha that matches the filter.
     * @param {PatientDoshaFindUniqueArgs} args - Arguments to find a PatientDosha
     * @example
     * // Get one PatientDosha
     * const patientDosha = await prisma.patientDosha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientDoshaFindUniqueArgs>(args: SelectSubset<T, PatientDoshaFindUniqueArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientDosha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientDoshaFindUniqueOrThrowArgs} args - Arguments to find a PatientDosha
     * @example
     * // Get one PatientDosha
     * const patientDosha = await prisma.patientDosha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientDoshaFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientDoshaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientDosha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaFindFirstArgs} args - Arguments to find a PatientDosha
     * @example
     * // Get one PatientDosha
     * const patientDosha = await prisma.patientDosha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientDoshaFindFirstArgs>(args?: SelectSubset<T, PatientDoshaFindFirstArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientDosha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaFindFirstOrThrowArgs} args - Arguments to find a PatientDosha
     * @example
     * // Get one PatientDosha
     * const patientDosha = await prisma.patientDosha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientDoshaFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientDoshaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientDoshas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientDoshas
     * const patientDoshas = await prisma.patientDosha.findMany()
     * 
     * // Get first 10 PatientDoshas
     * const patientDoshas = await prisma.patientDosha.findMany({ take: 10 })
     * 
     * // Only select the `patient_id`
     * const patientDoshaWithPatient_idOnly = await prisma.patientDosha.findMany({ select: { patient_id: true } })
     * 
     */
    findMany<T extends PatientDoshaFindManyArgs>(args?: SelectSubset<T, PatientDoshaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientDosha.
     * @param {PatientDoshaCreateArgs} args - Arguments to create a PatientDosha.
     * @example
     * // Create one PatientDosha
     * const PatientDosha = await prisma.patientDosha.create({
     *   data: {
     *     // ... data to create a PatientDosha
     *   }
     * })
     * 
     */
    create<T extends PatientDoshaCreateArgs>(args: SelectSubset<T, PatientDoshaCreateArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientDoshas.
     * @param {PatientDoshaCreateManyArgs} args - Arguments to create many PatientDoshas.
     * @example
     * // Create many PatientDoshas
     * const patientDosha = await prisma.patientDosha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientDoshaCreateManyArgs>(args?: SelectSubset<T, PatientDoshaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientDoshas and returns the data saved in the database.
     * @param {PatientDoshaCreateManyAndReturnArgs} args - Arguments to create many PatientDoshas.
     * @example
     * // Create many PatientDoshas
     * const patientDosha = await prisma.patientDosha.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientDoshas and only return the `patient_id`
     * const patientDoshaWithPatient_idOnly = await prisma.patientDosha.createManyAndReturn({
     *   select: { patient_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientDoshaCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientDoshaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientDosha.
     * @param {PatientDoshaDeleteArgs} args - Arguments to delete one PatientDosha.
     * @example
     * // Delete one PatientDosha
     * const PatientDosha = await prisma.patientDosha.delete({
     *   where: {
     *     // ... filter to delete one PatientDosha
     *   }
     * })
     * 
     */
    delete<T extends PatientDoshaDeleteArgs>(args: SelectSubset<T, PatientDoshaDeleteArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientDosha.
     * @param {PatientDoshaUpdateArgs} args - Arguments to update one PatientDosha.
     * @example
     * // Update one PatientDosha
     * const patientDosha = await prisma.patientDosha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientDoshaUpdateArgs>(args: SelectSubset<T, PatientDoshaUpdateArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientDoshas.
     * @param {PatientDoshaDeleteManyArgs} args - Arguments to filter PatientDoshas to delete.
     * @example
     * // Delete a few PatientDoshas
     * const { count } = await prisma.patientDosha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDoshaDeleteManyArgs>(args?: SelectSubset<T, PatientDoshaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientDoshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientDoshas
     * const patientDosha = await prisma.patientDosha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientDoshaUpdateManyArgs>(args: SelectSubset<T, PatientDoshaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientDoshas and returns the data updated in the database.
     * @param {PatientDoshaUpdateManyAndReturnArgs} args - Arguments to update many PatientDoshas.
     * @example
     * // Update many PatientDoshas
     * const patientDosha = await prisma.patientDosha.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientDoshas and only return the `patient_id`
     * const patientDoshaWithPatient_idOnly = await prisma.patientDosha.updateManyAndReturn({
     *   select: { patient_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientDoshaUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientDoshaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientDosha.
     * @param {PatientDoshaUpsertArgs} args - Arguments to update or create a PatientDosha.
     * @example
     * // Update or create a PatientDosha
     * const patientDosha = await prisma.patientDosha.upsert({
     *   create: {
     *     // ... data to create a PatientDosha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientDosha we want to update
     *   }
     * })
     */
    upsert<T extends PatientDoshaUpsertArgs>(args: SelectSubset<T, PatientDoshaUpsertArgs<ExtArgs>>): Prisma__PatientDoshaClient<$Result.GetResult<Prisma.$PatientDoshaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientDoshas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaCountArgs} args - Arguments to filter PatientDoshas to count.
     * @example
     * // Count the number of PatientDoshas
     * const count = await prisma.patientDosha.count({
     *   where: {
     *     // ... the filter for the PatientDoshas we want to count
     *   }
     * })
    **/
    count<T extends PatientDoshaCountArgs>(
      args?: Subset<T, PatientDoshaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientDoshaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientDosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientDoshaAggregateArgs>(args: Subset<T, PatientDoshaAggregateArgs>): Prisma.PrismaPromise<GetPatientDoshaAggregateType<T>>

    /**
     * Group by PatientDosha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDoshaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientDoshaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientDoshaGroupByArgs['orderBy'] }
        : { orderBy?: PatientDoshaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientDoshaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientDoshaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientDosha model
   */
  readonly fields: PatientDoshaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientDosha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientDoshaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dosha<T extends DoshaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoshaDefaultArgs<ExtArgs>>): Prisma__DoshaClient<$Result.GetResult<Prisma.$DoshaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientDosha model
   */
  interface PatientDoshaFieldRefs {
    readonly patient_id: FieldRef<"PatientDosha", 'String'>
    readonly dosha_id: FieldRef<"PatientDosha", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PatientDosha findUnique
   */
  export type PatientDoshaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter, which PatientDosha to fetch.
     */
    where: PatientDoshaWhereUniqueInput
  }

  /**
   * PatientDosha findUniqueOrThrow
   */
  export type PatientDoshaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter, which PatientDosha to fetch.
     */
    where: PatientDoshaWhereUniqueInput
  }

  /**
   * PatientDosha findFirst
   */
  export type PatientDoshaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter, which PatientDosha to fetch.
     */
    where?: PatientDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDoshas to fetch.
     */
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientDoshas.
     */
    cursor?: PatientDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientDoshas.
     */
    distinct?: PatientDoshaScalarFieldEnum | PatientDoshaScalarFieldEnum[]
  }

  /**
   * PatientDosha findFirstOrThrow
   */
  export type PatientDoshaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter, which PatientDosha to fetch.
     */
    where?: PatientDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDoshas to fetch.
     */
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientDoshas.
     */
    cursor?: PatientDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDoshas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientDoshas.
     */
    distinct?: PatientDoshaScalarFieldEnum | PatientDoshaScalarFieldEnum[]
  }

  /**
   * PatientDosha findMany
   */
  export type PatientDoshaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter, which PatientDoshas to fetch.
     */
    where?: PatientDoshaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDoshas to fetch.
     */
    orderBy?: PatientDoshaOrderByWithRelationInput | PatientDoshaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientDoshas.
     */
    cursor?: PatientDoshaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDoshas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDoshas.
     */
    skip?: number
    distinct?: PatientDoshaScalarFieldEnum | PatientDoshaScalarFieldEnum[]
  }

  /**
   * PatientDosha create
   */
  export type PatientDoshaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientDosha.
     */
    data: XOR<PatientDoshaCreateInput, PatientDoshaUncheckedCreateInput>
  }

  /**
   * PatientDosha createMany
   */
  export type PatientDoshaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientDoshas.
     */
    data: PatientDoshaCreateManyInput | PatientDoshaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientDosha createManyAndReturn
   */
  export type PatientDoshaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * The data used to create many PatientDoshas.
     */
    data: PatientDoshaCreateManyInput | PatientDoshaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientDosha update
   */
  export type PatientDoshaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientDosha.
     */
    data: XOR<PatientDoshaUpdateInput, PatientDoshaUncheckedUpdateInput>
    /**
     * Choose, which PatientDosha to update.
     */
    where: PatientDoshaWhereUniqueInput
  }

  /**
   * PatientDosha updateMany
   */
  export type PatientDoshaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientDoshas.
     */
    data: XOR<PatientDoshaUpdateManyMutationInput, PatientDoshaUncheckedUpdateManyInput>
    /**
     * Filter which PatientDoshas to update
     */
    where?: PatientDoshaWhereInput
    /**
     * Limit how many PatientDoshas to update.
     */
    limit?: number
  }

  /**
   * PatientDosha updateManyAndReturn
   */
  export type PatientDoshaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * The data used to update PatientDoshas.
     */
    data: XOR<PatientDoshaUpdateManyMutationInput, PatientDoshaUncheckedUpdateManyInput>
    /**
     * Filter which PatientDoshas to update
     */
    where?: PatientDoshaWhereInput
    /**
     * Limit how many PatientDoshas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientDosha upsert
   */
  export type PatientDoshaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientDosha to update in case it exists.
     */
    where: PatientDoshaWhereUniqueInput
    /**
     * In case the PatientDosha found by the `where` argument doesn't exist, create a new PatientDosha with this data.
     */
    create: XOR<PatientDoshaCreateInput, PatientDoshaUncheckedCreateInput>
    /**
     * In case the PatientDosha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientDoshaUpdateInput, PatientDoshaUncheckedUpdateInput>
  }

  /**
   * PatientDosha delete
   */
  export type PatientDoshaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
    /**
     * Filter which PatientDosha to delete.
     */
    where: PatientDoshaWhereUniqueInput
  }

  /**
   * PatientDosha deleteMany
   */
  export type PatientDoshaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientDoshas to delete
     */
    where?: PatientDoshaWhereInput
    /**
     * Limit how many PatientDoshas to delete.
     */
    limit?: number
  }

  /**
   * PatientDosha without action
   */
  export type PatientDoshaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDosha
     */
    select?: PatientDoshaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDosha
     */
    omit?: PatientDoshaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDoshaInclude<ExtArgs> | null
  }


  /**
   * Model FoodVirya
   */

  export type AggregateFoodVirya = {
    _count: FoodViryaCountAggregateOutputType | null
    _min: FoodViryaMinAggregateOutputType | null
    _max: FoodViryaMaxAggregateOutputType | null
  }

  export type FoodViryaMinAggregateOutputType = {
    food_id: string | null
    virya_id: string | null
  }

  export type FoodViryaMaxAggregateOutputType = {
    food_id: string | null
    virya_id: string | null
  }

  export type FoodViryaCountAggregateOutputType = {
    food_id: number
    virya_id: number
    _all: number
  }


  export type FoodViryaMinAggregateInputType = {
    food_id?: true
    virya_id?: true
  }

  export type FoodViryaMaxAggregateInputType = {
    food_id?: true
    virya_id?: true
  }

  export type FoodViryaCountAggregateInputType = {
    food_id?: true
    virya_id?: true
    _all?: true
  }

  export type FoodViryaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodVirya to aggregate.
     */
    where?: FoodViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodViryas to fetch.
     */
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodViryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodViryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodViryas
    **/
    _count?: true | FoodViryaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodViryaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodViryaMaxAggregateInputType
  }

  export type GetFoodViryaAggregateType<T extends FoodViryaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodVirya]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodVirya[P]>
      : GetScalarType<T[P], AggregateFoodVirya[P]>
  }




  export type FoodViryaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodViryaWhereInput
    orderBy?: FoodViryaOrderByWithAggregationInput | FoodViryaOrderByWithAggregationInput[]
    by: FoodViryaScalarFieldEnum[] | FoodViryaScalarFieldEnum
    having?: FoodViryaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodViryaCountAggregateInputType | true
    _min?: FoodViryaMinAggregateInputType
    _max?: FoodViryaMaxAggregateInputType
  }

  export type FoodViryaGroupByOutputType = {
    food_id: string
    virya_id: string
    _count: FoodViryaCountAggregateOutputType | null
    _min: FoodViryaMinAggregateOutputType | null
    _max: FoodViryaMaxAggregateOutputType | null
  }

  type GetFoodViryaGroupByPayload<T extends FoodViryaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodViryaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodViryaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodViryaGroupByOutputType[P]>
            : GetScalarType<T[P], FoodViryaGroupByOutputType[P]>
        }
      >
    >


  export type FoodViryaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    virya_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVirya"]>

  export type FoodViryaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    virya_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVirya"]>

  export type FoodViryaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    virya_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVirya"]>

  export type FoodViryaSelectScalar = {
    food_id?: boolean
    virya_id?: boolean
  }

  export type FoodViryaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "virya_id", ExtArgs["result"]["foodVirya"]>
  export type FoodViryaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }
  export type FoodViryaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }
  export type FoodViryaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    virya?: boolean | ViryaDefaultArgs<ExtArgs>
  }

  export type $FoodViryaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodVirya"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      virya: Prisma.$ViryaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      virya_id: string
    }, ExtArgs["result"]["foodVirya"]>
    composites: {}
  }

  type FoodViryaGetPayload<S extends boolean | null | undefined | FoodViryaDefaultArgs> = $Result.GetResult<Prisma.$FoodViryaPayload, S>

  type FoodViryaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodViryaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodViryaCountAggregateInputType | true
    }

  export interface FoodViryaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodVirya'], meta: { name: 'FoodVirya' } }
    /**
     * Find zero or one FoodVirya that matches the filter.
     * @param {FoodViryaFindUniqueArgs} args - Arguments to find a FoodVirya
     * @example
     * // Get one FoodVirya
     * const foodVirya = await prisma.foodVirya.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodViryaFindUniqueArgs>(args: SelectSubset<T, FoodViryaFindUniqueArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodVirya that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodViryaFindUniqueOrThrowArgs} args - Arguments to find a FoodVirya
     * @example
     * // Get one FoodVirya
     * const foodVirya = await prisma.foodVirya.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodViryaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodViryaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodVirya that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaFindFirstArgs} args - Arguments to find a FoodVirya
     * @example
     * // Get one FoodVirya
     * const foodVirya = await prisma.foodVirya.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodViryaFindFirstArgs>(args?: SelectSubset<T, FoodViryaFindFirstArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodVirya that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaFindFirstOrThrowArgs} args - Arguments to find a FoodVirya
     * @example
     * // Get one FoodVirya
     * const foodVirya = await prisma.foodVirya.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodViryaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodViryaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodViryas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodViryas
     * const foodViryas = await prisma.foodVirya.findMany()
     * 
     * // Get first 10 FoodViryas
     * const foodViryas = await prisma.foodVirya.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodViryaWithFood_idOnly = await prisma.foodVirya.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodViryaFindManyArgs>(args?: SelectSubset<T, FoodViryaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodVirya.
     * @param {FoodViryaCreateArgs} args - Arguments to create a FoodVirya.
     * @example
     * // Create one FoodVirya
     * const FoodVirya = await prisma.foodVirya.create({
     *   data: {
     *     // ... data to create a FoodVirya
     *   }
     * })
     * 
     */
    create<T extends FoodViryaCreateArgs>(args: SelectSubset<T, FoodViryaCreateArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodViryas.
     * @param {FoodViryaCreateManyArgs} args - Arguments to create many FoodViryas.
     * @example
     * // Create many FoodViryas
     * const foodVirya = await prisma.foodVirya.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodViryaCreateManyArgs>(args?: SelectSubset<T, FoodViryaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodViryas and returns the data saved in the database.
     * @param {FoodViryaCreateManyAndReturnArgs} args - Arguments to create many FoodViryas.
     * @example
     * // Create many FoodViryas
     * const foodVirya = await prisma.foodVirya.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodViryas and only return the `food_id`
     * const foodViryaWithFood_idOnly = await prisma.foodVirya.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodViryaCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodViryaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodVirya.
     * @param {FoodViryaDeleteArgs} args - Arguments to delete one FoodVirya.
     * @example
     * // Delete one FoodVirya
     * const FoodVirya = await prisma.foodVirya.delete({
     *   where: {
     *     // ... filter to delete one FoodVirya
     *   }
     * })
     * 
     */
    delete<T extends FoodViryaDeleteArgs>(args: SelectSubset<T, FoodViryaDeleteArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodVirya.
     * @param {FoodViryaUpdateArgs} args - Arguments to update one FoodVirya.
     * @example
     * // Update one FoodVirya
     * const foodVirya = await prisma.foodVirya.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodViryaUpdateArgs>(args: SelectSubset<T, FoodViryaUpdateArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodViryas.
     * @param {FoodViryaDeleteManyArgs} args - Arguments to filter FoodViryas to delete.
     * @example
     * // Delete a few FoodViryas
     * const { count } = await prisma.foodVirya.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodViryaDeleteManyArgs>(args?: SelectSubset<T, FoodViryaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodViryas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodViryas
     * const foodVirya = await prisma.foodVirya.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodViryaUpdateManyArgs>(args: SelectSubset<T, FoodViryaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodViryas and returns the data updated in the database.
     * @param {FoodViryaUpdateManyAndReturnArgs} args - Arguments to update many FoodViryas.
     * @example
     * // Update many FoodViryas
     * const foodVirya = await prisma.foodVirya.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodViryas and only return the `food_id`
     * const foodViryaWithFood_idOnly = await prisma.foodVirya.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodViryaUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodViryaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodVirya.
     * @param {FoodViryaUpsertArgs} args - Arguments to update or create a FoodVirya.
     * @example
     * // Update or create a FoodVirya
     * const foodVirya = await prisma.foodVirya.upsert({
     *   create: {
     *     // ... data to create a FoodVirya
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodVirya we want to update
     *   }
     * })
     */
    upsert<T extends FoodViryaUpsertArgs>(args: SelectSubset<T, FoodViryaUpsertArgs<ExtArgs>>): Prisma__FoodViryaClient<$Result.GetResult<Prisma.$FoodViryaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodViryas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaCountArgs} args - Arguments to filter FoodViryas to count.
     * @example
     * // Count the number of FoodViryas
     * const count = await prisma.foodVirya.count({
     *   where: {
     *     // ... the filter for the FoodViryas we want to count
     *   }
     * })
    **/
    count<T extends FoodViryaCountArgs>(
      args?: Subset<T, FoodViryaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodViryaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodVirya.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodViryaAggregateArgs>(args: Subset<T, FoodViryaAggregateArgs>): Prisma.PrismaPromise<GetFoodViryaAggregateType<T>>

    /**
     * Group by FoodVirya.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodViryaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodViryaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodViryaGroupByArgs['orderBy'] }
        : { orderBy?: FoodViryaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodViryaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodViryaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodVirya model
   */
  readonly fields: FoodViryaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodVirya.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodViryaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    virya<T extends ViryaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViryaDefaultArgs<ExtArgs>>): Prisma__ViryaClient<$Result.GetResult<Prisma.$ViryaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodVirya model
   */
  interface FoodViryaFieldRefs {
    readonly food_id: FieldRef<"FoodVirya", 'String'>
    readonly virya_id: FieldRef<"FoodVirya", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodVirya findUnique
   */
  export type FoodViryaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVirya to fetch.
     */
    where: FoodViryaWhereUniqueInput
  }

  /**
   * FoodVirya findUniqueOrThrow
   */
  export type FoodViryaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVirya to fetch.
     */
    where: FoodViryaWhereUniqueInput
  }

  /**
   * FoodVirya findFirst
   */
  export type FoodViryaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVirya to fetch.
     */
    where?: FoodViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodViryas to fetch.
     */
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodViryas.
     */
    cursor?: FoodViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodViryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodViryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodViryas.
     */
    distinct?: FoodViryaScalarFieldEnum | FoodViryaScalarFieldEnum[]
  }

  /**
   * FoodVirya findFirstOrThrow
   */
  export type FoodViryaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVirya to fetch.
     */
    where?: FoodViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodViryas to fetch.
     */
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodViryas.
     */
    cursor?: FoodViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodViryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodViryas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodViryas.
     */
    distinct?: FoodViryaScalarFieldEnum | FoodViryaScalarFieldEnum[]
  }

  /**
   * FoodVirya findMany
   */
  export type FoodViryaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter, which FoodViryas to fetch.
     */
    where?: FoodViryaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodViryas to fetch.
     */
    orderBy?: FoodViryaOrderByWithRelationInput | FoodViryaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodViryas.
     */
    cursor?: FoodViryaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodViryas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodViryas.
     */
    skip?: number
    distinct?: FoodViryaScalarFieldEnum | FoodViryaScalarFieldEnum[]
  }

  /**
   * FoodVirya create
   */
  export type FoodViryaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodVirya.
     */
    data: XOR<FoodViryaCreateInput, FoodViryaUncheckedCreateInput>
  }

  /**
   * FoodVirya createMany
   */
  export type FoodViryaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodViryas.
     */
    data: FoodViryaCreateManyInput | FoodViryaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodVirya createManyAndReturn
   */
  export type FoodViryaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * The data used to create many FoodViryas.
     */
    data: FoodViryaCreateManyInput | FoodViryaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodVirya update
   */
  export type FoodViryaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodVirya.
     */
    data: XOR<FoodViryaUpdateInput, FoodViryaUncheckedUpdateInput>
    /**
     * Choose, which FoodVirya to update.
     */
    where: FoodViryaWhereUniqueInput
  }

  /**
   * FoodVirya updateMany
   */
  export type FoodViryaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodViryas.
     */
    data: XOR<FoodViryaUpdateManyMutationInput, FoodViryaUncheckedUpdateManyInput>
    /**
     * Filter which FoodViryas to update
     */
    where?: FoodViryaWhereInput
    /**
     * Limit how many FoodViryas to update.
     */
    limit?: number
  }

  /**
   * FoodVirya updateManyAndReturn
   */
  export type FoodViryaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * The data used to update FoodViryas.
     */
    data: XOR<FoodViryaUpdateManyMutationInput, FoodViryaUncheckedUpdateManyInput>
    /**
     * Filter which FoodViryas to update
     */
    where?: FoodViryaWhereInput
    /**
     * Limit how many FoodViryas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodVirya upsert
   */
  export type FoodViryaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodVirya to update in case it exists.
     */
    where: FoodViryaWhereUniqueInput
    /**
     * In case the FoodVirya found by the `where` argument doesn't exist, create a new FoodVirya with this data.
     */
    create: XOR<FoodViryaCreateInput, FoodViryaUncheckedCreateInput>
    /**
     * In case the FoodVirya was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodViryaUpdateInput, FoodViryaUncheckedUpdateInput>
  }

  /**
   * FoodVirya delete
   */
  export type FoodViryaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
    /**
     * Filter which FoodVirya to delete.
     */
    where: FoodViryaWhereUniqueInput
  }

  /**
   * FoodVirya deleteMany
   */
  export type FoodViryaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodViryas to delete
     */
    where?: FoodViryaWhereInput
    /**
     * Limit how many FoodViryas to delete.
     */
    limit?: number
  }

  /**
   * FoodVirya without action
   */
  export type FoodViryaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVirya
     */
    select?: FoodViryaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVirya
     */
    omit?: FoodViryaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodViryaInclude<ExtArgs> | null
  }


  /**
   * Model FoodVipaka
   */

  export type AggregateFoodVipaka = {
    _count: FoodVipakaCountAggregateOutputType | null
    _min: FoodVipakaMinAggregateOutputType | null
    _max: FoodVipakaMaxAggregateOutputType | null
  }

  export type FoodVipakaMinAggregateOutputType = {
    food_id: string | null
    vipaka_id: string | null
  }

  export type FoodVipakaMaxAggregateOutputType = {
    food_id: string | null
    vipaka_id: string | null
  }

  export type FoodVipakaCountAggregateOutputType = {
    food_id: number
    vipaka_id: number
    _all: number
  }


  export type FoodVipakaMinAggregateInputType = {
    food_id?: true
    vipaka_id?: true
  }

  export type FoodVipakaMaxAggregateInputType = {
    food_id?: true
    vipaka_id?: true
  }

  export type FoodVipakaCountAggregateInputType = {
    food_id?: true
    vipaka_id?: true
    _all?: true
  }

  export type FoodVipakaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodVipaka to aggregate.
     */
    where?: FoodVipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodVipakas to fetch.
     */
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodVipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodVipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodVipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodVipakas
    **/
    _count?: true | FoodVipakaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodVipakaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodVipakaMaxAggregateInputType
  }

  export type GetFoodVipakaAggregateType<T extends FoodVipakaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodVipaka]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodVipaka[P]>
      : GetScalarType<T[P], AggregateFoodVipaka[P]>
  }




  export type FoodVipakaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodVipakaWhereInput
    orderBy?: FoodVipakaOrderByWithAggregationInput | FoodVipakaOrderByWithAggregationInput[]
    by: FoodVipakaScalarFieldEnum[] | FoodVipakaScalarFieldEnum
    having?: FoodVipakaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodVipakaCountAggregateInputType | true
    _min?: FoodVipakaMinAggregateInputType
    _max?: FoodVipakaMaxAggregateInputType
  }

  export type FoodVipakaGroupByOutputType = {
    food_id: string
    vipaka_id: string
    _count: FoodVipakaCountAggregateOutputType | null
    _min: FoodVipakaMinAggregateOutputType | null
    _max: FoodVipakaMaxAggregateOutputType | null
  }

  type GetFoodVipakaGroupByPayload<T extends FoodVipakaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodVipakaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodVipakaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodVipakaGroupByOutputType[P]>
            : GetScalarType<T[P], FoodVipakaGroupByOutputType[P]>
        }
      >
    >


  export type FoodVipakaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    vipaka_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVipaka"]>

  export type FoodVipakaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    vipaka_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVipaka"]>

  export type FoodVipakaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    vipaka_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodVipaka"]>

  export type FoodVipakaSelectScalar = {
    food_id?: boolean
    vipaka_id?: boolean
  }

  export type FoodVipakaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "vipaka_id", ExtArgs["result"]["foodVipaka"]>
  export type FoodVipakaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }
  export type FoodVipakaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }
  export type FoodVipakaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    vipaka?: boolean | VipakaDefaultArgs<ExtArgs>
  }

  export type $FoodVipakaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodVipaka"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      vipaka: Prisma.$VipakaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      vipaka_id: string
    }, ExtArgs["result"]["foodVipaka"]>
    composites: {}
  }

  type FoodVipakaGetPayload<S extends boolean | null | undefined | FoodVipakaDefaultArgs> = $Result.GetResult<Prisma.$FoodVipakaPayload, S>

  type FoodVipakaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodVipakaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodVipakaCountAggregateInputType | true
    }

  export interface FoodVipakaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodVipaka'], meta: { name: 'FoodVipaka' } }
    /**
     * Find zero or one FoodVipaka that matches the filter.
     * @param {FoodVipakaFindUniqueArgs} args - Arguments to find a FoodVipaka
     * @example
     * // Get one FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodVipakaFindUniqueArgs>(args: SelectSubset<T, FoodVipakaFindUniqueArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodVipaka that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodVipakaFindUniqueOrThrowArgs} args - Arguments to find a FoodVipaka
     * @example
     * // Get one FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodVipakaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodVipakaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodVipaka that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaFindFirstArgs} args - Arguments to find a FoodVipaka
     * @example
     * // Get one FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodVipakaFindFirstArgs>(args?: SelectSubset<T, FoodVipakaFindFirstArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodVipaka that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaFindFirstOrThrowArgs} args - Arguments to find a FoodVipaka
     * @example
     * // Get one FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodVipakaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodVipakaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodVipakas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodVipakas
     * const foodVipakas = await prisma.foodVipaka.findMany()
     * 
     * // Get first 10 FoodVipakas
     * const foodVipakas = await prisma.foodVipaka.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodVipakaWithFood_idOnly = await prisma.foodVipaka.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodVipakaFindManyArgs>(args?: SelectSubset<T, FoodVipakaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodVipaka.
     * @param {FoodVipakaCreateArgs} args - Arguments to create a FoodVipaka.
     * @example
     * // Create one FoodVipaka
     * const FoodVipaka = await prisma.foodVipaka.create({
     *   data: {
     *     // ... data to create a FoodVipaka
     *   }
     * })
     * 
     */
    create<T extends FoodVipakaCreateArgs>(args: SelectSubset<T, FoodVipakaCreateArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodVipakas.
     * @param {FoodVipakaCreateManyArgs} args - Arguments to create many FoodVipakas.
     * @example
     * // Create many FoodVipakas
     * const foodVipaka = await prisma.foodVipaka.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodVipakaCreateManyArgs>(args?: SelectSubset<T, FoodVipakaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodVipakas and returns the data saved in the database.
     * @param {FoodVipakaCreateManyAndReturnArgs} args - Arguments to create many FoodVipakas.
     * @example
     * // Create many FoodVipakas
     * const foodVipaka = await prisma.foodVipaka.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodVipakas and only return the `food_id`
     * const foodVipakaWithFood_idOnly = await prisma.foodVipaka.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodVipakaCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodVipakaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodVipaka.
     * @param {FoodVipakaDeleteArgs} args - Arguments to delete one FoodVipaka.
     * @example
     * // Delete one FoodVipaka
     * const FoodVipaka = await prisma.foodVipaka.delete({
     *   where: {
     *     // ... filter to delete one FoodVipaka
     *   }
     * })
     * 
     */
    delete<T extends FoodVipakaDeleteArgs>(args: SelectSubset<T, FoodVipakaDeleteArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodVipaka.
     * @param {FoodVipakaUpdateArgs} args - Arguments to update one FoodVipaka.
     * @example
     * // Update one FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodVipakaUpdateArgs>(args: SelectSubset<T, FoodVipakaUpdateArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodVipakas.
     * @param {FoodVipakaDeleteManyArgs} args - Arguments to filter FoodVipakas to delete.
     * @example
     * // Delete a few FoodVipakas
     * const { count } = await prisma.foodVipaka.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodVipakaDeleteManyArgs>(args?: SelectSubset<T, FoodVipakaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodVipakas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodVipakas
     * const foodVipaka = await prisma.foodVipaka.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodVipakaUpdateManyArgs>(args: SelectSubset<T, FoodVipakaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodVipakas and returns the data updated in the database.
     * @param {FoodVipakaUpdateManyAndReturnArgs} args - Arguments to update many FoodVipakas.
     * @example
     * // Update many FoodVipakas
     * const foodVipaka = await prisma.foodVipaka.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodVipakas and only return the `food_id`
     * const foodVipakaWithFood_idOnly = await prisma.foodVipaka.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodVipakaUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodVipakaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodVipaka.
     * @param {FoodVipakaUpsertArgs} args - Arguments to update or create a FoodVipaka.
     * @example
     * // Update or create a FoodVipaka
     * const foodVipaka = await prisma.foodVipaka.upsert({
     *   create: {
     *     // ... data to create a FoodVipaka
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodVipaka we want to update
     *   }
     * })
     */
    upsert<T extends FoodVipakaUpsertArgs>(args: SelectSubset<T, FoodVipakaUpsertArgs<ExtArgs>>): Prisma__FoodVipakaClient<$Result.GetResult<Prisma.$FoodVipakaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodVipakas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaCountArgs} args - Arguments to filter FoodVipakas to count.
     * @example
     * // Count the number of FoodVipakas
     * const count = await prisma.foodVipaka.count({
     *   where: {
     *     // ... the filter for the FoodVipakas we want to count
     *   }
     * })
    **/
    count<T extends FoodVipakaCountArgs>(
      args?: Subset<T, FoodVipakaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodVipakaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodVipaka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodVipakaAggregateArgs>(args: Subset<T, FoodVipakaAggregateArgs>): Prisma.PrismaPromise<GetFoodVipakaAggregateType<T>>

    /**
     * Group by FoodVipaka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodVipakaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodVipakaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodVipakaGroupByArgs['orderBy'] }
        : { orderBy?: FoodVipakaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodVipakaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodVipakaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodVipaka model
   */
  readonly fields: FoodVipakaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodVipaka.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodVipakaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vipaka<T extends VipakaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VipakaDefaultArgs<ExtArgs>>): Prisma__VipakaClient<$Result.GetResult<Prisma.$VipakaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodVipaka model
   */
  interface FoodVipakaFieldRefs {
    readonly food_id: FieldRef<"FoodVipaka", 'String'>
    readonly vipaka_id: FieldRef<"FoodVipaka", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodVipaka findUnique
   */
  export type FoodVipakaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVipaka to fetch.
     */
    where: FoodVipakaWhereUniqueInput
  }

  /**
   * FoodVipaka findUniqueOrThrow
   */
  export type FoodVipakaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVipaka to fetch.
     */
    where: FoodVipakaWhereUniqueInput
  }

  /**
   * FoodVipaka findFirst
   */
  export type FoodVipakaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVipaka to fetch.
     */
    where?: FoodVipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodVipakas to fetch.
     */
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodVipakas.
     */
    cursor?: FoodVipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodVipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodVipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodVipakas.
     */
    distinct?: FoodVipakaScalarFieldEnum | FoodVipakaScalarFieldEnum[]
  }

  /**
   * FoodVipaka findFirstOrThrow
   */
  export type FoodVipakaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVipaka to fetch.
     */
    where?: FoodVipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodVipakas to fetch.
     */
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodVipakas.
     */
    cursor?: FoodVipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodVipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodVipakas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodVipakas.
     */
    distinct?: FoodVipakaScalarFieldEnum | FoodVipakaScalarFieldEnum[]
  }

  /**
   * FoodVipaka findMany
   */
  export type FoodVipakaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter, which FoodVipakas to fetch.
     */
    where?: FoodVipakaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodVipakas to fetch.
     */
    orderBy?: FoodVipakaOrderByWithRelationInput | FoodVipakaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodVipakas.
     */
    cursor?: FoodVipakaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodVipakas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodVipakas.
     */
    skip?: number
    distinct?: FoodVipakaScalarFieldEnum | FoodVipakaScalarFieldEnum[]
  }

  /**
   * FoodVipaka create
   */
  export type FoodVipakaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodVipaka.
     */
    data: XOR<FoodVipakaCreateInput, FoodVipakaUncheckedCreateInput>
  }

  /**
   * FoodVipaka createMany
   */
  export type FoodVipakaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodVipakas.
     */
    data: FoodVipakaCreateManyInput | FoodVipakaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodVipaka createManyAndReturn
   */
  export type FoodVipakaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * The data used to create many FoodVipakas.
     */
    data: FoodVipakaCreateManyInput | FoodVipakaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodVipaka update
   */
  export type FoodVipakaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodVipaka.
     */
    data: XOR<FoodVipakaUpdateInput, FoodVipakaUncheckedUpdateInput>
    /**
     * Choose, which FoodVipaka to update.
     */
    where: FoodVipakaWhereUniqueInput
  }

  /**
   * FoodVipaka updateMany
   */
  export type FoodVipakaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodVipakas.
     */
    data: XOR<FoodVipakaUpdateManyMutationInput, FoodVipakaUncheckedUpdateManyInput>
    /**
     * Filter which FoodVipakas to update
     */
    where?: FoodVipakaWhereInput
    /**
     * Limit how many FoodVipakas to update.
     */
    limit?: number
  }

  /**
   * FoodVipaka updateManyAndReturn
   */
  export type FoodVipakaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * The data used to update FoodVipakas.
     */
    data: XOR<FoodVipakaUpdateManyMutationInput, FoodVipakaUncheckedUpdateManyInput>
    /**
     * Filter which FoodVipakas to update
     */
    where?: FoodVipakaWhereInput
    /**
     * Limit how many FoodVipakas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodVipaka upsert
   */
  export type FoodVipakaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodVipaka to update in case it exists.
     */
    where: FoodVipakaWhereUniqueInput
    /**
     * In case the FoodVipaka found by the `where` argument doesn't exist, create a new FoodVipaka with this data.
     */
    create: XOR<FoodVipakaCreateInput, FoodVipakaUncheckedCreateInput>
    /**
     * In case the FoodVipaka was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodVipakaUpdateInput, FoodVipakaUncheckedUpdateInput>
  }

  /**
   * FoodVipaka delete
   */
  export type FoodVipakaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
    /**
     * Filter which FoodVipaka to delete.
     */
    where: FoodVipakaWhereUniqueInput
  }

  /**
   * FoodVipaka deleteMany
   */
  export type FoodVipakaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodVipakas to delete
     */
    where?: FoodVipakaWhereInput
    /**
     * Limit how many FoodVipakas to delete.
     */
    limit?: number
  }

  /**
   * FoodVipaka without action
   */
  export type FoodVipakaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodVipaka
     */
    select?: FoodVipakaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodVipaka
     */
    omit?: FoodVipakaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodVipakaInclude<ExtArgs> | null
  }


  /**
   * Model FoodDigestibility
   */

  export type AggregateFoodDigestibility = {
    _count: FoodDigestibilityCountAggregateOutputType | null
    _min: FoodDigestibilityMinAggregateOutputType | null
    _max: FoodDigestibilityMaxAggregateOutputType | null
  }

  export type FoodDigestibilityMinAggregateOutputType = {
    food_id: string | null
    digestibility_id: string | null
  }

  export type FoodDigestibilityMaxAggregateOutputType = {
    food_id: string | null
    digestibility_id: string | null
  }

  export type FoodDigestibilityCountAggregateOutputType = {
    food_id: number
    digestibility_id: number
    _all: number
  }


  export type FoodDigestibilityMinAggregateInputType = {
    food_id?: true
    digestibility_id?: true
  }

  export type FoodDigestibilityMaxAggregateInputType = {
    food_id?: true
    digestibility_id?: true
  }

  export type FoodDigestibilityCountAggregateInputType = {
    food_id?: true
    digestibility_id?: true
    _all?: true
  }

  export type FoodDigestibilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodDigestibility to aggregate.
     */
    where?: FoodDigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDigestibilities to fetch.
     */
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodDigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDigestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDigestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodDigestibilities
    **/
    _count?: true | FoodDigestibilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodDigestibilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodDigestibilityMaxAggregateInputType
  }

  export type GetFoodDigestibilityAggregateType<T extends FoodDigestibilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodDigestibility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodDigestibility[P]>
      : GetScalarType<T[P], AggregateFoodDigestibility[P]>
  }




  export type FoodDigestibilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodDigestibilityWhereInput
    orderBy?: FoodDigestibilityOrderByWithAggregationInput | FoodDigestibilityOrderByWithAggregationInput[]
    by: FoodDigestibilityScalarFieldEnum[] | FoodDigestibilityScalarFieldEnum
    having?: FoodDigestibilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodDigestibilityCountAggregateInputType | true
    _min?: FoodDigestibilityMinAggregateInputType
    _max?: FoodDigestibilityMaxAggregateInputType
  }

  export type FoodDigestibilityGroupByOutputType = {
    food_id: string
    digestibility_id: string
    _count: FoodDigestibilityCountAggregateOutputType | null
    _min: FoodDigestibilityMinAggregateOutputType | null
    _max: FoodDigestibilityMaxAggregateOutputType | null
  }

  type GetFoodDigestibilityGroupByPayload<T extends FoodDigestibilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodDigestibilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodDigestibilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodDigestibilityGroupByOutputType[P]>
            : GetScalarType<T[P], FoodDigestibilityGroupByOutputType[P]>
        }
      >
    >


  export type FoodDigestibilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    digestibility_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDigestibility"]>

  export type FoodDigestibilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    digestibility_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDigestibility"]>

  export type FoodDigestibilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    food_id?: boolean
    digestibility_id?: boolean
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodDigestibility"]>

  export type FoodDigestibilitySelectScalar = {
    food_id?: boolean
    digestibility_id?: boolean
  }

  export type FoodDigestibilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"food_id" | "digestibility_id", ExtArgs["result"]["foodDigestibility"]>
  export type FoodDigestibilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }
  export type FoodDigestibilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }
  export type FoodDigestibilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    food?: boolean | FoodDefaultArgs<ExtArgs>
    digestibility?: boolean | DigestibilityDefaultArgs<ExtArgs>
  }

  export type $FoodDigestibilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodDigestibility"
    objects: {
      food: Prisma.$FoodPayload<ExtArgs>
      digestibility: Prisma.$DigestibilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      food_id: string
      digestibility_id: string
    }, ExtArgs["result"]["foodDigestibility"]>
    composites: {}
  }

  type FoodDigestibilityGetPayload<S extends boolean | null | undefined | FoodDigestibilityDefaultArgs> = $Result.GetResult<Prisma.$FoodDigestibilityPayload, S>

  type FoodDigestibilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodDigestibilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodDigestibilityCountAggregateInputType | true
    }

  export interface FoodDigestibilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodDigestibility'], meta: { name: 'FoodDigestibility' } }
    /**
     * Find zero or one FoodDigestibility that matches the filter.
     * @param {FoodDigestibilityFindUniqueArgs} args - Arguments to find a FoodDigestibility
     * @example
     * // Get one FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodDigestibilityFindUniqueArgs>(args: SelectSubset<T, FoodDigestibilityFindUniqueArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodDigestibility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodDigestibilityFindUniqueOrThrowArgs} args - Arguments to find a FoodDigestibility
     * @example
     * // Get one FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodDigestibilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodDigestibilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodDigestibility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityFindFirstArgs} args - Arguments to find a FoodDigestibility
     * @example
     * // Get one FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodDigestibilityFindFirstArgs>(args?: SelectSubset<T, FoodDigestibilityFindFirstArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodDigestibility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityFindFirstOrThrowArgs} args - Arguments to find a FoodDigestibility
     * @example
     * // Get one FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodDigestibilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodDigestibilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodDigestibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodDigestibilities
     * const foodDigestibilities = await prisma.foodDigestibility.findMany()
     * 
     * // Get first 10 FoodDigestibilities
     * const foodDigestibilities = await prisma.foodDigestibility.findMany({ take: 10 })
     * 
     * // Only select the `food_id`
     * const foodDigestibilityWithFood_idOnly = await prisma.foodDigestibility.findMany({ select: { food_id: true } })
     * 
     */
    findMany<T extends FoodDigestibilityFindManyArgs>(args?: SelectSubset<T, FoodDigestibilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodDigestibility.
     * @param {FoodDigestibilityCreateArgs} args - Arguments to create a FoodDigestibility.
     * @example
     * // Create one FoodDigestibility
     * const FoodDigestibility = await prisma.foodDigestibility.create({
     *   data: {
     *     // ... data to create a FoodDigestibility
     *   }
     * })
     * 
     */
    create<T extends FoodDigestibilityCreateArgs>(args: SelectSubset<T, FoodDigestibilityCreateArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodDigestibilities.
     * @param {FoodDigestibilityCreateManyArgs} args - Arguments to create many FoodDigestibilities.
     * @example
     * // Create many FoodDigestibilities
     * const foodDigestibility = await prisma.foodDigestibility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodDigestibilityCreateManyArgs>(args?: SelectSubset<T, FoodDigestibilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodDigestibilities and returns the data saved in the database.
     * @param {FoodDigestibilityCreateManyAndReturnArgs} args - Arguments to create many FoodDigestibilities.
     * @example
     * // Create many FoodDigestibilities
     * const foodDigestibility = await prisma.foodDigestibility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodDigestibilities and only return the `food_id`
     * const foodDigestibilityWithFood_idOnly = await prisma.foodDigestibility.createManyAndReturn({
     *   select: { food_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodDigestibilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodDigestibilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodDigestibility.
     * @param {FoodDigestibilityDeleteArgs} args - Arguments to delete one FoodDigestibility.
     * @example
     * // Delete one FoodDigestibility
     * const FoodDigestibility = await prisma.foodDigestibility.delete({
     *   where: {
     *     // ... filter to delete one FoodDigestibility
     *   }
     * })
     * 
     */
    delete<T extends FoodDigestibilityDeleteArgs>(args: SelectSubset<T, FoodDigestibilityDeleteArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodDigestibility.
     * @param {FoodDigestibilityUpdateArgs} args - Arguments to update one FoodDigestibility.
     * @example
     * // Update one FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodDigestibilityUpdateArgs>(args: SelectSubset<T, FoodDigestibilityUpdateArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodDigestibilities.
     * @param {FoodDigestibilityDeleteManyArgs} args - Arguments to filter FoodDigestibilities to delete.
     * @example
     * // Delete a few FoodDigestibilities
     * const { count } = await prisma.foodDigestibility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDigestibilityDeleteManyArgs>(args?: SelectSubset<T, FoodDigestibilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodDigestibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodDigestibilities
     * const foodDigestibility = await prisma.foodDigestibility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodDigestibilityUpdateManyArgs>(args: SelectSubset<T, FoodDigestibilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodDigestibilities and returns the data updated in the database.
     * @param {FoodDigestibilityUpdateManyAndReturnArgs} args - Arguments to update many FoodDigestibilities.
     * @example
     * // Update many FoodDigestibilities
     * const foodDigestibility = await prisma.foodDigestibility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodDigestibilities and only return the `food_id`
     * const foodDigestibilityWithFood_idOnly = await prisma.foodDigestibility.updateManyAndReturn({
     *   select: { food_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodDigestibilityUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodDigestibilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodDigestibility.
     * @param {FoodDigestibilityUpsertArgs} args - Arguments to update or create a FoodDigestibility.
     * @example
     * // Update or create a FoodDigestibility
     * const foodDigestibility = await prisma.foodDigestibility.upsert({
     *   create: {
     *     // ... data to create a FoodDigestibility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodDigestibility we want to update
     *   }
     * })
     */
    upsert<T extends FoodDigestibilityUpsertArgs>(args: SelectSubset<T, FoodDigestibilityUpsertArgs<ExtArgs>>): Prisma__FoodDigestibilityClient<$Result.GetResult<Prisma.$FoodDigestibilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodDigestibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityCountArgs} args - Arguments to filter FoodDigestibilities to count.
     * @example
     * // Count the number of FoodDigestibilities
     * const count = await prisma.foodDigestibility.count({
     *   where: {
     *     // ... the filter for the FoodDigestibilities we want to count
     *   }
     * })
    **/
    count<T extends FoodDigestibilityCountArgs>(
      args?: Subset<T, FoodDigestibilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodDigestibilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodDigestibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodDigestibilityAggregateArgs>(args: Subset<T, FoodDigestibilityAggregateArgs>): Prisma.PrismaPromise<GetFoodDigestibilityAggregateType<T>>

    /**
     * Group by FoodDigestibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodDigestibilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodDigestibilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodDigestibilityGroupByArgs['orderBy'] }
        : { orderBy?: FoodDigestibilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodDigestibilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodDigestibilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodDigestibility model
   */
  readonly fields: FoodDigestibilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodDigestibility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodDigestibilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    digestibility<T extends DigestibilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DigestibilityDefaultArgs<ExtArgs>>): Prisma__DigestibilityClient<$Result.GetResult<Prisma.$DigestibilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodDigestibility model
   */
  interface FoodDigestibilityFieldRefs {
    readonly food_id: FieldRef<"FoodDigestibility", 'String'>
    readonly digestibility_id: FieldRef<"FoodDigestibility", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodDigestibility findUnique
   */
  export type FoodDigestibilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which FoodDigestibility to fetch.
     */
    where: FoodDigestibilityWhereUniqueInput
  }

  /**
   * FoodDigestibility findUniqueOrThrow
   */
  export type FoodDigestibilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which FoodDigestibility to fetch.
     */
    where: FoodDigestibilityWhereUniqueInput
  }

  /**
   * FoodDigestibility findFirst
   */
  export type FoodDigestibilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which FoodDigestibility to fetch.
     */
    where?: FoodDigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDigestibilities to fetch.
     */
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodDigestibilities.
     */
    cursor?: FoodDigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDigestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDigestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodDigestibilities.
     */
    distinct?: FoodDigestibilityScalarFieldEnum | FoodDigestibilityScalarFieldEnum[]
  }

  /**
   * FoodDigestibility findFirstOrThrow
   */
  export type FoodDigestibilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which FoodDigestibility to fetch.
     */
    where?: FoodDigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDigestibilities to fetch.
     */
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodDigestibilities.
     */
    cursor?: FoodDigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDigestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDigestibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodDigestibilities.
     */
    distinct?: FoodDigestibilityScalarFieldEnum | FoodDigestibilityScalarFieldEnum[]
  }

  /**
   * FoodDigestibility findMany
   */
  export type FoodDigestibilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter, which FoodDigestibilities to fetch.
     */
    where?: FoodDigestibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodDigestibilities to fetch.
     */
    orderBy?: FoodDigestibilityOrderByWithRelationInput | FoodDigestibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodDigestibilities.
     */
    cursor?: FoodDigestibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodDigestibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodDigestibilities.
     */
    skip?: number
    distinct?: FoodDigestibilityScalarFieldEnum | FoodDigestibilityScalarFieldEnum[]
  }

  /**
   * FoodDigestibility create
   */
  export type FoodDigestibilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodDigestibility.
     */
    data: XOR<FoodDigestibilityCreateInput, FoodDigestibilityUncheckedCreateInput>
  }

  /**
   * FoodDigestibility createMany
   */
  export type FoodDigestibilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodDigestibilities.
     */
    data: FoodDigestibilityCreateManyInput | FoodDigestibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodDigestibility createManyAndReturn
   */
  export type FoodDigestibilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * The data used to create many FoodDigestibilities.
     */
    data: FoodDigestibilityCreateManyInput | FoodDigestibilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodDigestibility update
   */
  export type FoodDigestibilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodDigestibility.
     */
    data: XOR<FoodDigestibilityUpdateInput, FoodDigestibilityUncheckedUpdateInput>
    /**
     * Choose, which FoodDigestibility to update.
     */
    where: FoodDigestibilityWhereUniqueInput
  }

  /**
   * FoodDigestibility updateMany
   */
  export type FoodDigestibilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodDigestibilities.
     */
    data: XOR<FoodDigestibilityUpdateManyMutationInput, FoodDigestibilityUncheckedUpdateManyInput>
    /**
     * Filter which FoodDigestibilities to update
     */
    where?: FoodDigestibilityWhereInput
    /**
     * Limit how many FoodDigestibilities to update.
     */
    limit?: number
  }

  /**
   * FoodDigestibility updateManyAndReturn
   */
  export type FoodDigestibilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * The data used to update FoodDigestibilities.
     */
    data: XOR<FoodDigestibilityUpdateManyMutationInput, FoodDigestibilityUncheckedUpdateManyInput>
    /**
     * Filter which FoodDigestibilities to update
     */
    where?: FoodDigestibilityWhereInput
    /**
     * Limit how many FoodDigestibilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodDigestibility upsert
   */
  export type FoodDigestibilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodDigestibility to update in case it exists.
     */
    where: FoodDigestibilityWhereUniqueInput
    /**
     * In case the FoodDigestibility found by the `where` argument doesn't exist, create a new FoodDigestibility with this data.
     */
    create: XOR<FoodDigestibilityCreateInput, FoodDigestibilityUncheckedCreateInput>
    /**
     * In case the FoodDigestibility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodDigestibilityUpdateInput, FoodDigestibilityUncheckedUpdateInput>
  }

  /**
   * FoodDigestibility delete
   */
  export type FoodDigestibilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
    /**
     * Filter which FoodDigestibility to delete.
     */
    where: FoodDigestibilityWhereUniqueInput
  }

  /**
   * FoodDigestibility deleteMany
   */
  export type FoodDigestibilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodDigestibilities to delete
     */
    where?: FoodDigestibilityWhereInput
    /**
     * Limit how many FoodDigestibilities to delete.
     */
    limit?: number
  }

  /**
   * FoodDigestibility without action
   */
  export type FoodDigestibilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodDigestibility
     */
    select?: FoodDigestibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodDigestibility
     */
    omit?: FoodDigestibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodDigestibilityInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeMinAggregateOutputType = {
    recipe_id: string | null
    name: string | null
    cuisine_id: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    recipe_id: string | null
    name: string | null
    cuisine_id: string | null
  }

  export type RecipeCountAggregateOutputType = {
    recipe_id: number
    name: number
    cuisine_id: number
    _all: number
  }


  export type RecipeMinAggregateInputType = {
    recipe_id?: true
    name?: true
    cuisine_id?: true
  }

  export type RecipeMaxAggregateInputType = {
    recipe_id?: true
    name?: true
    cuisine_id?: true
  }

  export type RecipeCountAggregateInputType = {
    recipe_id?: true
    name?: true
    cuisine_id?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    recipe_id: string
    name: string
    cuisine_id: string
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    name?: boolean
    cuisine_id?: boolean
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
    RecipeIngredient?: boolean | Recipe$RecipeIngredientArgs<ExtArgs>
    DietChartRecipe?: boolean | Recipe$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    name?: boolean
    cuisine_id?: boolean
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    name?: boolean
    cuisine_id?: boolean
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    recipe_id?: boolean
    name?: boolean
    cuisine_id?: boolean
  }

  export type RecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recipe_id" | "name" | "cuisine_id", ExtArgs["result"]["recipe"]>
  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
    RecipeIngredient?: boolean | Recipe$RecipeIngredientArgs<ExtArgs>
    DietChartRecipe?: boolean | Recipe$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cuisine?: boolean | CuisineDefaultArgs<ExtArgs>
  }

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      Cuisine: Prisma.$CuisinePayload<ExtArgs>
      RecipeIngredient: Prisma.$RecipeIngredientPayload<ExtArgs>[]
      DietChartRecipe: Prisma.$DietChartRecipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      recipe_id: string
      name: string
      cuisine_id: string
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `recipe_id`
     * const recipeWithRecipe_idOnly = await prisma.recipe.findMany({ select: { recipe_id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `recipe_id`
     * const recipeWithRecipe_idOnly = await prisma.recipe.createManyAndReturn({
     *   select: { recipe_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes and returns the data updated in the database.
     * @param {RecipeUpdateManyAndReturnArgs} args - Arguments to update many Recipes.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recipes and only return the `recipe_id`
     * const recipeWithRecipe_idOnly = await prisma.recipe.updateManyAndReturn({
     *   select: { recipe_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cuisine<T extends CuisineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuisineDefaultArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RecipeIngredient<T extends Recipe$RecipeIngredientArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$RecipeIngredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DietChartRecipe<T extends Recipe$DietChartRecipeArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$DietChartRecipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */
  interface RecipeFieldRefs {
    readonly recipe_id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly cuisine_id: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe updateManyAndReturn
   */
  export type RecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to delete.
     */
    limit?: number
  }

  /**
   * Recipe.RecipeIngredient
   */
  export type Recipe$RecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * Recipe.DietChartRecipe
   */
  export type Recipe$DietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    where?: DietChartRecipeWhereInput
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    cursor?: DietChartRecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeIngredient
   */

  export type AggregateRecipeIngredient = {
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  export type RecipeIngredientAvgAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeIngredientSumAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeIngredientMinAggregateOutputType = {
    recipe_id: string | null
    food_id: string | null
    quantity: number | null
  }

  export type RecipeIngredientMaxAggregateOutputType = {
    recipe_id: string | null
    food_id: string | null
    quantity: number | null
  }

  export type RecipeIngredientCountAggregateOutputType = {
    recipe_id: number
    food_id: number
    quantity: number
    _all: number
  }


  export type RecipeIngredientAvgAggregateInputType = {
    quantity?: true
  }

  export type RecipeIngredientSumAggregateInputType = {
    quantity?: true
  }

  export type RecipeIngredientMinAggregateInputType = {
    recipe_id?: true
    food_id?: true
    quantity?: true
  }

  export type RecipeIngredientMaxAggregateInputType = {
    recipe_id?: true
    food_id?: true
    quantity?: true
  }

  export type RecipeIngredientCountAggregateInputType = {
    recipe_id?: true
    food_id?: true
    quantity?: true
    _all?: true
  }

  export type RecipeIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredient to aggregate.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeIngredients
    **/
    _count?: true | RecipeIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type GetRecipeIngredientAggregateType<T extends RecipeIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeIngredient[P]>
      : GetScalarType<T[P], AggregateRecipeIngredient[P]>
  }




  export type RecipeIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithAggregationInput | RecipeIngredientOrderByWithAggregationInput[]
    by: RecipeIngredientScalarFieldEnum[] | RecipeIngredientScalarFieldEnum
    having?: RecipeIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeIngredientCountAggregateInputType | true
    _avg?: RecipeIngredientAvgAggregateInputType
    _sum?: RecipeIngredientSumAggregateInputType
    _min?: RecipeIngredientMinAggregateInputType
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type RecipeIngredientGroupByOutputType = {
    recipe_id: string
    food_id: string
    quantity: number
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  type GetRecipeIngredientGroupByPayload<T extends RecipeIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
        }
      >
    >


  export type RecipeIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    food_id?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    food_id?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipe_id?: boolean
    food_id?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectScalar = {
    recipe_id?: boolean
    food_id?: boolean
    quantity?: boolean
  }

  export type RecipeIngredientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recipe_id" | "food_id" | "quantity", ExtArgs["result"]["recipeIngredient"]>
  export type RecipeIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }

  export type $RecipeIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeIngredient"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      food: Prisma.$FoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipe_id: string
      food_id: string
      quantity: number
    }, ExtArgs["result"]["recipeIngredient"]>
    composites: {}
  }

  type RecipeIngredientGetPayload<S extends boolean | null | undefined | RecipeIngredientDefaultArgs> = $Result.GetResult<Prisma.$RecipeIngredientPayload, S>

  type RecipeIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeIngredientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeIngredientCountAggregateInputType | true
    }

  export interface RecipeIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeIngredient'], meta: { name: 'RecipeIngredient' } }
    /**
     * Find zero or one RecipeIngredient that matches the filter.
     * @param {RecipeIngredientFindUniqueArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeIngredientFindUniqueArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeIngredient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeIngredientFindUniqueOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeIngredientFindFirstArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany()
     * 
     * // Get first 10 RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany({ take: 10 })
     * 
     * // Only select the `recipe_id`
     * const recipeIngredientWithRecipe_idOnly = await prisma.recipeIngredient.findMany({ select: { recipe_id: true } })
     * 
     */
    findMany<T extends RecipeIngredientFindManyArgs>(args?: SelectSubset<T, RecipeIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeIngredient.
     * @param {RecipeIngredientCreateArgs} args - Arguments to create a RecipeIngredient.
     * @example
     * // Create one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.create({
     *   data: {
     *     // ... data to create a RecipeIngredient
     *   }
     * })
     * 
     */
    create<T extends RecipeIngredientCreateArgs>(args: SelectSubset<T, RecipeIngredientCreateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeIngredients.
     * @param {RecipeIngredientCreateManyArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeIngredientCreateManyArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeIngredients and returns the data saved in the database.
     * @param {RecipeIngredientCreateManyAndReturnArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeIngredients and only return the `recipe_id`
     * const recipeIngredientWithRecipe_idOnly = await prisma.recipeIngredient.createManyAndReturn({
     *   select: { recipe_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeIngredient.
     * @param {RecipeIngredientDeleteArgs} args - Arguments to delete one RecipeIngredient.
     * @example
     * // Delete one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.delete({
     *   where: {
     *     // ... filter to delete one RecipeIngredient
     *   }
     * })
     * 
     */
    delete<T extends RecipeIngredientDeleteArgs>(args: SelectSubset<T, RecipeIngredientDeleteArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeIngredient.
     * @param {RecipeIngredientUpdateArgs} args - Arguments to update one RecipeIngredient.
     * @example
     * // Update one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeIngredientUpdateArgs>(args: SelectSubset<T, RecipeIngredientUpdateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeIngredients.
     * @param {RecipeIngredientDeleteManyArgs} args - Arguments to filter RecipeIngredients to delete.
     * @example
     * // Delete a few RecipeIngredients
     * const { count } = await prisma.recipeIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeIngredientDeleteManyArgs>(args?: SelectSubset<T, RecipeIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeIngredientUpdateManyArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients and returns the data updated in the database.
     * @param {RecipeIngredientUpdateManyAndReturnArgs} args - Arguments to update many RecipeIngredients.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeIngredients and only return the `recipe_id`
     * const recipeIngredientWithRecipe_idOnly = await prisma.recipeIngredient.updateManyAndReturn({
     *   select: { recipe_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeIngredientUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeIngredient.
     * @param {RecipeIngredientUpsertArgs} args - Arguments to update or create a RecipeIngredient.
     * @example
     * // Update or create a RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.upsert({
     *   create: {
     *     // ... data to create a RecipeIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeIngredient we want to update
     *   }
     * })
     */
    upsert<T extends RecipeIngredientUpsertArgs>(args: SelectSubset<T, RecipeIngredientUpsertArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientCountArgs} args - Arguments to filter RecipeIngredients to count.
     * @example
     * // Count the number of RecipeIngredients
     * const count = await prisma.recipeIngredient.count({
     *   where: {
     *     // ... the filter for the RecipeIngredients we want to count
     *   }
     * })
    **/
    count<T extends RecipeIngredientCountArgs>(
      args?: Subset<T, RecipeIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeIngredientAggregateArgs>(args: Subset<T, RecipeIngredientAggregateArgs>): Prisma.PrismaPromise<GetRecipeIngredientAggregateType<T>>

    /**
     * Group by RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeIngredientGroupByArgs['orderBy'] }
        : { orderBy?: RecipeIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeIngredient model
   */
  readonly fields: RecipeIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeIngredient model
   */
  interface RecipeIngredientFieldRefs {
    readonly recipe_id: FieldRef<"RecipeIngredient", 'String'>
    readonly food_id: FieldRef<"RecipeIngredient", 'String'>
    readonly quantity: FieldRef<"RecipeIngredient", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RecipeIngredient findUnique
   */
  export type RecipeIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findUniqueOrThrow
   */
  export type RecipeIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findFirst
   */
  export type RecipeIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findFirstOrThrow
   */
  export type RecipeIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findMany
   */
  export type RecipeIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredients to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient create
   */
  export type RecipeIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeIngredient.
     */
    data: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
  }

  /**
   * RecipeIngredient createMany
   */
  export type RecipeIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeIngredient createManyAndReturn
   */
  export type RecipeIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient update
   */
  export type RecipeIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeIngredient.
     */
    data: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
    /**
     * Choose, which RecipeIngredient to update.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient updateMany
   */
  export type RecipeIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
  }

  /**
   * RecipeIngredient updateManyAndReturn
   */
  export type RecipeIngredientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient upsert
   */
  export type RecipeIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeIngredient to update in case it exists.
     */
    where: RecipeIngredientWhereUniqueInput
    /**
     * In case the RecipeIngredient found by the `where` argument doesn't exist, create a new RecipeIngredient with this data.
     */
    create: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
    /**
     * In case the RecipeIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
  }

  /**
   * RecipeIngredient delete
   */
  export type RecipeIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter which RecipeIngredient to delete.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient deleteMany
   */
  export type RecipeIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredients to delete
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to delete.
     */
    limit?: number
  }

  /**
   * RecipeIngredient without action
   */
  export type RecipeIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
  }


  /**
   * Model DietChart
   */

  export type AggregateDietChart = {
    _count: DietChartCountAggregateOutputType | null
    _min: DietChartMinAggregateOutputType | null
    _max: DietChartMaxAggregateOutputType | null
  }

  export type DietChartMinAggregateOutputType = {
    chart_id: string | null
    name: string | null
    description: string | null
  }

  export type DietChartMaxAggregateOutputType = {
    chart_id: string | null
    name: string | null
    description: string | null
  }

  export type DietChartCountAggregateOutputType = {
    chart_id: number
    name: number
    description: number
    _all: number
  }


  export type DietChartMinAggregateInputType = {
    chart_id?: true
    name?: true
    description?: true
  }

  export type DietChartMaxAggregateInputType = {
    chart_id?: true
    name?: true
    description?: true
  }

  export type DietChartCountAggregateInputType = {
    chart_id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type DietChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietChart to aggregate.
     */
    where?: DietChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietCharts to fetch.
     */
    orderBy?: DietChartOrderByWithRelationInput | DietChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietCharts
    **/
    _count?: true | DietChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietChartMaxAggregateInputType
  }

  export type GetDietChartAggregateType<T extends DietChartAggregateArgs> = {
        [P in keyof T & keyof AggregateDietChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietChart[P]>
      : GetScalarType<T[P], AggregateDietChart[P]>
  }




  export type DietChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietChartWhereInput
    orderBy?: DietChartOrderByWithAggregationInput | DietChartOrderByWithAggregationInput[]
    by: DietChartScalarFieldEnum[] | DietChartScalarFieldEnum
    having?: DietChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietChartCountAggregateInputType | true
    _min?: DietChartMinAggregateInputType
    _max?: DietChartMaxAggregateInputType
  }

  export type DietChartGroupByOutputType = {
    chart_id: string
    name: string
    description: string | null
    _count: DietChartCountAggregateOutputType | null
    _min: DietChartMinAggregateOutputType | null
    _max: DietChartMaxAggregateOutputType | null
  }

  type GetDietChartGroupByPayload<T extends DietChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietChartGroupByOutputType[P]>
            : GetScalarType<T[P], DietChartGroupByOutputType[P]>
        }
      >
    >


  export type DietChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    name?: boolean
    description?: boolean
    DietChartRecipe?: boolean | DietChart$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | DietChartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietChart"]>

  export type DietChartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["dietChart"]>

  export type DietChartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["dietChart"]>

  export type DietChartSelectScalar = {
    chart_id?: boolean
    name?: boolean
    description?: boolean
  }

  export type DietChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chart_id" | "name" | "description", ExtArgs["result"]["dietChart"]>
  export type DietChartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DietChartRecipe?: boolean | DietChart$DietChartRecipeArgs<ExtArgs>
    _count?: boolean | DietChartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DietChartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DietChartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DietChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietChart"
    objects: {
      DietChartRecipe: Prisma.$DietChartRecipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      chart_id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["dietChart"]>
    composites: {}
  }

  type DietChartGetPayload<S extends boolean | null | undefined | DietChartDefaultArgs> = $Result.GetResult<Prisma.$DietChartPayload, S>

  type DietChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DietChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DietChartCountAggregateInputType | true
    }

  export interface DietChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietChart'], meta: { name: 'DietChart' } }
    /**
     * Find zero or one DietChart that matches the filter.
     * @param {DietChartFindUniqueArgs} args - Arguments to find a DietChart
     * @example
     * // Get one DietChart
     * const dietChart = await prisma.dietChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietChartFindUniqueArgs>(args: SelectSubset<T, DietChartFindUniqueArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DietChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DietChartFindUniqueOrThrowArgs} args - Arguments to find a DietChart
     * @example
     * // Get one DietChart
     * const dietChart = await prisma.dietChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietChartFindUniqueOrThrowArgs>(args: SelectSubset<T, DietChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartFindFirstArgs} args - Arguments to find a DietChart
     * @example
     * // Get one DietChart
     * const dietChart = await prisma.dietChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietChartFindFirstArgs>(args?: SelectSubset<T, DietChartFindFirstArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartFindFirstOrThrowArgs} args - Arguments to find a DietChart
     * @example
     * // Get one DietChart
     * const dietChart = await prisma.dietChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietChartFindFirstOrThrowArgs>(args?: SelectSubset<T, DietChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DietCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietCharts
     * const dietCharts = await prisma.dietChart.findMany()
     * 
     * // Get first 10 DietCharts
     * const dietCharts = await prisma.dietChart.findMany({ take: 10 })
     * 
     * // Only select the `chart_id`
     * const dietChartWithChart_idOnly = await prisma.dietChart.findMany({ select: { chart_id: true } })
     * 
     */
    findMany<T extends DietChartFindManyArgs>(args?: SelectSubset<T, DietChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DietChart.
     * @param {DietChartCreateArgs} args - Arguments to create a DietChart.
     * @example
     * // Create one DietChart
     * const DietChart = await prisma.dietChart.create({
     *   data: {
     *     // ... data to create a DietChart
     *   }
     * })
     * 
     */
    create<T extends DietChartCreateArgs>(args: SelectSubset<T, DietChartCreateArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DietCharts.
     * @param {DietChartCreateManyArgs} args - Arguments to create many DietCharts.
     * @example
     * // Create many DietCharts
     * const dietChart = await prisma.dietChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietChartCreateManyArgs>(args?: SelectSubset<T, DietChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietCharts and returns the data saved in the database.
     * @param {DietChartCreateManyAndReturnArgs} args - Arguments to create many DietCharts.
     * @example
     * // Create many DietCharts
     * const dietChart = await prisma.dietChart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietCharts and only return the `chart_id`
     * const dietChartWithChart_idOnly = await prisma.dietChart.createManyAndReturn({
     *   select: { chart_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietChartCreateManyAndReturnArgs>(args?: SelectSubset<T, DietChartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DietChart.
     * @param {DietChartDeleteArgs} args - Arguments to delete one DietChart.
     * @example
     * // Delete one DietChart
     * const DietChart = await prisma.dietChart.delete({
     *   where: {
     *     // ... filter to delete one DietChart
     *   }
     * })
     * 
     */
    delete<T extends DietChartDeleteArgs>(args: SelectSubset<T, DietChartDeleteArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DietChart.
     * @param {DietChartUpdateArgs} args - Arguments to update one DietChart.
     * @example
     * // Update one DietChart
     * const dietChart = await prisma.dietChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietChartUpdateArgs>(args: SelectSubset<T, DietChartUpdateArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DietCharts.
     * @param {DietChartDeleteManyArgs} args - Arguments to filter DietCharts to delete.
     * @example
     * // Delete a few DietCharts
     * const { count } = await prisma.dietChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietChartDeleteManyArgs>(args?: SelectSubset<T, DietChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietCharts
     * const dietChart = await prisma.dietChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietChartUpdateManyArgs>(args: SelectSubset<T, DietChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietCharts and returns the data updated in the database.
     * @param {DietChartUpdateManyAndReturnArgs} args - Arguments to update many DietCharts.
     * @example
     * // Update many DietCharts
     * const dietChart = await prisma.dietChart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DietCharts and only return the `chart_id`
     * const dietChartWithChart_idOnly = await prisma.dietChart.updateManyAndReturn({
     *   select: { chart_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DietChartUpdateManyAndReturnArgs>(args: SelectSubset<T, DietChartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DietChart.
     * @param {DietChartUpsertArgs} args - Arguments to update or create a DietChart.
     * @example
     * // Update or create a DietChart
     * const dietChart = await prisma.dietChart.upsert({
     *   create: {
     *     // ... data to create a DietChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietChart we want to update
     *   }
     * })
     */
    upsert<T extends DietChartUpsertArgs>(args: SelectSubset<T, DietChartUpsertArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DietCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartCountArgs} args - Arguments to filter DietCharts to count.
     * @example
     * // Count the number of DietCharts
     * const count = await prisma.dietChart.count({
     *   where: {
     *     // ... the filter for the DietCharts we want to count
     *   }
     * })
    **/
    count<T extends DietChartCountArgs>(
      args?: Subset<T, DietChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietChartAggregateArgs>(args: Subset<T, DietChartAggregateArgs>): Prisma.PrismaPromise<GetDietChartAggregateType<T>>

    /**
     * Group by DietChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietChartGroupByArgs['orderBy'] }
        : { orderBy?: DietChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietChart model
   */
  readonly fields: DietChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DietChartRecipe<T extends DietChart$DietChartRecipeArgs<ExtArgs> = {}>(args?: Subset<T, DietChart$DietChartRecipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietChart model
   */
  interface DietChartFieldRefs {
    readonly chart_id: FieldRef<"DietChart", 'String'>
    readonly name: FieldRef<"DietChart", 'String'>
    readonly description: FieldRef<"DietChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DietChart findUnique
   */
  export type DietChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter, which DietChart to fetch.
     */
    where: DietChartWhereUniqueInput
  }

  /**
   * DietChart findUniqueOrThrow
   */
  export type DietChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter, which DietChart to fetch.
     */
    where: DietChartWhereUniqueInput
  }

  /**
   * DietChart findFirst
   */
  export type DietChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter, which DietChart to fetch.
     */
    where?: DietChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietCharts to fetch.
     */
    orderBy?: DietChartOrderByWithRelationInput | DietChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietCharts.
     */
    cursor?: DietChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietCharts.
     */
    distinct?: DietChartScalarFieldEnum | DietChartScalarFieldEnum[]
  }

  /**
   * DietChart findFirstOrThrow
   */
  export type DietChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter, which DietChart to fetch.
     */
    where?: DietChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietCharts to fetch.
     */
    orderBy?: DietChartOrderByWithRelationInput | DietChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietCharts.
     */
    cursor?: DietChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietCharts.
     */
    distinct?: DietChartScalarFieldEnum | DietChartScalarFieldEnum[]
  }

  /**
   * DietChart findMany
   */
  export type DietChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter, which DietCharts to fetch.
     */
    where?: DietChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietCharts to fetch.
     */
    orderBy?: DietChartOrderByWithRelationInput | DietChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietCharts.
     */
    cursor?: DietChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietCharts.
     */
    skip?: number
    distinct?: DietChartScalarFieldEnum | DietChartScalarFieldEnum[]
  }

  /**
   * DietChart create
   */
  export type DietChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * The data needed to create a DietChart.
     */
    data: XOR<DietChartCreateInput, DietChartUncheckedCreateInput>
  }

  /**
   * DietChart createMany
   */
  export type DietChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietCharts.
     */
    data: DietChartCreateManyInput | DietChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietChart createManyAndReturn
   */
  export type DietChartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * The data used to create many DietCharts.
     */
    data: DietChartCreateManyInput | DietChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietChart update
   */
  export type DietChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * The data needed to update a DietChart.
     */
    data: XOR<DietChartUpdateInput, DietChartUncheckedUpdateInput>
    /**
     * Choose, which DietChart to update.
     */
    where: DietChartWhereUniqueInput
  }

  /**
   * DietChart updateMany
   */
  export type DietChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietCharts.
     */
    data: XOR<DietChartUpdateManyMutationInput, DietChartUncheckedUpdateManyInput>
    /**
     * Filter which DietCharts to update
     */
    where?: DietChartWhereInput
    /**
     * Limit how many DietCharts to update.
     */
    limit?: number
  }

  /**
   * DietChart updateManyAndReturn
   */
  export type DietChartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * The data used to update DietCharts.
     */
    data: XOR<DietChartUpdateManyMutationInput, DietChartUncheckedUpdateManyInput>
    /**
     * Filter which DietCharts to update
     */
    where?: DietChartWhereInput
    /**
     * Limit how many DietCharts to update.
     */
    limit?: number
  }

  /**
   * DietChart upsert
   */
  export type DietChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * The filter to search for the DietChart to update in case it exists.
     */
    where: DietChartWhereUniqueInput
    /**
     * In case the DietChart found by the `where` argument doesn't exist, create a new DietChart with this data.
     */
    create: XOR<DietChartCreateInput, DietChartUncheckedCreateInput>
    /**
     * In case the DietChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietChartUpdateInput, DietChartUncheckedUpdateInput>
  }

  /**
   * DietChart delete
   */
  export type DietChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
    /**
     * Filter which DietChart to delete.
     */
    where: DietChartWhereUniqueInput
  }

  /**
   * DietChart deleteMany
   */
  export type DietChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietCharts to delete
     */
    where?: DietChartWhereInput
    /**
     * Limit how many DietCharts to delete.
     */
    limit?: number
  }

  /**
   * DietChart.DietChartRecipe
   */
  export type DietChart$DietChartRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    where?: DietChartRecipeWhereInput
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    cursor?: DietChartRecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * DietChart without action
   */
  export type DietChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChart
     */
    select?: DietChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChart
     */
    omit?: DietChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartInclude<ExtArgs> | null
  }


  /**
   * Model DietChartRecipe
   */

  export type AggregateDietChartRecipe = {
    _count: DietChartRecipeCountAggregateOutputType | null
    _avg: DietChartRecipeAvgAggregateOutputType | null
    _sum: DietChartRecipeSumAggregateOutputType | null
    _min: DietChartRecipeMinAggregateOutputType | null
    _max: DietChartRecipeMaxAggregateOutputType | null
  }

  export type DietChartRecipeAvgAggregateOutputType = {
    quantity: number | null
  }

  export type DietChartRecipeSumAggregateOutputType = {
    quantity: number | null
  }

  export type DietChartRecipeMinAggregateOutputType = {
    chart_id: string | null
    recipe_id: string | null
    mealTime: $Enums.MealTime | null
    food_id: string | null
    quantity: number | null
  }

  export type DietChartRecipeMaxAggregateOutputType = {
    chart_id: string | null
    recipe_id: string | null
    mealTime: $Enums.MealTime | null
    food_id: string | null
    quantity: number | null
  }

  export type DietChartRecipeCountAggregateOutputType = {
    chart_id: number
    recipe_id: number
    mealTime: number
    food_id: number
    quantity: number
    _all: number
  }


  export type DietChartRecipeAvgAggregateInputType = {
    quantity?: true
  }

  export type DietChartRecipeSumAggregateInputType = {
    quantity?: true
  }

  export type DietChartRecipeMinAggregateInputType = {
    chart_id?: true
    recipe_id?: true
    mealTime?: true
    food_id?: true
    quantity?: true
  }

  export type DietChartRecipeMaxAggregateInputType = {
    chart_id?: true
    recipe_id?: true
    mealTime?: true
    food_id?: true
    quantity?: true
  }

  export type DietChartRecipeCountAggregateInputType = {
    chart_id?: true
    recipe_id?: true
    mealTime?: true
    food_id?: true
    quantity?: true
    _all?: true
  }

  export type DietChartRecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietChartRecipe to aggregate.
     */
    where?: DietChartRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietChartRecipes to fetch.
     */
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietChartRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietChartRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietChartRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietChartRecipes
    **/
    _count?: true | DietChartRecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DietChartRecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DietChartRecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietChartRecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietChartRecipeMaxAggregateInputType
  }

  export type GetDietChartRecipeAggregateType<T extends DietChartRecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateDietChartRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietChartRecipe[P]>
      : GetScalarType<T[P], AggregateDietChartRecipe[P]>
  }




  export type DietChartRecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietChartRecipeWhereInput
    orderBy?: DietChartRecipeOrderByWithAggregationInput | DietChartRecipeOrderByWithAggregationInput[]
    by: DietChartRecipeScalarFieldEnum[] | DietChartRecipeScalarFieldEnum
    having?: DietChartRecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietChartRecipeCountAggregateInputType | true
    _avg?: DietChartRecipeAvgAggregateInputType
    _sum?: DietChartRecipeSumAggregateInputType
    _min?: DietChartRecipeMinAggregateInputType
    _max?: DietChartRecipeMaxAggregateInputType
  }

  export type DietChartRecipeGroupByOutputType = {
    chart_id: string
    recipe_id: string
    mealTime: $Enums.MealTime
    food_id: string | null
    quantity: number | null
    _count: DietChartRecipeCountAggregateOutputType | null
    _avg: DietChartRecipeAvgAggregateOutputType | null
    _sum: DietChartRecipeSumAggregateOutputType | null
    _min: DietChartRecipeMinAggregateOutputType | null
    _max: DietChartRecipeMaxAggregateOutputType | null
  }

  type GetDietChartRecipeGroupByPayload<T extends DietChartRecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietChartRecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietChartRecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietChartRecipeGroupByOutputType[P]>
            : GetScalarType<T[P], DietChartRecipeGroupByOutputType[P]>
        }
      >
    >


  export type DietChartRecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    recipe_id?: boolean
    mealTime?: boolean
    food_id?: boolean
    quantity?: boolean
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }, ExtArgs["result"]["dietChartRecipe"]>

  export type DietChartRecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    recipe_id?: boolean
    mealTime?: boolean
    food_id?: boolean
    quantity?: boolean
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }, ExtArgs["result"]["dietChartRecipe"]>

  export type DietChartRecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chart_id?: boolean
    recipe_id?: boolean
    mealTime?: boolean
    food_id?: boolean
    quantity?: boolean
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }, ExtArgs["result"]["dietChartRecipe"]>

  export type DietChartRecipeSelectScalar = {
    chart_id?: boolean
    recipe_id?: boolean
    mealTime?: boolean
    food_id?: boolean
    quantity?: boolean
  }

  export type DietChartRecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chart_id" | "recipe_id" | "mealTime" | "food_id" | "quantity", ExtArgs["result"]["dietChartRecipe"]>
  export type DietChartRecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }
  export type DietChartRecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }
  export type DietChartRecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietChart?: boolean | DietChartDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    food?: boolean | DietChartRecipe$foodArgs<ExtArgs>
  }

  export type $DietChartRecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietChartRecipe"
    objects: {
      dietChart: Prisma.$DietChartPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
      food: Prisma.$FoodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      chart_id: string
      recipe_id: string
      mealTime: $Enums.MealTime
      food_id: string | null
      quantity: number | null
    }, ExtArgs["result"]["dietChartRecipe"]>
    composites: {}
  }

  type DietChartRecipeGetPayload<S extends boolean | null | undefined | DietChartRecipeDefaultArgs> = $Result.GetResult<Prisma.$DietChartRecipePayload, S>

  type DietChartRecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DietChartRecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DietChartRecipeCountAggregateInputType | true
    }

  export interface DietChartRecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietChartRecipe'], meta: { name: 'DietChartRecipe' } }
    /**
     * Find zero or one DietChartRecipe that matches the filter.
     * @param {DietChartRecipeFindUniqueArgs} args - Arguments to find a DietChartRecipe
     * @example
     * // Get one DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietChartRecipeFindUniqueArgs>(args: SelectSubset<T, DietChartRecipeFindUniqueArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DietChartRecipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DietChartRecipeFindUniqueOrThrowArgs} args - Arguments to find a DietChartRecipe
     * @example
     * // Get one DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietChartRecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, DietChartRecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietChartRecipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeFindFirstArgs} args - Arguments to find a DietChartRecipe
     * @example
     * // Get one DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietChartRecipeFindFirstArgs>(args?: SelectSubset<T, DietChartRecipeFindFirstArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietChartRecipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeFindFirstOrThrowArgs} args - Arguments to find a DietChartRecipe
     * @example
     * // Get one DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietChartRecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, DietChartRecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DietChartRecipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietChartRecipes
     * const dietChartRecipes = await prisma.dietChartRecipe.findMany()
     * 
     * // Get first 10 DietChartRecipes
     * const dietChartRecipes = await prisma.dietChartRecipe.findMany({ take: 10 })
     * 
     * // Only select the `chart_id`
     * const dietChartRecipeWithChart_idOnly = await prisma.dietChartRecipe.findMany({ select: { chart_id: true } })
     * 
     */
    findMany<T extends DietChartRecipeFindManyArgs>(args?: SelectSubset<T, DietChartRecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DietChartRecipe.
     * @param {DietChartRecipeCreateArgs} args - Arguments to create a DietChartRecipe.
     * @example
     * // Create one DietChartRecipe
     * const DietChartRecipe = await prisma.dietChartRecipe.create({
     *   data: {
     *     // ... data to create a DietChartRecipe
     *   }
     * })
     * 
     */
    create<T extends DietChartRecipeCreateArgs>(args: SelectSubset<T, DietChartRecipeCreateArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DietChartRecipes.
     * @param {DietChartRecipeCreateManyArgs} args - Arguments to create many DietChartRecipes.
     * @example
     * // Create many DietChartRecipes
     * const dietChartRecipe = await prisma.dietChartRecipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietChartRecipeCreateManyArgs>(args?: SelectSubset<T, DietChartRecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietChartRecipes and returns the data saved in the database.
     * @param {DietChartRecipeCreateManyAndReturnArgs} args - Arguments to create many DietChartRecipes.
     * @example
     * // Create many DietChartRecipes
     * const dietChartRecipe = await prisma.dietChartRecipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietChartRecipes and only return the `chart_id`
     * const dietChartRecipeWithChart_idOnly = await prisma.dietChartRecipe.createManyAndReturn({
     *   select: { chart_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietChartRecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, DietChartRecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DietChartRecipe.
     * @param {DietChartRecipeDeleteArgs} args - Arguments to delete one DietChartRecipe.
     * @example
     * // Delete one DietChartRecipe
     * const DietChartRecipe = await prisma.dietChartRecipe.delete({
     *   where: {
     *     // ... filter to delete one DietChartRecipe
     *   }
     * })
     * 
     */
    delete<T extends DietChartRecipeDeleteArgs>(args: SelectSubset<T, DietChartRecipeDeleteArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DietChartRecipe.
     * @param {DietChartRecipeUpdateArgs} args - Arguments to update one DietChartRecipe.
     * @example
     * // Update one DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietChartRecipeUpdateArgs>(args: SelectSubset<T, DietChartRecipeUpdateArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DietChartRecipes.
     * @param {DietChartRecipeDeleteManyArgs} args - Arguments to filter DietChartRecipes to delete.
     * @example
     * // Delete a few DietChartRecipes
     * const { count } = await prisma.dietChartRecipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietChartRecipeDeleteManyArgs>(args?: SelectSubset<T, DietChartRecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietChartRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietChartRecipes
     * const dietChartRecipe = await prisma.dietChartRecipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietChartRecipeUpdateManyArgs>(args: SelectSubset<T, DietChartRecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietChartRecipes and returns the data updated in the database.
     * @param {DietChartRecipeUpdateManyAndReturnArgs} args - Arguments to update many DietChartRecipes.
     * @example
     * // Update many DietChartRecipes
     * const dietChartRecipe = await prisma.dietChartRecipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DietChartRecipes and only return the `chart_id`
     * const dietChartRecipeWithChart_idOnly = await prisma.dietChartRecipe.updateManyAndReturn({
     *   select: { chart_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DietChartRecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, DietChartRecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DietChartRecipe.
     * @param {DietChartRecipeUpsertArgs} args - Arguments to update or create a DietChartRecipe.
     * @example
     * // Update or create a DietChartRecipe
     * const dietChartRecipe = await prisma.dietChartRecipe.upsert({
     *   create: {
     *     // ... data to create a DietChartRecipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietChartRecipe we want to update
     *   }
     * })
     */
    upsert<T extends DietChartRecipeUpsertArgs>(args: SelectSubset<T, DietChartRecipeUpsertArgs<ExtArgs>>): Prisma__DietChartRecipeClient<$Result.GetResult<Prisma.$DietChartRecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DietChartRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeCountArgs} args - Arguments to filter DietChartRecipes to count.
     * @example
     * // Count the number of DietChartRecipes
     * const count = await prisma.dietChartRecipe.count({
     *   where: {
     *     // ... the filter for the DietChartRecipes we want to count
     *   }
     * })
    **/
    count<T extends DietChartRecipeCountArgs>(
      args?: Subset<T, DietChartRecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietChartRecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietChartRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietChartRecipeAggregateArgs>(args: Subset<T, DietChartRecipeAggregateArgs>): Prisma.PrismaPromise<GetDietChartRecipeAggregateType<T>>

    /**
     * Group by DietChartRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietChartRecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietChartRecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietChartRecipeGroupByArgs['orderBy'] }
        : { orderBy?: DietChartRecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietChartRecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietChartRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietChartRecipe model
   */
  readonly fields: DietChartRecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietChartRecipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietChartRecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dietChart<T extends DietChartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DietChartDefaultArgs<ExtArgs>>): Prisma__DietChartClient<$Result.GetResult<Prisma.$DietChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    food<T extends DietChartRecipe$foodArgs<ExtArgs> = {}>(args?: Subset<T, DietChartRecipe$foodArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietChartRecipe model
   */
  interface DietChartRecipeFieldRefs {
    readonly chart_id: FieldRef<"DietChartRecipe", 'String'>
    readonly recipe_id: FieldRef<"DietChartRecipe", 'String'>
    readonly mealTime: FieldRef<"DietChartRecipe", 'MealTime'>
    readonly food_id: FieldRef<"DietChartRecipe", 'String'>
    readonly quantity: FieldRef<"DietChartRecipe", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DietChartRecipe findUnique
   */
  export type DietChartRecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter, which DietChartRecipe to fetch.
     */
    where: DietChartRecipeWhereUniqueInput
  }

  /**
   * DietChartRecipe findUniqueOrThrow
   */
  export type DietChartRecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter, which DietChartRecipe to fetch.
     */
    where: DietChartRecipeWhereUniqueInput
  }

  /**
   * DietChartRecipe findFirst
   */
  export type DietChartRecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter, which DietChartRecipe to fetch.
     */
    where?: DietChartRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietChartRecipes to fetch.
     */
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietChartRecipes.
     */
    cursor?: DietChartRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietChartRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietChartRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietChartRecipes.
     */
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * DietChartRecipe findFirstOrThrow
   */
  export type DietChartRecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter, which DietChartRecipe to fetch.
     */
    where?: DietChartRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietChartRecipes to fetch.
     */
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietChartRecipes.
     */
    cursor?: DietChartRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietChartRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietChartRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietChartRecipes.
     */
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * DietChartRecipe findMany
   */
  export type DietChartRecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter, which DietChartRecipes to fetch.
     */
    where?: DietChartRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietChartRecipes to fetch.
     */
    orderBy?: DietChartRecipeOrderByWithRelationInput | DietChartRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietChartRecipes.
     */
    cursor?: DietChartRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietChartRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietChartRecipes.
     */
    skip?: number
    distinct?: DietChartRecipeScalarFieldEnum | DietChartRecipeScalarFieldEnum[]
  }

  /**
   * DietChartRecipe create
   */
  export type DietChartRecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a DietChartRecipe.
     */
    data: XOR<DietChartRecipeCreateInput, DietChartRecipeUncheckedCreateInput>
  }

  /**
   * DietChartRecipe createMany
   */
  export type DietChartRecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietChartRecipes.
     */
    data: DietChartRecipeCreateManyInput | DietChartRecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietChartRecipe createManyAndReturn
   */
  export type DietChartRecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * The data used to create many DietChartRecipes.
     */
    data: DietChartRecipeCreateManyInput | DietChartRecipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DietChartRecipe update
   */
  export type DietChartRecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a DietChartRecipe.
     */
    data: XOR<DietChartRecipeUpdateInput, DietChartRecipeUncheckedUpdateInput>
    /**
     * Choose, which DietChartRecipe to update.
     */
    where: DietChartRecipeWhereUniqueInput
  }

  /**
   * DietChartRecipe updateMany
   */
  export type DietChartRecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietChartRecipes.
     */
    data: XOR<DietChartRecipeUpdateManyMutationInput, DietChartRecipeUncheckedUpdateManyInput>
    /**
     * Filter which DietChartRecipes to update
     */
    where?: DietChartRecipeWhereInput
    /**
     * Limit how many DietChartRecipes to update.
     */
    limit?: number
  }

  /**
   * DietChartRecipe updateManyAndReturn
   */
  export type DietChartRecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * The data used to update DietChartRecipes.
     */
    data: XOR<DietChartRecipeUpdateManyMutationInput, DietChartRecipeUncheckedUpdateManyInput>
    /**
     * Filter which DietChartRecipes to update
     */
    where?: DietChartRecipeWhereInput
    /**
     * Limit how many DietChartRecipes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DietChartRecipe upsert
   */
  export type DietChartRecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the DietChartRecipe to update in case it exists.
     */
    where: DietChartRecipeWhereUniqueInput
    /**
     * In case the DietChartRecipe found by the `where` argument doesn't exist, create a new DietChartRecipe with this data.
     */
    create: XOR<DietChartRecipeCreateInput, DietChartRecipeUncheckedCreateInput>
    /**
     * In case the DietChartRecipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietChartRecipeUpdateInput, DietChartRecipeUncheckedUpdateInput>
  }

  /**
   * DietChartRecipe delete
   */
  export type DietChartRecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
    /**
     * Filter which DietChartRecipe to delete.
     */
    where: DietChartRecipeWhereUniqueInput
  }

  /**
   * DietChartRecipe deleteMany
   */
  export type DietChartRecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietChartRecipes to delete
     */
    where?: DietChartRecipeWhereInput
    /**
     * Limit how many DietChartRecipes to delete.
     */
    limit?: number
  }

  /**
   * DietChartRecipe.food
   */
  export type DietChartRecipe$foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Food
     */
    omit?: FoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    where?: FoodWhereInput
  }

  /**
   * DietChartRecipe without action
   */
  export type DietChartRecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietChartRecipe
     */
    select?: DietChartRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietChartRecipe
     */
    omit?: DietChartRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietChartRecipeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gender: 'gender',
    dob: 'dob',
    height: 'height',
    weight: 'weight',
    dietary_habits: 'dietary_habits',
    mealFrequency: 'mealFrequency',
    waterIntake: 'waterIntake',
    digestionQuality: 'digestionQuality',
    bowelMovement: 'bowelMovement'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const DoctorPatientScalarFieldEnum: {
    doctor_id: 'doctor_id',
    patient_id: 'patient_id'
  };

  export type DoctorPatientScalarFieldEnum = (typeof DoctorPatientScalarFieldEnum)[keyof typeof DoctorPatientScalarFieldEnum]


  export const CuisineScalarFieldEnum: {
    cuisine_id: 'cuisine_id',
    name: 'name'
  };

  export type CuisineScalarFieldEnum = (typeof CuisineScalarFieldEnum)[keyof typeof CuisineScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    food_id: 'food_id',
    name: 'name',
    hindi_name: 'hindi_name'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const NutrientScalarFieldEnum: {
    nutrient_id: 'nutrient_id',
    name: 'name',
    unit: 'unit'
  };

  export type NutrientScalarFieldEnum = (typeof NutrientScalarFieldEnum)[keyof typeof NutrientScalarFieldEnum]


  export const RasaScalarFieldEnum: {
    rasa_id: 'rasa_id',
    name: 'name'
  };

  export type RasaScalarFieldEnum = (typeof RasaScalarFieldEnum)[keyof typeof RasaScalarFieldEnum]


  export const GunaScalarFieldEnum: {
    guna_id: 'guna_id',
    name: 'name'
  };

  export type GunaScalarFieldEnum = (typeof GunaScalarFieldEnum)[keyof typeof GunaScalarFieldEnum]


  export const DoshaScalarFieldEnum: {
    dosha_id: 'dosha_id',
    name: 'name'
  };

  export type DoshaScalarFieldEnum = (typeof DoshaScalarFieldEnum)[keyof typeof DoshaScalarFieldEnum]


  export const ViryaScalarFieldEnum: {
    virya_id: 'virya_id',
    name: 'name'
  };

  export type ViryaScalarFieldEnum = (typeof ViryaScalarFieldEnum)[keyof typeof ViryaScalarFieldEnum]


  export const VipakaScalarFieldEnum: {
    vipaka_id: 'vipaka_id',
    name: 'name'
  };

  export type VipakaScalarFieldEnum = (typeof VipakaScalarFieldEnum)[keyof typeof VipakaScalarFieldEnum]


  export const DigestibilityScalarFieldEnum: {
    digestibility_id: 'digestibility_id',
    name: 'name'
  };

  export type DigestibilityScalarFieldEnum = (typeof DigestibilityScalarFieldEnum)[keyof typeof DigestibilityScalarFieldEnum]


  export const RdaScalarFieldEnum: {
    rda_id: 'rda_id',
    nutrient_id: 'nutrient_id',
    age_group: 'age_group',
    gender: 'gender',
    amount: 'amount'
  };

  export type RdaScalarFieldEnum = (typeof RdaScalarFieldEnum)[keyof typeof RdaScalarFieldEnum]


  export const FoodNutrientScalarFieldEnum: {
    food_id: 'food_id',
    nutrient_id: 'nutrient_id',
    amount: 'amount'
  };

  export type FoodNutrientScalarFieldEnum = (typeof FoodNutrientScalarFieldEnum)[keyof typeof FoodNutrientScalarFieldEnum]


  export const FoodRasaScalarFieldEnum: {
    food_id: 'food_id',
    rasa_id: 'rasa_id'
  };

  export type FoodRasaScalarFieldEnum = (typeof FoodRasaScalarFieldEnum)[keyof typeof FoodRasaScalarFieldEnum]


  export const FoodGunaScalarFieldEnum: {
    food_id: 'food_id',
    guna_id: 'guna_id'
  };

  export type FoodGunaScalarFieldEnum = (typeof FoodGunaScalarFieldEnum)[keyof typeof FoodGunaScalarFieldEnum]


  export const FoodDoshaScalarFieldEnum: {
    food_id: 'food_id',
    dosha_id: 'dosha_id'
  };

  export type FoodDoshaScalarFieldEnum = (typeof FoodDoshaScalarFieldEnum)[keyof typeof FoodDoshaScalarFieldEnum]


  export const PatientDoshaScalarFieldEnum: {
    patient_id: 'patient_id',
    dosha_id: 'dosha_id'
  };

  export type PatientDoshaScalarFieldEnum = (typeof PatientDoshaScalarFieldEnum)[keyof typeof PatientDoshaScalarFieldEnum]


  export const FoodViryaScalarFieldEnum: {
    food_id: 'food_id',
    virya_id: 'virya_id'
  };

  export type FoodViryaScalarFieldEnum = (typeof FoodViryaScalarFieldEnum)[keyof typeof FoodViryaScalarFieldEnum]


  export const FoodVipakaScalarFieldEnum: {
    food_id: 'food_id',
    vipaka_id: 'vipaka_id'
  };

  export type FoodVipakaScalarFieldEnum = (typeof FoodVipakaScalarFieldEnum)[keyof typeof FoodVipakaScalarFieldEnum]


  export const FoodDigestibilityScalarFieldEnum: {
    food_id: 'food_id',
    digestibility_id: 'digestibility_id'
  };

  export type FoodDigestibilityScalarFieldEnum = (typeof FoodDigestibilityScalarFieldEnum)[keyof typeof FoodDigestibilityScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    recipe_id: 'recipe_id',
    name: 'name',
    cuisine_id: 'cuisine_id'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeIngredientScalarFieldEnum: {
    recipe_id: 'recipe_id',
    food_id: 'food_id',
    quantity: 'quantity'
  };

  export type RecipeIngredientScalarFieldEnum = (typeof RecipeIngredientScalarFieldEnum)[keyof typeof RecipeIngredientScalarFieldEnum]


  export const DietChartScalarFieldEnum: {
    chart_id: 'chart_id',
    name: 'name',
    description: 'description'
  };

  export type DietChartScalarFieldEnum = (typeof DietChartScalarFieldEnum)[keyof typeof DietChartScalarFieldEnum]


  export const DietChartRecipeScalarFieldEnum: {
    chart_id: 'chart_id',
    recipe_id: 'recipe_id',
    mealTime: 'mealTime',
    food_id: 'food_id',
    quantity: 'quantity'
  };

  export type DietChartRecipeScalarFieldEnum = (typeof DietChartRecipeScalarFieldEnum)[keyof typeof DietChartRecipeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DietaryHabits'
   */
  export type EnumDietaryHabitsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DietaryHabits'>
    


  /**
   * Reference to a field of type 'DietaryHabits[]'
   */
  export type ListEnumDietaryHabitsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DietaryHabits[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DigestionQuality'
   */
  export type EnumDigestionQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigestionQuality'>
    


  /**
   * Reference to a field of type 'DigestionQuality[]'
   */
  export type ListEnumDigestionQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigestionQuality[]'>
    


  /**
   * Reference to a field of type 'BowelMovement'
   */
  export type EnumBowelMovementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BowelMovement'>
    


  /**
   * Reference to a field of type 'BowelMovement[]'
   */
  export type ListEnumBowelMovementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BowelMovement[]'>
    


  /**
   * Reference to a field of type 'AgeGroup'
   */
  export type EnumAgeGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeGroup'>
    


  /**
   * Reference to a field of type 'AgeGroup[]'
   */
  export type ListEnumAgeGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeGroup[]'>
    


  /**
   * Reference to a field of type 'MealTime'
   */
  export type EnumMealTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MealTime'>
    


  /**
   * Reference to a field of type 'MealTime[]'
   */
  export type ListEnumMealTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MealTime[]'>
    
  /**
   * Deep Input Types
   */


  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: StringFilter<"Doctor"> | string
    email?: StringFilter<"Doctor"> | string
    name?: StringNullableFilter<"Doctor"> | string | null
    password?: StringFilter<"Doctor"> | string
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    DoctorPatient?: DoctorPatientListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DoctorPatient?: DoctorPatientOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    name?: StringNullableFilter<"Doctor"> | string | null
    password?: StringFilter<"Doctor"> | string
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    DoctorPatient?: DoctorPatientListRelationFilter
  }, "id" | "email">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Doctor"> | string
    email?: StringWithAggregatesFilter<"Doctor"> | string
    name?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    password?: StringWithAggregatesFilter<"Doctor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    email?: StringFilter<"Patient"> | string
    name?: StringNullableFilter<"Patient"> | string | null
    password?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    dietary_habits?: EnumDietaryHabitsFilter<"Patient"> | $Enums.DietaryHabits
    mealFrequency?: IntFilter<"Patient"> | number
    waterIntake?: FloatFilter<"Patient"> | number
    digestionQuality?: EnumDigestionQualityFilter<"Patient"> | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFilter<"Patient"> | $Enums.BowelMovement
    PatientDosha?: PatientDoshaListRelationFilter
    DoctorPatient?: DoctorPatientListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dietary_habits?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
    digestionQuality?: SortOrder
    bowelMovement?: SortOrder
    PatientDosha?: PatientDoshaOrderByRelationAggregateInput
    DoctorPatient?: DoctorPatientOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    name?: StringNullableFilter<"Patient"> | string | null
    password?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    dietary_habits?: EnumDietaryHabitsFilter<"Patient"> | $Enums.DietaryHabits
    mealFrequency?: IntFilter<"Patient"> | number
    waterIntake?: FloatFilter<"Patient"> | number
    digestionQuality?: EnumDigestionQualityFilter<"Patient"> | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFilter<"Patient"> | $Enums.BowelMovement
    PatientDosha?: PatientDoshaListRelationFilter
    DoctorPatient?: DoctorPatientListRelationFilter
  }, "id" | "email">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dietary_habits?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
    digestionQuality?: SortOrder
    bowelMovement?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    email?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    password?: StringWithAggregatesFilter<"Patient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    gender?: EnumGenderNullableWithAggregatesFilter<"Patient"> | $Enums.Gender | null
    dob?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    height?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    dietary_habits?: EnumDietaryHabitsWithAggregatesFilter<"Patient"> | $Enums.DietaryHabits
    mealFrequency?: IntWithAggregatesFilter<"Patient"> | number
    waterIntake?: FloatWithAggregatesFilter<"Patient"> | number
    digestionQuality?: EnumDigestionQualityWithAggregatesFilter<"Patient"> | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementWithAggregatesFilter<"Patient"> | $Enums.BowelMovement
  }

  export type DoctorPatientWhereInput = {
    AND?: DoctorPatientWhereInput | DoctorPatientWhereInput[]
    OR?: DoctorPatientWhereInput[]
    NOT?: DoctorPatientWhereInput | DoctorPatientWhereInput[]
    doctor_id?: StringFilter<"DoctorPatient"> | string
    patient_id?: StringFilter<"DoctorPatient"> | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type DoctorPatientOrderByWithRelationInput = {
    doctor_id?: SortOrder
    patient_id?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type DoctorPatientWhereUniqueInput = Prisma.AtLeast<{
    doctor_id_patient_id?: DoctorPatientDoctor_idPatient_idCompoundUniqueInput
    AND?: DoctorPatientWhereInput | DoctorPatientWhereInput[]
    OR?: DoctorPatientWhereInput[]
    NOT?: DoctorPatientWhereInput | DoctorPatientWhereInput[]
    doctor_id?: StringFilter<"DoctorPatient"> | string
    patient_id?: StringFilter<"DoctorPatient"> | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "doctor_id_patient_id">

  export type DoctorPatientOrderByWithAggregationInput = {
    doctor_id?: SortOrder
    patient_id?: SortOrder
    _count?: DoctorPatientCountOrderByAggregateInput
    _max?: DoctorPatientMaxOrderByAggregateInput
    _min?: DoctorPatientMinOrderByAggregateInput
  }

  export type DoctorPatientScalarWhereWithAggregatesInput = {
    AND?: DoctorPatientScalarWhereWithAggregatesInput | DoctorPatientScalarWhereWithAggregatesInput[]
    OR?: DoctorPatientScalarWhereWithAggregatesInput[]
    NOT?: DoctorPatientScalarWhereWithAggregatesInput | DoctorPatientScalarWhereWithAggregatesInput[]
    doctor_id?: StringWithAggregatesFilter<"DoctorPatient"> | string
    patient_id?: StringWithAggregatesFilter<"DoctorPatient"> | string
  }

  export type CuisineWhereInput = {
    AND?: CuisineWhereInput | CuisineWhereInput[]
    OR?: CuisineWhereInput[]
    NOT?: CuisineWhereInput | CuisineWhereInput[]
    cuisine_id?: StringFilter<"Cuisine"> | string
    name?: StringFilter<"Cuisine"> | string
    Recipe?: RecipeListRelationFilter
  }

  export type CuisineOrderByWithRelationInput = {
    cuisine_id?: SortOrder
    name?: SortOrder
    Recipe?: RecipeOrderByRelationAggregateInput
  }

  export type CuisineWhereUniqueInput = Prisma.AtLeast<{
    cuisine_id?: string
    AND?: CuisineWhereInput | CuisineWhereInput[]
    OR?: CuisineWhereInput[]
    NOT?: CuisineWhereInput | CuisineWhereInput[]
    name?: StringFilter<"Cuisine"> | string
    Recipe?: RecipeListRelationFilter
  }, "cuisine_id">

  export type CuisineOrderByWithAggregationInput = {
    cuisine_id?: SortOrder
    name?: SortOrder
    _count?: CuisineCountOrderByAggregateInput
    _max?: CuisineMaxOrderByAggregateInput
    _min?: CuisineMinOrderByAggregateInput
  }

  export type CuisineScalarWhereWithAggregatesInput = {
    AND?: CuisineScalarWhereWithAggregatesInput | CuisineScalarWhereWithAggregatesInput[]
    OR?: CuisineScalarWhereWithAggregatesInput[]
    NOT?: CuisineScalarWhereWithAggregatesInput | CuisineScalarWhereWithAggregatesInput[]
    cuisine_id?: StringWithAggregatesFilter<"Cuisine"> | string
    name?: StringWithAggregatesFilter<"Cuisine"> | string
  }

  export type FoodWhereInput = {
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    food_id?: StringFilter<"Food"> | string
    name?: StringFilter<"Food"> | string
    hindi_name?: StringNullableFilter<"Food"> | string | null
    FoodNutrient?: FoodNutrientListRelationFilter
    FoodRasa?: FoodRasaListRelationFilter
    FoodGuna?: FoodGunaListRelationFilter
    FoodDosha?: FoodDoshaListRelationFilter
    FoodVirya?: FoodViryaListRelationFilter
    FoodVipaka?: FoodVipakaListRelationFilter
    FoodDigestibility?: FoodDigestibilityListRelationFilter
    RecipeIngredient?: RecipeIngredientListRelationFilter
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }

  export type FoodOrderByWithRelationInput = {
    food_id?: SortOrder
    name?: SortOrder
    hindi_name?: SortOrderInput | SortOrder
    FoodNutrient?: FoodNutrientOrderByRelationAggregateInput
    FoodRasa?: FoodRasaOrderByRelationAggregateInput
    FoodGuna?: FoodGunaOrderByRelationAggregateInput
    FoodDosha?: FoodDoshaOrderByRelationAggregateInput
    FoodVirya?: FoodViryaOrderByRelationAggregateInput
    FoodVipaka?: FoodVipakaOrderByRelationAggregateInput
    FoodDigestibility?: FoodDigestibilityOrderByRelationAggregateInput
    RecipeIngredient?: RecipeIngredientOrderByRelationAggregateInput
    DietChartRecipe?: DietChartRecipeOrderByRelationAggregateInput
  }

  export type FoodWhereUniqueInput = Prisma.AtLeast<{
    food_id?: string
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    name?: StringFilter<"Food"> | string
    hindi_name?: StringNullableFilter<"Food"> | string | null
    FoodNutrient?: FoodNutrientListRelationFilter
    FoodRasa?: FoodRasaListRelationFilter
    FoodGuna?: FoodGunaListRelationFilter
    FoodDosha?: FoodDoshaListRelationFilter
    FoodVirya?: FoodViryaListRelationFilter
    FoodVipaka?: FoodVipakaListRelationFilter
    FoodDigestibility?: FoodDigestibilityListRelationFilter
    RecipeIngredient?: RecipeIngredientListRelationFilter
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }, "food_id">

  export type FoodOrderByWithAggregationInput = {
    food_id?: SortOrder
    name?: SortOrder
    hindi_name?: SortOrderInput | SortOrder
    _count?: FoodCountOrderByAggregateInput
    _max?: FoodMaxOrderByAggregateInput
    _min?: FoodMinOrderByAggregateInput
  }

  export type FoodScalarWhereWithAggregatesInput = {
    AND?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    OR?: FoodScalarWhereWithAggregatesInput[]
    NOT?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"Food"> | string
    name?: StringWithAggregatesFilter<"Food"> | string
    hindi_name?: StringNullableWithAggregatesFilter<"Food"> | string | null
  }

  export type NutrientWhereInput = {
    AND?: NutrientWhereInput | NutrientWhereInput[]
    OR?: NutrientWhereInput[]
    NOT?: NutrientWhereInput | NutrientWhereInput[]
    nutrient_id?: StringFilter<"Nutrient"> | string
    name?: StringFilter<"Nutrient"> | string
    unit?: StringFilter<"Nutrient"> | string
    FoodNutrient?: FoodNutrientListRelationFilter
    Rda?: RdaListRelationFilter
  }

  export type NutrientOrderByWithRelationInput = {
    nutrient_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    FoodNutrient?: FoodNutrientOrderByRelationAggregateInput
    Rda?: RdaOrderByRelationAggregateInput
  }

  export type NutrientWhereUniqueInput = Prisma.AtLeast<{
    nutrient_id?: string
    AND?: NutrientWhereInput | NutrientWhereInput[]
    OR?: NutrientWhereInput[]
    NOT?: NutrientWhereInput | NutrientWhereInput[]
    name?: StringFilter<"Nutrient"> | string
    unit?: StringFilter<"Nutrient"> | string
    FoodNutrient?: FoodNutrientListRelationFilter
    Rda?: RdaListRelationFilter
  }, "nutrient_id">

  export type NutrientOrderByWithAggregationInput = {
    nutrient_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    _count?: NutrientCountOrderByAggregateInput
    _max?: NutrientMaxOrderByAggregateInput
    _min?: NutrientMinOrderByAggregateInput
  }

  export type NutrientScalarWhereWithAggregatesInput = {
    AND?: NutrientScalarWhereWithAggregatesInput | NutrientScalarWhereWithAggregatesInput[]
    OR?: NutrientScalarWhereWithAggregatesInput[]
    NOT?: NutrientScalarWhereWithAggregatesInput | NutrientScalarWhereWithAggregatesInput[]
    nutrient_id?: StringWithAggregatesFilter<"Nutrient"> | string
    name?: StringWithAggregatesFilter<"Nutrient"> | string
    unit?: StringWithAggregatesFilter<"Nutrient"> | string
  }

  export type RasaWhereInput = {
    AND?: RasaWhereInput | RasaWhereInput[]
    OR?: RasaWhereInput[]
    NOT?: RasaWhereInput | RasaWhereInput[]
    rasa_id?: StringFilter<"Rasa"> | string
    name?: StringFilter<"Rasa"> | string
    FoodRasa?: FoodRasaListRelationFilter
  }

  export type RasaOrderByWithRelationInput = {
    rasa_id?: SortOrder
    name?: SortOrder
    FoodRasa?: FoodRasaOrderByRelationAggregateInput
  }

  export type RasaWhereUniqueInput = Prisma.AtLeast<{
    rasa_id?: string
    name?: string
    AND?: RasaWhereInput | RasaWhereInput[]
    OR?: RasaWhereInput[]
    NOT?: RasaWhereInput | RasaWhereInput[]
    FoodRasa?: FoodRasaListRelationFilter
  }, "rasa_id" | "name">

  export type RasaOrderByWithAggregationInput = {
    rasa_id?: SortOrder
    name?: SortOrder
    _count?: RasaCountOrderByAggregateInput
    _max?: RasaMaxOrderByAggregateInput
    _min?: RasaMinOrderByAggregateInput
  }

  export type RasaScalarWhereWithAggregatesInput = {
    AND?: RasaScalarWhereWithAggregatesInput | RasaScalarWhereWithAggregatesInput[]
    OR?: RasaScalarWhereWithAggregatesInput[]
    NOT?: RasaScalarWhereWithAggregatesInput | RasaScalarWhereWithAggregatesInput[]
    rasa_id?: StringWithAggregatesFilter<"Rasa"> | string
    name?: StringWithAggregatesFilter<"Rasa"> | string
  }

  export type GunaWhereInput = {
    AND?: GunaWhereInput | GunaWhereInput[]
    OR?: GunaWhereInput[]
    NOT?: GunaWhereInput | GunaWhereInput[]
    guna_id?: StringFilter<"Guna"> | string
    name?: StringFilter<"Guna"> | string
    FoodGuna?: FoodGunaListRelationFilter
  }

  export type GunaOrderByWithRelationInput = {
    guna_id?: SortOrder
    name?: SortOrder
    FoodGuna?: FoodGunaOrderByRelationAggregateInput
  }

  export type GunaWhereUniqueInput = Prisma.AtLeast<{
    guna_id?: string
    name?: string
    AND?: GunaWhereInput | GunaWhereInput[]
    OR?: GunaWhereInput[]
    NOT?: GunaWhereInput | GunaWhereInput[]
    FoodGuna?: FoodGunaListRelationFilter
  }, "guna_id" | "name">

  export type GunaOrderByWithAggregationInput = {
    guna_id?: SortOrder
    name?: SortOrder
    _count?: GunaCountOrderByAggregateInput
    _max?: GunaMaxOrderByAggregateInput
    _min?: GunaMinOrderByAggregateInput
  }

  export type GunaScalarWhereWithAggregatesInput = {
    AND?: GunaScalarWhereWithAggregatesInput | GunaScalarWhereWithAggregatesInput[]
    OR?: GunaScalarWhereWithAggregatesInput[]
    NOT?: GunaScalarWhereWithAggregatesInput | GunaScalarWhereWithAggregatesInput[]
    guna_id?: StringWithAggregatesFilter<"Guna"> | string
    name?: StringWithAggregatesFilter<"Guna"> | string
  }

  export type DoshaWhereInput = {
    AND?: DoshaWhereInput | DoshaWhereInput[]
    OR?: DoshaWhereInput[]
    NOT?: DoshaWhereInput | DoshaWhereInput[]
    dosha_id?: StringFilter<"Dosha"> | string
    name?: StringFilter<"Dosha"> | string
    FoodDosha?: FoodDoshaListRelationFilter
    PatientDosha?: PatientDoshaListRelationFilter
  }

  export type DoshaOrderByWithRelationInput = {
    dosha_id?: SortOrder
    name?: SortOrder
    FoodDosha?: FoodDoshaOrderByRelationAggregateInput
    PatientDosha?: PatientDoshaOrderByRelationAggregateInput
  }

  export type DoshaWhereUniqueInput = Prisma.AtLeast<{
    dosha_id?: string
    name?: string
    AND?: DoshaWhereInput | DoshaWhereInput[]
    OR?: DoshaWhereInput[]
    NOT?: DoshaWhereInput | DoshaWhereInput[]
    FoodDosha?: FoodDoshaListRelationFilter
    PatientDosha?: PatientDoshaListRelationFilter
  }, "dosha_id" | "name">

  export type DoshaOrderByWithAggregationInput = {
    dosha_id?: SortOrder
    name?: SortOrder
    _count?: DoshaCountOrderByAggregateInput
    _max?: DoshaMaxOrderByAggregateInput
    _min?: DoshaMinOrderByAggregateInput
  }

  export type DoshaScalarWhereWithAggregatesInput = {
    AND?: DoshaScalarWhereWithAggregatesInput | DoshaScalarWhereWithAggregatesInput[]
    OR?: DoshaScalarWhereWithAggregatesInput[]
    NOT?: DoshaScalarWhereWithAggregatesInput | DoshaScalarWhereWithAggregatesInput[]
    dosha_id?: StringWithAggregatesFilter<"Dosha"> | string
    name?: StringWithAggregatesFilter<"Dosha"> | string
  }

  export type ViryaWhereInput = {
    AND?: ViryaWhereInput | ViryaWhereInput[]
    OR?: ViryaWhereInput[]
    NOT?: ViryaWhereInput | ViryaWhereInput[]
    virya_id?: StringFilter<"Virya"> | string
    name?: StringFilter<"Virya"> | string
    FoodVirya?: FoodViryaListRelationFilter
  }

  export type ViryaOrderByWithRelationInput = {
    virya_id?: SortOrder
    name?: SortOrder
    FoodVirya?: FoodViryaOrderByRelationAggregateInput
  }

  export type ViryaWhereUniqueInput = Prisma.AtLeast<{
    virya_id?: string
    name?: string
    AND?: ViryaWhereInput | ViryaWhereInput[]
    OR?: ViryaWhereInput[]
    NOT?: ViryaWhereInput | ViryaWhereInput[]
    FoodVirya?: FoodViryaListRelationFilter
  }, "virya_id" | "name">

  export type ViryaOrderByWithAggregationInput = {
    virya_id?: SortOrder
    name?: SortOrder
    _count?: ViryaCountOrderByAggregateInput
    _max?: ViryaMaxOrderByAggregateInput
    _min?: ViryaMinOrderByAggregateInput
  }

  export type ViryaScalarWhereWithAggregatesInput = {
    AND?: ViryaScalarWhereWithAggregatesInput | ViryaScalarWhereWithAggregatesInput[]
    OR?: ViryaScalarWhereWithAggregatesInput[]
    NOT?: ViryaScalarWhereWithAggregatesInput | ViryaScalarWhereWithAggregatesInput[]
    virya_id?: StringWithAggregatesFilter<"Virya"> | string
    name?: StringWithAggregatesFilter<"Virya"> | string
  }

  export type VipakaWhereInput = {
    AND?: VipakaWhereInput | VipakaWhereInput[]
    OR?: VipakaWhereInput[]
    NOT?: VipakaWhereInput | VipakaWhereInput[]
    vipaka_id?: StringFilter<"Vipaka"> | string
    name?: StringFilter<"Vipaka"> | string
    FoodVipaka?: FoodVipakaListRelationFilter
  }

  export type VipakaOrderByWithRelationInput = {
    vipaka_id?: SortOrder
    name?: SortOrder
    FoodVipaka?: FoodVipakaOrderByRelationAggregateInput
  }

  export type VipakaWhereUniqueInput = Prisma.AtLeast<{
    vipaka_id?: string
    name?: string
    AND?: VipakaWhereInput | VipakaWhereInput[]
    OR?: VipakaWhereInput[]
    NOT?: VipakaWhereInput | VipakaWhereInput[]
    FoodVipaka?: FoodVipakaListRelationFilter
  }, "vipaka_id" | "name">

  export type VipakaOrderByWithAggregationInput = {
    vipaka_id?: SortOrder
    name?: SortOrder
    _count?: VipakaCountOrderByAggregateInput
    _max?: VipakaMaxOrderByAggregateInput
    _min?: VipakaMinOrderByAggregateInput
  }

  export type VipakaScalarWhereWithAggregatesInput = {
    AND?: VipakaScalarWhereWithAggregatesInput | VipakaScalarWhereWithAggregatesInput[]
    OR?: VipakaScalarWhereWithAggregatesInput[]
    NOT?: VipakaScalarWhereWithAggregatesInput | VipakaScalarWhereWithAggregatesInput[]
    vipaka_id?: StringWithAggregatesFilter<"Vipaka"> | string
    name?: StringWithAggregatesFilter<"Vipaka"> | string
  }

  export type DigestibilityWhereInput = {
    AND?: DigestibilityWhereInput | DigestibilityWhereInput[]
    OR?: DigestibilityWhereInput[]
    NOT?: DigestibilityWhereInput | DigestibilityWhereInput[]
    digestibility_id?: StringFilter<"Digestibility"> | string
    name?: StringFilter<"Digestibility"> | string
    FoodDigestibility?: FoodDigestibilityListRelationFilter
  }

  export type DigestibilityOrderByWithRelationInput = {
    digestibility_id?: SortOrder
    name?: SortOrder
    FoodDigestibility?: FoodDigestibilityOrderByRelationAggregateInput
  }

  export type DigestibilityWhereUniqueInput = Prisma.AtLeast<{
    digestibility_id?: string
    name?: string
    AND?: DigestibilityWhereInput | DigestibilityWhereInput[]
    OR?: DigestibilityWhereInput[]
    NOT?: DigestibilityWhereInput | DigestibilityWhereInput[]
    FoodDigestibility?: FoodDigestibilityListRelationFilter
  }, "digestibility_id" | "name">

  export type DigestibilityOrderByWithAggregationInput = {
    digestibility_id?: SortOrder
    name?: SortOrder
    _count?: DigestibilityCountOrderByAggregateInput
    _max?: DigestibilityMaxOrderByAggregateInput
    _min?: DigestibilityMinOrderByAggregateInput
  }

  export type DigestibilityScalarWhereWithAggregatesInput = {
    AND?: DigestibilityScalarWhereWithAggregatesInput | DigestibilityScalarWhereWithAggregatesInput[]
    OR?: DigestibilityScalarWhereWithAggregatesInput[]
    NOT?: DigestibilityScalarWhereWithAggregatesInput | DigestibilityScalarWhereWithAggregatesInput[]
    digestibility_id?: StringWithAggregatesFilter<"Digestibility"> | string
    name?: StringWithAggregatesFilter<"Digestibility"> | string
  }

  export type RdaWhereInput = {
    AND?: RdaWhereInput | RdaWhereInput[]
    OR?: RdaWhereInput[]
    NOT?: RdaWhereInput | RdaWhereInput[]
    rda_id?: StringFilter<"Rda"> | string
    nutrient_id?: StringFilter<"Rda"> | string
    age_group?: EnumAgeGroupFilter<"Rda"> | $Enums.AgeGroup
    gender?: EnumGenderFilter<"Rda"> | $Enums.Gender
    amount?: FloatFilter<"Rda"> | number
    Nutrient?: XOR<NutrientScalarRelationFilter, NutrientWhereInput>
  }

  export type RdaOrderByWithRelationInput = {
    rda_id?: SortOrder
    nutrient_id?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    amount?: SortOrder
    Nutrient?: NutrientOrderByWithRelationInput
  }

  export type RdaWhereUniqueInput = Prisma.AtLeast<{
    rda_id?: string
    AND?: RdaWhereInput | RdaWhereInput[]
    OR?: RdaWhereInput[]
    NOT?: RdaWhereInput | RdaWhereInput[]
    nutrient_id?: StringFilter<"Rda"> | string
    age_group?: EnumAgeGroupFilter<"Rda"> | $Enums.AgeGroup
    gender?: EnumGenderFilter<"Rda"> | $Enums.Gender
    amount?: FloatFilter<"Rda"> | number
    Nutrient?: XOR<NutrientScalarRelationFilter, NutrientWhereInput>
  }, "rda_id">

  export type RdaOrderByWithAggregationInput = {
    rda_id?: SortOrder
    nutrient_id?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    amount?: SortOrder
    _count?: RdaCountOrderByAggregateInput
    _avg?: RdaAvgOrderByAggregateInput
    _max?: RdaMaxOrderByAggregateInput
    _min?: RdaMinOrderByAggregateInput
    _sum?: RdaSumOrderByAggregateInput
  }

  export type RdaScalarWhereWithAggregatesInput = {
    AND?: RdaScalarWhereWithAggregatesInput | RdaScalarWhereWithAggregatesInput[]
    OR?: RdaScalarWhereWithAggregatesInput[]
    NOT?: RdaScalarWhereWithAggregatesInput | RdaScalarWhereWithAggregatesInput[]
    rda_id?: StringWithAggregatesFilter<"Rda"> | string
    nutrient_id?: StringWithAggregatesFilter<"Rda"> | string
    age_group?: EnumAgeGroupWithAggregatesFilter<"Rda"> | $Enums.AgeGroup
    gender?: EnumGenderWithAggregatesFilter<"Rda"> | $Enums.Gender
    amount?: FloatWithAggregatesFilter<"Rda"> | number
  }

  export type FoodNutrientWhereInput = {
    AND?: FoodNutrientWhereInput | FoodNutrientWhereInput[]
    OR?: FoodNutrientWhereInput[]
    NOT?: FoodNutrientWhereInput | FoodNutrientWhereInput[]
    food_id?: StringFilter<"FoodNutrient"> | string
    nutrient_id?: StringFilter<"FoodNutrient"> | string
    amount?: FloatFilter<"FoodNutrient"> | number
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    nutrient?: XOR<NutrientScalarRelationFilter, NutrientWhereInput>
  }

  export type FoodNutrientOrderByWithRelationInput = {
    food_id?: SortOrder
    nutrient_id?: SortOrder
    amount?: SortOrder
    food?: FoodOrderByWithRelationInput
    nutrient?: NutrientOrderByWithRelationInput
  }

  export type FoodNutrientWhereUniqueInput = Prisma.AtLeast<{
    food_id_nutrient_id?: FoodNutrientFood_idNutrient_idCompoundUniqueInput
    AND?: FoodNutrientWhereInput | FoodNutrientWhereInput[]
    OR?: FoodNutrientWhereInput[]
    NOT?: FoodNutrientWhereInput | FoodNutrientWhereInput[]
    food_id?: StringFilter<"FoodNutrient"> | string
    nutrient_id?: StringFilter<"FoodNutrient"> | string
    amount?: FloatFilter<"FoodNutrient"> | number
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    nutrient?: XOR<NutrientScalarRelationFilter, NutrientWhereInput>
  }, "food_id_nutrient_id">

  export type FoodNutrientOrderByWithAggregationInput = {
    food_id?: SortOrder
    nutrient_id?: SortOrder
    amount?: SortOrder
    _count?: FoodNutrientCountOrderByAggregateInput
    _avg?: FoodNutrientAvgOrderByAggregateInput
    _max?: FoodNutrientMaxOrderByAggregateInput
    _min?: FoodNutrientMinOrderByAggregateInput
    _sum?: FoodNutrientSumOrderByAggregateInput
  }

  export type FoodNutrientScalarWhereWithAggregatesInput = {
    AND?: FoodNutrientScalarWhereWithAggregatesInput | FoodNutrientScalarWhereWithAggregatesInput[]
    OR?: FoodNutrientScalarWhereWithAggregatesInput[]
    NOT?: FoodNutrientScalarWhereWithAggregatesInput | FoodNutrientScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodNutrient"> | string
    nutrient_id?: StringWithAggregatesFilter<"FoodNutrient"> | string
    amount?: FloatWithAggregatesFilter<"FoodNutrient"> | number
  }

  export type FoodRasaWhereInput = {
    AND?: FoodRasaWhereInput | FoodRasaWhereInput[]
    OR?: FoodRasaWhereInput[]
    NOT?: FoodRasaWhereInput | FoodRasaWhereInput[]
    food_id?: StringFilter<"FoodRasa"> | string
    rasa_id?: StringFilter<"FoodRasa"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    rasa?: XOR<RasaScalarRelationFilter, RasaWhereInput>
  }

  export type FoodRasaOrderByWithRelationInput = {
    food_id?: SortOrder
    rasa_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    rasa?: RasaOrderByWithRelationInput
  }

  export type FoodRasaWhereUniqueInput = Prisma.AtLeast<{
    food_id_rasa_id?: FoodRasaFood_idRasa_idCompoundUniqueInput
    AND?: FoodRasaWhereInput | FoodRasaWhereInput[]
    OR?: FoodRasaWhereInput[]
    NOT?: FoodRasaWhereInput | FoodRasaWhereInput[]
    food_id?: StringFilter<"FoodRasa"> | string
    rasa_id?: StringFilter<"FoodRasa"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    rasa?: XOR<RasaScalarRelationFilter, RasaWhereInput>
  }, "food_id_rasa_id">

  export type FoodRasaOrderByWithAggregationInput = {
    food_id?: SortOrder
    rasa_id?: SortOrder
    _count?: FoodRasaCountOrderByAggregateInput
    _max?: FoodRasaMaxOrderByAggregateInput
    _min?: FoodRasaMinOrderByAggregateInput
  }

  export type FoodRasaScalarWhereWithAggregatesInput = {
    AND?: FoodRasaScalarWhereWithAggregatesInput | FoodRasaScalarWhereWithAggregatesInput[]
    OR?: FoodRasaScalarWhereWithAggregatesInput[]
    NOT?: FoodRasaScalarWhereWithAggregatesInput | FoodRasaScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodRasa"> | string
    rasa_id?: StringWithAggregatesFilter<"FoodRasa"> | string
  }

  export type FoodGunaWhereInput = {
    AND?: FoodGunaWhereInput | FoodGunaWhereInput[]
    OR?: FoodGunaWhereInput[]
    NOT?: FoodGunaWhereInput | FoodGunaWhereInput[]
    food_id?: StringFilter<"FoodGuna"> | string
    guna_id?: StringFilter<"FoodGuna"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    guna?: XOR<GunaScalarRelationFilter, GunaWhereInput>
  }

  export type FoodGunaOrderByWithRelationInput = {
    food_id?: SortOrder
    guna_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    guna?: GunaOrderByWithRelationInput
  }

  export type FoodGunaWhereUniqueInput = Prisma.AtLeast<{
    food_id_guna_id?: FoodGunaFood_idGuna_idCompoundUniqueInput
    AND?: FoodGunaWhereInput | FoodGunaWhereInput[]
    OR?: FoodGunaWhereInput[]
    NOT?: FoodGunaWhereInput | FoodGunaWhereInput[]
    food_id?: StringFilter<"FoodGuna"> | string
    guna_id?: StringFilter<"FoodGuna"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    guna?: XOR<GunaScalarRelationFilter, GunaWhereInput>
  }, "food_id_guna_id">

  export type FoodGunaOrderByWithAggregationInput = {
    food_id?: SortOrder
    guna_id?: SortOrder
    _count?: FoodGunaCountOrderByAggregateInput
    _max?: FoodGunaMaxOrderByAggregateInput
    _min?: FoodGunaMinOrderByAggregateInput
  }

  export type FoodGunaScalarWhereWithAggregatesInput = {
    AND?: FoodGunaScalarWhereWithAggregatesInput | FoodGunaScalarWhereWithAggregatesInput[]
    OR?: FoodGunaScalarWhereWithAggregatesInput[]
    NOT?: FoodGunaScalarWhereWithAggregatesInput | FoodGunaScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodGuna"> | string
    guna_id?: StringWithAggregatesFilter<"FoodGuna"> | string
  }

  export type FoodDoshaWhereInput = {
    AND?: FoodDoshaWhereInput | FoodDoshaWhereInput[]
    OR?: FoodDoshaWhereInput[]
    NOT?: FoodDoshaWhereInput | FoodDoshaWhereInput[]
    food_id?: StringFilter<"FoodDosha"> | string
    dosha_id?: StringFilter<"FoodDosha"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    dosha?: XOR<DoshaScalarRelationFilter, DoshaWhereInput>
  }

  export type FoodDoshaOrderByWithRelationInput = {
    food_id?: SortOrder
    dosha_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    dosha?: DoshaOrderByWithRelationInput
  }

  export type FoodDoshaWhereUniqueInput = Prisma.AtLeast<{
    food_id_dosha_id?: FoodDoshaFood_idDosha_idCompoundUniqueInput
    AND?: FoodDoshaWhereInput | FoodDoshaWhereInput[]
    OR?: FoodDoshaWhereInput[]
    NOT?: FoodDoshaWhereInput | FoodDoshaWhereInput[]
    food_id?: StringFilter<"FoodDosha"> | string
    dosha_id?: StringFilter<"FoodDosha"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    dosha?: XOR<DoshaScalarRelationFilter, DoshaWhereInput>
  }, "food_id_dosha_id">

  export type FoodDoshaOrderByWithAggregationInput = {
    food_id?: SortOrder
    dosha_id?: SortOrder
    _count?: FoodDoshaCountOrderByAggregateInput
    _max?: FoodDoshaMaxOrderByAggregateInput
    _min?: FoodDoshaMinOrderByAggregateInput
  }

  export type FoodDoshaScalarWhereWithAggregatesInput = {
    AND?: FoodDoshaScalarWhereWithAggregatesInput | FoodDoshaScalarWhereWithAggregatesInput[]
    OR?: FoodDoshaScalarWhereWithAggregatesInput[]
    NOT?: FoodDoshaScalarWhereWithAggregatesInput | FoodDoshaScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodDosha"> | string
    dosha_id?: StringWithAggregatesFilter<"FoodDosha"> | string
  }

  export type PatientDoshaWhereInput = {
    AND?: PatientDoshaWhereInput | PatientDoshaWhereInput[]
    OR?: PatientDoshaWhereInput[]
    NOT?: PatientDoshaWhereInput | PatientDoshaWhereInput[]
    patient_id?: StringFilter<"PatientDosha"> | string
    dosha_id?: StringFilter<"PatientDosha"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dosha?: XOR<DoshaScalarRelationFilter, DoshaWhereInput>
  }

  export type PatientDoshaOrderByWithRelationInput = {
    patient_id?: SortOrder
    dosha_id?: SortOrder
    patient?: PatientOrderByWithRelationInput
    dosha?: DoshaOrderByWithRelationInput
  }

  export type PatientDoshaWhereUniqueInput = Prisma.AtLeast<{
    patient_id_dosha_id?: PatientDoshaPatient_idDosha_idCompoundUniqueInput
    AND?: PatientDoshaWhereInput | PatientDoshaWhereInput[]
    OR?: PatientDoshaWhereInput[]
    NOT?: PatientDoshaWhereInput | PatientDoshaWhereInput[]
    patient_id?: StringFilter<"PatientDosha"> | string
    dosha_id?: StringFilter<"PatientDosha"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dosha?: XOR<DoshaScalarRelationFilter, DoshaWhereInput>
  }, "patient_id_dosha_id">

  export type PatientDoshaOrderByWithAggregationInput = {
    patient_id?: SortOrder
    dosha_id?: SortOrder
    _count?: PatientDoshaCountOrderByAggregateInput
    _max?: PatientDoshaMaxOrderByAggregateInput
    _min?: PatientDoshaMinOrderByAggregateInput
  }

  export type PatientDoshaScalarWhereWithAggregatesInput = {
    AND?: PatientDoshaScalarWhereWithAggregatesInput | PatientDoshaScalarWhereWithAggregatesInput[]
    OR?: PatientDoshaScalarWhereWithAggregatesInput[]
    NOT?: PatientDoshaScalarWhereWithAggregatesInput | PatientDoshaScalarWhereWithAggregatesInput[]
    patient_id?: StringWithAggregatesFilter<"PatientDosha"> | string
    dosha_id?: StringWithAggregatesFilter<"PatientDosha"> | string
  }

  export type FoodViryaWhereInput = {
    AND?: FoodViryaWhereInput | FoodViryaWhereInput[]
    OR?: FoodViryaWhereInput[]
    NOT?: FoodViryaWhereInput | FoodViryaWhereInput[]
    food_id?: StringFilter<"FoodVirya"> | string
    virya_id?: StringFilter<"FoodVirya"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    virya?: XOR<ViryaScalarRelationFilter, ViryaWhereInput>
  }

  export type FoodViryaOrderByWithRelationInput = {
    food_id?: SortOrder
    virya_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    virya?: ViryaOrderByWithRelationInput
  }

  export type FoodViryaWhereUniqueInput = Prisma.AtLeast<{
    food_id_virya_id?: FoodViryaFood_idVirya_idCompoundUniqueInput
    AND?: FoodViryaWhereInput | FoodViryaWhereInput[]
    OR?: FoodViryaWhereInput[]
    NOT?: FoodViryaWhereInput | FoodViryaWhereInput[]
    food_id?: StringFilter<"FoodVirya"> | string
    virya_id?: StringFilter<"FoodVirya"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    virya?: XOR<ViryaScalarRelationFilter, ViryaWhereInput>
  }, "food_id_virya_id">

  export type FoodViryaOrderByWithAggregationInput = {
    food_id?: SortOrder
    virya_id?: SortOrder
    _count?: FoodViryaCountOrderByAggregateInput
    _max?: FoodViryaMaxOrderByAggregateInput
    _min?: FoodViryaMinOrderByAggregateInput
  }

  export type FoodViryaScalarWhereWithAggregatesInput = {
    AND?: FoodViryaScalarWhereWithAggregatesInput | FoodViryaScalarWhereWithAggregatesInput[]
    OR?: FoodViryaScalarWhereWithAggregatesInput[]
    NOT?: FoodViryaScalarWhereWithAggregatesInput | FoodViryaScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodVirya"> | string
    virya_id?: StringWithAggregatesFilter<"FoodVirya"> | string
  }

  export type FoodVipakaWhereInput = {
    AND?: FoodVipakaWhereInput | FoodVipakaWhereInput[]
    OR?: FoodVipakaWhereInput[]
    NOT?: FoodVipakaWhereInput | FoodVipakaWhereInput[]
    food_id?: StringFilter<"FoodVipaka"> | string
    vipaka_id?: StringFilter<"FoodVipaka"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    vipaka?: XOR<VipakaScalarRelationFilter, VipakaWhereInput>
  }

  export type FoodVipakaOrderByWithRelationInput = {
    food_id?: SortOrder
    vipaka_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    vipaka?: VipakaOrderByWithRelationInput
  }

  export type FoodVipakaWhereUniqueInput = Prisma.AtLeast<{
    food_id?: string
    AND?: FoodVipakaWhereInput | FoodVipakaWhereInput[]
    OR?: FoodVipakaWhereInput[]
    NOT?: FoodVipakaWhereInput | FoodVipakaWhereInput[]
    vipaka_id?: StringFilter<"FoodVipaka"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    vipaka?: XOR<VipakaScalarRelationFilter, VipakaWhereInput>
  }, "food_id">

  export type FoodVipakaOrderByWithAggregationInput = {
    food_id?: SortOrder
    vipaka_id?: SortOrder
    _count?: FoodVipakaCountOrderByAggregateInput
    _max?: FoodVipakaMaxOrderByAggregateInput
    _min?: FoodVipakaMinOrderByAggregateInput
  }

  export type FoodVipakaScalarWhereWithAggregatesInput = {
    AND?: FoodVipakaScalarWhereWithAggregatesInput | FoodVipakaScalarWhereWithAggregatesInput[]
    OR?: FoodVipakaScalarWhereWithAggregatesInput[]
    NOT?: FoodVipakaScalarWhereWithAggregatesInput | FoodVipakaScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodVipaka"> | string
    vipaka_id?: StringWithAggregatesFilter<"FoodVipaka"> | string
  }

  export type FoodDigestibilityWhereInput = {
    AND?: FoodDigestibilityWhereInput | FoodDigestibilityWhereInput[]
    OR?: FoodDigestibilityWhereInput[]
    NOT?: FoodDigestibilityWhereInput | FoodDigestibilityWhereInput[]
    food_id?: StringFilter<"FoodDigestibility"> | string
    digestibility_id?: StringFilter<"FoodDigestibility"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    digestibility?: XOR<DigestibilityScalarRelationFilter, DigestibilityWhereInput>
  }

  export type FoodDigestibilityOrderByWithRelationInput = {
    food_id?: SortOrder
    digestibility_id?: SortOrder
    food?: FoodOrderByWithRelationInput
    digestibility?: DigestibilityOrderByWithRelationInput
  }

  export type FoodDigestibilityWhereUniqueInput = Prisma.AtLeast<{
    food_id?: string
    AND?: FoodDigestibilityWhereInput | FoodDigestibilityWhereInput[]
    OR?: FoodDigestibilityWhereInput[]
    NOT?: FoodDigestibilityWhereInput | FoodDigestibilityWhereInput[]
    digestibility_id?: StringFilter<"FoodDigestibility"> | string
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
    digestibility?: XOR<DigestibilityScalarRelationFilter, DigestibilityWhereInput>
  }, "food_id">

  export type FoodDigestibilityOrderByWithAggregationInput = {
    food_id?: SortOrder
    digestibility_id?: SortOrder
    _count?: FoodDigestibilityCountOrderByAggregateInput
    _max?: FoodDigestibilityMaxOrderByAggregateInput
    _min?: FoodDigestibilityMinOrderByAggregateInput
  }

  export type FoodDigestibilityScalarWhereWithAggregatesInput = {
    AND?: FoodDigestibilityScalarWhereWithAggregatesInput | FoodDigestibilityScalarWhereWithAggregatesInput[]
    OR?: FoodDigestibilityScalarWhereWithAggregatesInput[]
    NOT?: FoodDigestibilityScalarWhereWithAggregatesInput | FoodDigestibilityScalarWhereWithAggregatesInput[]
    food_id?: StringWithAggregatesFilter<"FoodDigestibility"> | string
    digestibility_id?: StringWithAggregatesFilter<"FoodDigestibility"> | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    recipe_id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    cuisine_id?: StringFilter<"Recipe"> | string
    Cuisine?: XOR<CuisineScalarRelationFilter, CuisineWhereInput>
    RecipeIngredient?: RecipeIngredientListRelationFilter
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    recipe_id?: SortOrder
    name?: SortOrder
    cuisine_id?: SortOrder
    Cuisine?: CuisineOrderByWithRelationInput
    RecipeIngredient?: RecipeIngredientOrderByRelationAggregateInput
    DietChartRecipe?: DietChartRecipeOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    recipe_id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    cuisine_id?: StringFilter<"Recipe"> | string
    Cuisine?: XOR<CuisineScalarRelationFilter, CuisineWhereInput>
    RecipeIngredient?: RecipeIngredientListRelationFilter
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }, "recipe_id">

  export type RecipeOrderByWithAggregationInput = {
    recipe_id?: SortOrder
    name?: SortOrder
    cuisine_id?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    recipe_id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    cuisine_id?: StringWithAggregatesFilter<"Recipe"> | string
  }

  export type RecipeIngredientWhereInput = {
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipe_id?: StringFilter<"RecipeIngredient"> | string
    food_id?: StringFilter<"RecipeIngredient"> | string
    quantity?: FloatFilter<"RecipeIngredient"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
  }

  export type RecipeIngredientOrderByWithRelationInput = {
    recipe_id?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    food?: FoodOrderByWithRelationInput
  }

  export type RecipeIngredientWhereUniqueInput = Prisma.AtLeast<{
    recipe_id_food_id?: RecipeIngredientRecipe_idFood_idCompoundUniqueInput
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipe_id?: StringFilter<"RecipeIngredient"> | string
    food_id?: StringFilter<"RecipeIngredient"> | string
    quantity?: FloatFilter<"RecipeIngredient"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    food?: XOR<FoodScalarRelationFilter, FoodWhereInput>
  }, "recipe_id_food_id">

  export type RecipeIngredientOrderByWithAggregationInput = {
    recipe_id?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
    _count?: RecipeIngredientCountOrderByAggregateInput
    _avg?: RecipeIngredientAvgOrderByAggregateInput
    _max?: RecipeIngredientMaxOrderByAggregateInput
    _min?: RecipeIngredientMinOrderByAggregateInput
    _sum?: RecipeIngredientSumOrderByAggregateInput
  }

  export type RecipeIngredientScalarWhereWithAggregatesInput = {
    AND?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    OR?: RecipeIngredientScalarWhereWithAggregatesInput[]
    NOT?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    recipe_id?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    food_id?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    quantity?: FloatWithAggregatesFilter<"RecipeIngredient"> | number
  }

  export type DietChartWhereInput = {
    AND?: DietChartWhereInput | DietChartWhereInput[]
    OR?: DietChartWhereInput[]
    NOT?: DietChartWhereInput | DietChartWhereInput[]
    chart_id?: StringFilter<"DietChart"> | string
    name?: StringFilter<"DietChart"> | string
    description?: StringNullableFilter<"DietChart"> | string | null
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }

  export type DietChartOrderByWithRelationInput = {
    chart_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    DietChartRecipe?: DietChartRecipeOrderByRelationAggregateInput
  }

  export type DietChartWhereUniqueInput = Prisma.AtLeast<{
    chart_id?: string
    AND?: DietChartWhereInput | DietChartWhereInput[]
    OR?: DietChartWhereInput[]
    NOT?: DietChartWhereInput | DietChartWhereInput[]
    name?: StringFilter<"DietChart"> | string
    description?: StringNullableFilter<"DietChart"> | string | null
    DietChartRecipe?: DietChartRecipeListRelationFilter
  }, "chart_id">

  export type DietChartOrderByWithAggregationInput = {
    chart_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: DietChartCountOrderByAggregateInput
    _max?: DietChartMaxOrderByAggregateInput
    _min?: DietChartMinOrderByAggregateInput
  }

  export type DietChartScalarWhereWithAggregatesInput = {
    AND?: DietChartScalarWhereWithAggregatesInput | DietChartScalarWhereWithAggregatesInput[]
    OR?: DietChartScalarWhereWithAggregatesInput[]
    NOT?: DietChartScalarWhereWithAggregatesInput | DietChartScalarWhereWithAggregatesInput[]
    chart_id?: StringWithAggregatesFilter<"DietChart"> | string
    name?: StringWithAggregatesFilter<"DietChart"> | string
    description?: StringNullableWithAggregatesFilter<"DietChart"> | string | null
  }

  export type DietChartRecipeWhereInput = {
    AND?: DietChartRecipeWhereInput | DietChartRecipeWhereInput[]
    OR?: DietChartRecipeWhereInput[]
    NOT?: DietChartRecipeWhereInput | DietChartRecipeWhereInput[]
    chart_id?: StringFilter<"DietChartRecipe"> | string
    recipe_id?: StringFilter<"DietChartRecipe"> | string
    mealTime?: EnumMealTimeFilter<"DietChartRecipe"> | $Enums.MealTime
    food_id?: StringNullableFilter<"DietChartRecipe"> | string | null
    quantity?: FloatNullableFilter<"DietChartRecipe"> | number | null
    dietChart?: XOR<DietChartScalarRelationFilter, DietChartWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    food?: XOR<FoodNullableScalarRelationFilter, FoodWhereInput> | null
  }

  export type DietChartRecipeOrderByWithRelationInput = {
    chart_id?: SortOrder
    recipe_id?: SortOrder
    mealTime?: SortOrder
    food_id?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    dietChart?: DietChartOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    food?: FoodOrderByWithRelationInput
  }

  export type DietChartRecipeWhereUniqueInput = Prisma.AtLeast<{
    chart_id_recipe_id?: DietChartRecipeChart_idRecipe_idCompoundUniqueInput
    AND?: DietChartRecipeWhereInput | DietChartRecipeWhereInput[]
    OR?: DietChartRecipeWhereInput[]
    NOT?: DietChartRecipeWhereInput | DietChartRecipeWhereInput[]
    chart_id?: StringFilter<"DietChartRecipe"> | string
    recipe_id?: StringFilter<"DietChartRecipe"> | string
    mealTime?: EnumMealTimeFilter<"DietChartRecipe"> | $Enums.MealTime
    food_id?: StringNullableFilter<"DietChartRecipe"> | string | null
    quantity?: FloatNullableFilter<"DietChartRecipe"> | number | null
    dietChart?: XOR<DietChartScalarRelationFilter, DietChartWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    food?: XOR<FoodNullableScalarRelationFilter, FoodWhereInput> | null
  }, "chart_id_recipe_id">

  export type DietChartRecipeOrderByWithAggregationInput = {
    chart_id?: SortOrder
    recipe_id?: SortOrder
    mealTime?: SortOrder
    food_id?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: DietChartRecipeCountOrderByAggregateInput
    _avg?: DietChartRecipeAvgOrderByAggregateInput
    _max?: DietChartRecipeMaxOrderByAggregateInput
    _min?: DietChartRecipeMinOrderByAggregateInput
    _sum?: DietChartRecipeSumOrderByAggregateInput
  }

  export type DietChartRecipeScalarWhereWithAggregatesInput = {
    AND?: DietChartRecipeScalarWhereWithAggregatesInput | DietChartRecipeScalarWhereWithAggregatesInput[]
    OR?: DietChartRecipeScalarWhereWithAggregatesInput[]
    NOT?: DietChartRecipeScalarWhereWithAggregatesInput | DietChartRecipeScalarWhereWithAggregatesInput[]
    chart_id?: StringWithAggregatesFilter<"DietChartRecipe"> | string
    recipe_id?: StringWithAggregatesFilter<"DietChartRecipe"> | string
    mealTime?: EnumMealTimeWithAggregatesFilter<"DietChartRecipe"> | $Enums.MealTime
    food_id?: StringNullableWithAggregatesFilter<"DietChartRecipe"> | string | null
    quantity?: FloatNullableWithAggregatesFilter<"DietChartRecipe"> | number | null
  }

  export type DoctorCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DoctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    PatientDosha?: PatientDoshaCreateNestedManyWithoutPatientInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    PatientDosha?: PatientDoshaUncheckedCreateNestedManyWithoutPatientInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    PatientDosha?: PatientDoshaUpdateManyWithoutPatientNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    PatientDosha?: PatientDoshaUncheckedUpdateManyWithoutPatientNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
  }

  export type DoctorPatientCreateInput = {
    doctor: DoctorCreateNestedOneWithoutDoctorPatientInput
    patient: PatientCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateInput = {
    doctor_id: string
    patient_id: string
  }

  export type DoctorPatientUpdateInput = {
    doctor?: DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput
    patient?: PatientUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorPatientCreateManyInput = {
    doctor_id: string
    patient_id: string
  }

  export type DoctorPatientUpdateManyMutationInput = {

  }

  export type DoctorPatientUncheckedUpdateManyInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type CuisineCreateInput = {
    cuisine_id?: string
    name: string
    Recipe?: RecipeCreateNestedManyWithoutCuisineInput
  }

  export type CuisineUncheckedCreateInput = {
    cuisine_id?: string
    name: string
    Recipe?: RecipeUncheckedCreateNestedManyWithoutCuisineInput
  }

  export type CuisineUpdateInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Recipe?: RecipeUpdateManyWithoutCuisineNestedInput
  }

  export type CuisineUncheckedUpdateInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Recipe?: RecipeUncheckedUpdateManyWithoutCuisineNestedInput
  }

  export type CuisineCreateManyInput = {
    cuisine_id?: string
    name: string
  }

  export type CuisineUpdateManyMutationInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CuisineUncheckedUpdateManyInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type FoodCreateManyInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
  }

  export type FoodUpdateManyMutationInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FoodUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutrientCreateInput = {
    nutrient_id?: string
    name: string
    unit: string
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutNutrientInput
    Rda?: RdaCreateNestedManyWithoutNutrientInput
  }

  export type NutrientUncheckedCreateInput = {
    nutrient_id?: string
    name: string
    unit: string
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutNutrientInput
    Rda?: RdaUncheckedCreateNestedManyWithoutNutrientInput
  }

  export type NutrientUpdateInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    FoodNutrient?: FoodNutrientUpdateManyWithoutNutrientNestedInput
    Rda?: RdaUpdateManyWithoutNutrientNestedInput
  }

  export type NutrientUncheckedUpdateInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutNutrientNestedInput
    Rda?: RdaUncheckedUpdateManyWithoutNutrientNestedInput
  }

  export type NutrientCreateManyInput = {
    nutrient_id?: string
    name: string
    unit: string
  }

  export type NutrientUpdateManyMutationInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type NutrientUncheckedUpdateManyInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RasaCreateInput = {
    rasa_id?: string
    name: string
    FoodRasa?: FoodRasaCreateNestedManyWithoutRasaInput
  }

  export type RasaUncheckedCreateInput = {
    rasa_id?: string
    name: string
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutRasaInput
  }

  export type RasaUpdateInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodRasa?: FoodRasaUpdateManyWithoutRasaNestedInput
  }

  export type RasaUncheckedUpdateInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutRasaNestedInput
  }

  export type RasaCreateManyInput = {
    rasa_id?: string
    name: string
  }

  export type RasaUpdateManyMutationInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RasaUncheckedUpdateManyInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GunaCreateInput = {
    guna_id?: string
    name: string
    FoodGuna?: FoodGunaCreateNestedManyWithoutGunaInput
  }

  export type GunaUncheckedCreateInput = {
    guna_id?: string
    name: string
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutGunaInput
  }

  export type GunaUpdateInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodGuna?: FoodGunaUpdateManyWithoutGunaNestedInput
  }

  export type GunaUncheckedUpdateInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutGunaNestedInput
  }

  export type GunaCreateManyInput = {
    guna_id?: string
    name: string
  }

  export type GunaUpdateManyMutationInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GunaUncheckedUpdateManyInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DoshaCreateInput = {
    dosha_id?: string
    name: string
    FoodDosha?: FoodDoshaCreateNestedManyWithoutDoshaInput
    PatientDosha?: PatientDoshaCreateNestedManyWithoutDoshaInput
  }

  export type DoshaUncheckedCreateInput = {
    dosha_id?: string
    name: string
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutDoshaInput
    PatientDosha?: PatientDoshaUncheckedCreateNestedManyWithoutDoshaInput
  }

  export type DoshaUpdateInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDosha?: FoodDoshaUpdateManyWithoutDoshaNestedInput
    PatientDosha?: PatientDoshaUpdateManyWithoutDoshaNestedInput
  }

  export type DoshaUncheckedUpdateInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutDoshaNestedInput
    PatientDosha?: PatientDoshaUncheckedUpdateManyWithoutDoshaNestedInput
  }

  export type DoshaCreateManyInput = {
    dosha_id?: string
    name: string
  }

  export type DoshaUpdateManyMutationInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DoshaUncheckedUpdateManyInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ViryaCreateInput = {
    virya_id?: string
    name: string
    FoodVirya?: FoodViryaCreateNestedManyWithoutViryaInput
  }

  export type ViryaUncheckedCreateInput = {
    virya_id?: string
    name: string
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutViryaInput
  }

  export type ViryaUpdateInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodVirya?: FoodViryaUpdateManyWithoutViryaNestedInput
  }

  export type ViryaUncheckedUpdateInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutViryaNestedInput
  }

  export type ViryaCreateManyInput = {
    virya_id?: string
    name: string
  }

  export type ViryaUpdateManyMutationInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ViryaUncheckedUpdateManyInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VipakaCreateInput = {
    vipaka_id?: string
    name: string
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutVipakaInput
  }

  export type VipakaUncheckedCreateInput = {
    vipaka_id?: string
    name: string
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutVipakaInput
  }

  export type VipakaUpdateInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodVipaka?: FoodVipakaUpdateManyWithoutVipakaNestedInput
  }

  export type VipakaUncheckedUpdateInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutVipakaNestedInput
  }

  export type VipakaCreateManyInput = {
    vipaka_id?: string
    name: string
  }

  export type VipakaUpdateManyMutationInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VipakaUncheckedUpdateManyInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DigestibilityCreateInput = {
    digestibility_id?: string
    name: string
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutDigestibilityInput
  }

  export type DigestibilityUncheckedCreateInput = {
    digestibility_id?: string
    name: string
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutDigestibilityInput
  }

  export type DigestibilityUpdateInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutDigestibilityNestedInput
  }

  export type DigestibilityUncheckedUpdateInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutDigestibilityNestedInput
  }

  export type DigestibilityCreateManyInput = {
    digestibility_id?: string
    name: string
  }

  export type DigestibilityUpdateManyMutationInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DigestibilityUncheckedUpdateManyInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RdaCreateInput = {
    rda_id?: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
    Nutrient: NutrientCreateNestedOneWithoutRdaInput
  }

  export type RdaUncheckedCreateInput = {
    rda_id?: string
    nutrient_id: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
  }

  export type RdaUpdateInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
    Nutrient?: NutrientUpdateOneRequiredWithoutRdaNestedInput
  }

  export type RdaUncheckedUpdateInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    nutrient_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RdaCreateManyInput = {
    rda_id?: string
    nutrient_id: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
  }

  export type RdaUpdateManyMutationInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RdaUncheckedUpdateManyInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    nutrient_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodNutrientCreateInput = {
    amount: number
    food: FoodCreateNestedOneWithoutFoodNutrientInput
    nutrient: NutrientCreateNestedOneWithoutFoodNutrientInput
  }

  export type FoodNutrientUncheckedCreateInput = {
    food_id: string
    nutrient_id: string
    amount: number
  }

  export type FoodNutrientUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    food?: FoodUpdateOneRequiredWithoutFoodNutrientNestedInput
    nutrient?: NutrientUpdateOneRequiredWithoutFoodNutrientNestedInput
  }

  export type FoodNutrientUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    nutrient_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodNutrientCreateManyInput = {
    food_id: string
    nutrient_id: string
    amount: number
  }

  export type FoodNutrientUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodNutrientUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    nutrient_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodRasaCreateInput = {
    food: FoodCreateNestedOneWithoutFoodRasaInput
    rasa: RasaCreateNestedOneWithoutFoodRasaInput
  }

  export type FoodRasaUncheckedCreateInput = {
    food_id: string
    rasa_id: string
  }

  export type FoodRasaUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodRasaNestedInput
    rasa?: RasaUpdateOneRequiredWithoutFoodRasaNestedInput
  }

  export type FoodRasaUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    rasa_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodRasaCreateManyInput = {
    food_id: string
    rasa_id: string
  }

  export type FoodRasaUpdateManyMutationInput = {

  }

  export type FoodRasaUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    rasa_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaCreateInput = {
    food: FoodCreateNestedOneWithoutFoodGunaInput
    guna: GunaCreateNestedOneWithoutFoodGunaInput
  }

  export type FoodGunaUncheckedCreateInput = {
    food_id: string
    guna_id: string
  }

  export type FoodGunaUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodGunaNestedInput
    guna?: GunaUpdateOneRequiredWithoutFoodGunaNestedInput
  }

  export type FoodGunaUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    guna_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaCreateManyInput = {
    food_id: string
    guna_id: string
  }

  export type FoodGunaUpdateManyMutationInput = {

  }

  export type FoodGunaUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    guna_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaCreateInput = {
    food: FoodCreateNestedOneWithoutFoodDoshaInput
    dosha: DoshaCreateNestedOneWithoutFoodDoshaInput
  }

  export type FoodDoshaUncheckedCreateInput = {
    food_id: string
    dosha_id: string
  }

  export type FoodDoshaUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodDoshaNestedInput
    dosha?: DoshaUpdateOneRequiredWithoutFoodDoshaNestedInput
  }

  export type FoodDoshaUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaCreateManyInput = {
    food_id: string
    dosha_id: string
  }

  export type FoodDoshaUpdateManyMutationInput = {

  }

  export type FoodDoshaUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaCreateInput = {
    patient: PatientCreateNestedOneWithoutPatientDoshaInput
    dosha: DoshaCreateNestedOneWithoutPatientDoshaInput
  }

  export type PatientDoshaUncheckedCreateInput = {
    patient_id: string
    dosha_id: string
  }

  export type PatientDoshaUpdateInput = {
    patient?: PatientUpdateOneRequiredWithoutPatientDoshaNestedInput
    dosha?: DoshaUpdateOneRequiredWithoutPatientDoshaNestedInput
  }

  export type PatientDoshaUncheckedUpdateInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaCreateManyInput = {
    patient_id: string
    dosha_id: string
  }

  export type PatientDoshaUpdateManyMutationInput = {

  }

  export type PatientDoshaUncheckedUpdateManyInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaCreateInput = {
    food: FoodCreateNestedOneWithoutFoodViryaInput
    virya: ViryaCreateNestedOneWithoutFoodViryaInput
  }

  export type FoodViryaUncheckedCreateInput = {
    food_id: string
    virya_id: string
  }

  export type FoodViryaUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodViryaNestedInput
    virya?: ViryaUpdateOneRequiredWithoutFoodViryaNestedInput
  }

  export type FoodViryaUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    virya_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaCreateManyInput = {
    food_id: string
    virya_id: string
  }

  export type FoodViryaUpdateManyMutationInput = {

  }

  export type FoodViryaUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    virya_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaCreateInput = {
    food: FoodCreateNestedOneWithoutFoodVipakaInput
    vipaka: VipakaCreateNestedOneWithoutFoodVipakaInput
  }

  export type FoodVipakaUncheckedCreateInput = {
    food_id: string
    vipaka_id: string
  }

  export type FoodVipakaUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodVipakaNestedInput
    vipaka?: VipakaUpdateOneRequiredWithoutFoodVipakaNestedInput
  }

  export type FoodVipakaUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    vipaka_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaCreateManyInput = {
    food_id: string
    vipaka_id: string
  }

  export type FoodVipakaUpdateManyMutationInput = {

  }

  export type FoodVipakaUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    vipaka_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityCreateInput = {
    food: FoodCreateNestedOneWithoutFoodDigestibilityInput
    digestibility: DigestibilityCreateNestedOneWithoutFoodDigestibilityInput
  }

  export type FoodDigestibilityUncheckedCreateInput = {
    food_id: string
    digestibility_id: string
  }

  export type FoodDigestibilityUpdateInput = {
    food?: FoodUpdateOneRequiredWithoutFoodDigestibilityNestedInput
    digestibility?: DigestibilityUpdateOneRequiredWithoutFoodDigestibilityNestedInput
  }

  export type FoodDigestibilityUncheckedUpdateInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    digestibility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityCreateManyInput = {
    food_id: string
    digestibility_id: string
  }

  export type FoodDigestibilityUpdateManyMutationInput = {

  }

  export type FoodDigestibilityUncheckedUpdateManyInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    digestibility_id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateInput = {
    recipe_id?: string
    name: string
    Cuisine: CuisineCreateNestedOneWithoutRecipeInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    recipe_id?: string
    name: string
    cuisine_id: string
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Cuisine?: CuisineUpdateOneRequiredWithoutRecipeNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine_id?: StringFieldUpdateOperationsInput | string
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    recipe_id?: string
    name: string
    cuisine_id: string
  }

  export type RecipeUpdateManyMutationInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine_id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientCreateInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutRecipeIngredientInput
    food: FoodCreateNestedOneWithoutRecipeIngredientInput
  }

  export type RecipeIngredientUncheckedCreateInput = {
    recipe_id: string
    food_id: string
    quantity: number
  }

  export type RecipeIngredientUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutRecipeIngredientNestedInput
    food?: FoodUpdateOneRequiredWithoutRecipeIngredientNestedInput
  }

  export type RecipeIngredientUncheckedUpdateInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    food_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeIngredientCreateManyInput = {
    recipe_id: string
    food_id: string
    quantity: number
  }

  export type RecipeIngredientUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeIngredientUncheckedUpdateManyInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    food_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type DietChartCreateInput = {
    chart_id?: string
    name: string
    description?: string | null
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutDietChartInput
  }

  export type DietChartUncheckedCreateInput = {
    chart_id?: string
    name: string
    description?: string | null
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutDietChartInput
  }

  export type DietChartUpdateInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutDietChartNestedInput
  }

  export type DietChartUncheckedUpdateInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutDietChartNestedInput
  }

  export type DietChartCreateManyInput = {
    chart_id?: string
    name: string
    description?: string | null
  }

  export type DietChartUpdateManyMutationInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DietChartUncheckedUpdateManyInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DietChartRecipeCreateInput = {
    mealTime: $Enums.MealTime
    quantity?: number | null
    dietChart: DietChartCreateNestedOneWithoutDietChartRecipeInput
    recipe: RecipeCreateNestedOneWithoutDietChartRecipeInput
    food?: FoodCreateNestedOneWithoutDietChartRecipeInput
  }

  export type DietChartRecipeUncheckedCreateInput = {
    chart_id: string
    recipe_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type DietChartRecipeUpdateInput = {
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    dietChart?: DietChartUpdateOneRequiredWithoutDietChartRecipeNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutDietChartRecipeNestedInput
    food?: FoodUpdateOneWithoutDietChartRecipeNestedInput
  }

  export type DietChartRecipeUncheckedUpdateInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeCreateManyInput = {
    chart_id: string
    recipe_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type DietChartRecipeUpdateManyMutationInput = {
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeUncheckedUpdateManyInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DoctorPatientListRelationFilter = {
    every?: DoctorPatientWhereInput
    some?: DoctorPatientWhereInput
    none?: DoctorPatientWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DoctorPatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDietaryHabitsFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryHabits | EnumDietaryHabitsFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    not?: NestedEnumDietaryHabitsFilter<$PrismaModel> | $Enums.DietaryHabits
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumDigestionQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestionQuality | EnumDigestionQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestionQualityFilter<$PrismaModel> | $Enums.DigestionQuality
  }

  export type EnumBowelMovementFilter<$PrismaModel = never> = {
    equals?: $Enums.BowelMovement | EnumBowelMovementFieldRefInput<$PrismaModel>
    in?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    notIn?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    not?: NestedEnumBowelMovementFilter<$PrismaModel> | $Enums.BowelMovement
  }

  export type PatientDoshaListRelationFilter = {
    every?: PatientDoshaWhereInput
    some?: PatientDoshaWhereInput
    none?: PatientDoshaWhereInput
  }

  export type PatientDoshaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    dietary_habits?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
    digestionQuality?: SortOrder
    bowelMovement?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    dietary_habits?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
    digestionQuality?: SortOrder
    bowelMovement?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    dietary_habits?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
    digestionQuality?: SortOrder
    bowelMovement?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    mealFrequency?: SortOrder
    waterIntake?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDietaryHabitsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryHabits | EnumDietaryHabitsFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    not?: NestedEnumDietaryHabitsWithAggregatesFilter<$PrismaModel> | $Enums.DietaryHabits
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDietaryHabitsFilter<$PrismaModel>
    _max?: NestedEnumDietaryHabitsFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumDigestionQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestionQuality | EnumDigestionQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestionQualityWithAggregatesFilter<$PrismaModel> | $Enums.DigestionQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDigestionQualityFilter<$PrismaModel>
    _max?: NestedEnumDigestionQualityFilter<$PrismaModel>
  }

  export type EnumBowelMovementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BowelMovement | EnumBowelMovementFieldRefInput<$PrismaModel>
    in?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    notIn?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    not?: NestedEnumBowelMovementWithAggregatesFilter<$PrismaModel> | $Enums.BowelMovement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBowelMovementFilter<$PrismaModel>
    _max?: NestedEnumBowelMovementFilter<$PrismaModel>
  }

  export type DoctorScalarRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type DoctorPatientDoctor_idPatient_idCompoundUniqueInput = {
    doctor_id: string
    patient_id: string
  }

  export type DoctorPatientCountOrderByAggregateInput = {
    doctor_id?: SortOrder
    patient_id?: SortOrder
  }

  export type DoctorPatientMaxOrderByAggregateInput = {
    doctor_id?: SortOrder
    patient_id?: SortOrder
  }

  export type DoctorPatientMinOrderByAggregateInput = {
    doctor_id?: SortOrder
    patient_id?: SortOrder
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CuisineCountOrderByAggregateInput = {
    cuisine_id?: SortOrder
    name?: SortOrder
  }

  export type CuisineMaxOrderByAggregateInput = {
    cuisine_id?: SortOrder
    name?: SortOrder
  }

  export type CuisineMinOrderByAggregateInput = {
    cuisine_id?: SortOrder
    name?: SortOrder
  }

  export type FoodNutrientListRelationFilter = {
    every?: FoodNutrientWhereInput
    some?: FoodNutrientWhereInput
    none?: FoodNutrientWhereInput
  }

  export type FoodRasaListRelationFilter = {
    every?: FoodRasaWhereInput
    some?: FoodRasaWhereInput
    none?: FoodRasaWhereInput
  }

  export type FoodGunaListRelationFilter = {
    every?: FoodGunaWhereInput
    some?: FoodGunaWhereInput
    none?: FoodGunaWhereInput
  }

  export type FoodDoshaListRelationFilter = {
    every?: FoodDoshaWhereInput
    some?: FoodDoshaWhereInput
    none?: FoodDoshaWhereInput
  }

  export type FoodViryaListRelationFilter = {
    every?: FoodViryaWhereInput
    some?: FoodViryaWhereInput
    none?: FoodViryaWhereInput
  }

  export type FoodVipakaListRelationFilter = {
    every?: FoodVipakaWhereInput
    some?: FoodVipakaWhereInput
    none?: FoodVipakaWhereInput
  }

  export type FoodDigestibilityListRelationFilter = {
    every?: FoodDigestibilityWhereInput
    some?: FoodDigestibilityWhereInput
    none?: FoodDigestibilityWhereInput
  }

  export type RecipeIngredientListRelationFilter = {
    every?: RecipeIngredientWhereInput
    some?: RecipeIngredientWhereInput
    none?: RecipeIngredientWhereInput
  }

  export type DietChartRecipeListRelationFilter = {
    every?: DietChartRecipeWhereInput
    some?: DietChartRecipeWhereInput
    none?: DietChartRecipeWhereInput
  }

  export type FoodNutrientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodRasaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodGunaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodDoshaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodViryaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodVipakaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodDigestibilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DietChartRecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodCountOrderByAggregateInput = {
    food_id?: SortOrder
    name?: SortOrder
    hindi_name?: SortOrder
  }

  export type FoodMaxOrderByAggregateInput = {
    food_id?: SortOrder
    name?: SortOrder
    hindi_name?: SortOrder
  }

  export type FoodMinOrderByAggregateInput = {
    food_id?: SortOrder
    name?: SortOrder
    hindi_name?: SortOrder
  }

  export type RdaListRelationFilter = {
    every?: RdaWhereInput
    some?: RdaWhereInput
    none?: RdaWhereInput
  }

  export type RdaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutrientCountOrderByAggregateInput = {
    nutrient_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
  }

  export type NutrientMaxOrderByAggregateInput = {
    nutrient_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
  }

  export type NutrientMinOrderByAggregateInput = {
    nutrient_id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
  }

  export type RasaCountOrderByAggregateInput = {
    rasa_id?: SortOrder
    name?: SortOrder
  }

  export type RasaMaxOrderByAggregateInput = {
    rasa_id?: SortOrder
    name?: SortOrder
  }

  export type RasaMinOrderByAggregateInput = {
    rasa_id?: SortOrder
    name?: SortOrder
  }

  export type GunaCountOrderByAggregateInput = {
    guna_id?: SortOrder
    name?: SortOrder
  }

  export type GunaMaxOrderByAggregateInput = {
    guna_id?: SortOrder
    name?: SortOrder
  }

  export type GunaMinOrderByAggregateInput = {
    guna_id?: SortOrder
    name?: SortOrder
  }

  export type DoshaCountOrderByAggregateInput = {
    dosha_id?: SortOrder
    name?: SortOrder
  }

  export type DoshaMaxOrderByAggregateInput = {
    dosha_id?: SortOrder
    name?: SortOrder
  }

  export type DoshaMinOrderByAggregateInput = {
    dosha_id?: SortOrder
    name?: SortOrder
  }

  export type ViryaCountOrderByAggregateInput = {
    virya_id?: SortOrder
    name?: SortOrder
  }

  export type ViryaMaxOrderByAggregateInput = {
    virya_id?: SortOrder
    name?: SortOrder
  }

  export type ViryaMinOrderByAggregateInput = {
    virya_id?: SortOrder
    name?: SortOrder
  }

  export type VipakaCountOrderByAggregateInput = {
    vipaka_id?: SortOrder
    name?: SortOrder
  }

  export type VipakaMaxOrderByAggregateInput = {
    vipaka_id?: SortOrder
    name?: SortOrder
  }

  export type VipakaMinOrderByAggregateInput = {
    vipaka_id?: SortOrder
    name?: SortOrder
  }

  export type DigestibilityCountOrderByAggregateInput = {
    digestibility_id?: SortOrder
    name?: SortOrder
  }

  export type DigestibilityMaxOrderByAggregateInput = {
    digestibility_id?: SortOrder
    name?: SortOrder
  }

  export type DigestibilityMinOrderByAggregateInput = {
    digestibility_id?: SortOrder
    name?: SortOrder
  }

  export type EnumAgeGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeGroup | EnumAgeGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeGroupFilter<$PrismaModel> | $Enums.AgeGroup
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NutrientScalarRelationFilter = {
    is?: NutrientWhereInput
    isNot?: NutrientWhereInput
  }

  export type RdaCountOrderByAggregateInput = {
    rda_id?: SortOrder
    nutrient_id?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    amount?: SortOrder
  }

  export type RdaAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RdaMaxOrderByAggregateInput = {
    rda_id?: SortOrder
    nutrient_id?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    amount?: SortOrder
  }

  export type RdaMinOrderByAggregateInput = {
    rda_id?: SortOrder
    nutrient_id?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    amount?: SortOrder
  }

  export type RdaSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumAgeGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeGroup | EnumAgeGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeGroupWithAggregatesFilter<$PrismaModel> | $Enums.AgeGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeGroupFilter<$PrismaModel>
    _max?: NestedEnumAgeGroupFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type FoodScalarRelationFilter = {
    is?: FoodWhereInput
    isNot?: FoodWhereInput
  }

  export type FoodNutrientFood_idNutrient_idCompoundUniqueInput = {
    food_id: string
    nutrient_id: string
  }

  export type FoodNutrientCountOrderByAggregateInput = {
    food_id?: SortOrder
    nutrient_id?: SortOrder
    amount?: SortOrder
  }

  export type FoodNutrientAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FoodNutrientMaxOrderByAggregateInput = {
    food_id?: SortOrder
    nutrient_id?: SortOrder
    amount?: SortOrder
  }

  export type FoodNutrientMinOrderByAggregateInput = {
    food_id?: SortOrder
    nutrient_id?: SortOrder
    amount?: SortOrder
  }

  export type FoodNutrientSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RasaScalarRelationFilter = {
    is?: RasaWhereInput
    isNot?: RasaWhereInput
  }

  export type FoodRasaFood_idRasa_idCompoundUniqueInput = {
    food_id: string
    rasa_id: string
  }

  export type FoodRasaCountOrderByAggregateInput = {
    food_id?: SortOrder
    rasa_id?: SortOrder
  }

  export type FoodRasaMaxOrderByAggregateInput = {
    food_id?: SortOrder
    rasa_id?: SortOrder
  }

  export type FoodRasaMinOrderByAggregateInput = {
    food_id?: SortOrder
    rasa_id?: SortOrder
  }

  export type GunaScalarRelationFilter = {
    is?: GunaWhereInput
    isNot?: GunaWhereInput
  }

  export type FoodGunaFood_idGuna_idCompoundUniqueInput = {
    food_id: string
    guna_id: string
  }

  export type FoodGunaCountOrderByAggregateInput = {
    food_id?: SortOrder
    guna_id?: SortOrder
  }

  export type FoodGunaMaxOrderByAggregateInput = {
    food_id?: SortOrder
    guna_id?: SortOrder
  }

  export type FoodGunaMinOrderByAggregateInput = {
    food_id?: SortOrder
    guna_id?: SortOrder
  }

  export type DoshaScalarRelationFilter = {
    is?: DoshaWhereInput
    isNot?: DoshaWhereInput
  }

  export type FoodDoshaFood_idDosha_idCompoundUniqueInput = {
    food_id: string
    dosha_id: string
  }

  export type FoodDoshaCountOrderByAggregateInput = {
    food_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type FoodDoshaMaxOrderByAggregateInput = {
    food_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type FoodDoshaMinOrderByAggregateInput = {
    food_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type PatientDoshaPatient_idDosha_idCompoundUniqueInput = {
    patient_id: string
    dosha_id: string
  }

  export type PatientDoshaCountOrderByAggregateInput = {
    patient_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type PatientDoshaMaxOrderByAggregateInput = {
    patient_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type PatientDoshaMinOrderByAggregateInput = {
    patient_id?: SortOrder
    dosha_id?: SortOrder
  }

  export type ViryaScalarRelationFilter = {
    is?: ViryaWhereInput
    isNot?: ViryaWhereInput
  }

  export type FoodViryaFood_idVirya_idCompoundUniqueInput = {
    food_id: string
    virya_id: string
  }

  export type FoodViryaCountOrderByAggregateInput = {
    food_id?: SortOrder
    virya_id?: SortOrder
  }

  export type FoodViryaMaxOrderByAggregateInput = {
    food_id?: SortOrder
    virya_id?: SortOrder
  }

  export type FoodViryaMinOrderByAggregateInput = {
    food_id?: SortOrder
    virya_id?: SortOrder
  }

  export type VipakaScalarRelationFilter = {
    is?: VipakaWhereInput
    isNot?: VipakaWhereInput
  }

  export type FoodVipakaCountOrderByAggregateInput = {
    food_id?: SortOrder
    vipaka_id?: SortOrder
  }

  export type FoodVipakaMaxOrderByAggregateInput = {
    food_id?: SortOrder
    vipaka_id?: SortOrder
  }

  export type FoodVipakaMinOrderByAggregateInput = {
    food_id?: SortOrder
    vipaka_id?: SortOrder
  }

  export type DigestibilityScalarRelationFilter = {
    is?: DigestibilityWhereInput
    isNot?: DigestibilityWhereInput
  }

  export type FoodDigestibilityCountOrderByAggregateInput = {
    food_id?: SortOrder
    digestibility_id?: SortOrder
  }

  export type FoodDigestibilityMaxOrderByAggregateInput = {
    food_id?: SortOrder
    digestibility_id?: SortOrder
  }

  export type FoodDigestibilityMinOrderByAggregateInput = {
    food_id?: SortOrder
    digestibility_id?: SortOrder
  }

  export type CuisineScalarRelationFilter = {
    is?: CuisineWhereInput
    isNot?: CuisineWhereInput
  }

  export type RecipeCountOrderByAggregateInput = {
    recipe_id?: SortOrder
    name?: SortOrder
    cuisine_id?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    recipe_id?: SortOrder
    name?: SortOrder
    cuisine_id?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    recipe_id?: SortOrder
    name?: SortOrder
    cuisine_id?: SortOrder
  }

  export type RecipeScalarRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type RecipeIngredientRecipe_idFood_idCompoundUniqueInput = {
    recipe_id: string
    food_id: string
  }

  export type RecipeIngredientCountOrderByAggregateInput = {
    recipe_id?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeIngredientAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type RecipeIngredientMaxOrderByAggregateInput = {
    recipe_id?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeIngredientMinOrderByAggregateInput = {
    recipe_id?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type RecipeIngredientSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DietChartCountOrderByAggregateInput = {
    chart_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DietChartMaxOrderByAggregateInput = {
    chart_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DietChartMinOrderByAggregateInput = {
    chart_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumMealTimeFilter<$PrismaModel = never> = {
    equals?: $Enums.MealTime | EnumMealTimeFieldRefInput<$PrismaModel>
    in?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    not?: NestedEnumMealTimeFilter<$PrismaModel> | $Enums.MealTime
  }

  export type DietChartScalarRelationFilter = {
    is?: DietChartWhereInput
    isNot?: DietChartWhereInput
  }

  export type FoodNullableScalarRelationFilter = {
    is?: FoodWhereInput | null
    isNot?: FoodWhereInput | null
  }

  export type DietChartRecipeChart_idRecipe_idCompoundUniqueInput = {
    chart_id: string
    recipe_id: string
  }

  export type DietChartRecipeCountOrderByAggregateInput = {
    chart_id?: SortOrder
    recipe_id?: SortOrder
    mealTime?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type DietChartRecipeAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DietChartRecipeMaxOrderByAggregateInput = {
    chart_id?: SortOrder
    recipe_id?: SortOrder
    mealTime?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type DietChartRecipeMinOrderByAggregateInput = {
    chart_id?: SortOrder
    recipe_id?: SortOrder
    mealTime?: SortOrder
    food_id?: SortOrder
    quantity?: SortOrder
  }

  export type DietChartRecipeSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumMealTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MealTime | EnumMealTimeFieldRefInput<$PrismaModel>
    in?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    not?: NestedEnumMealTimeWithAggregatesFilter<$PrismaModel> | $Enums.MealTime
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMealTimeFilter<$PrismaModel>
    _max?: NestedEnumMealTimeFilter<$PrismaModel>
  }

  export type DoctorPatientCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput> | DoctorPatientCreateWithoutDoctorInput[] | DoctorPatientUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutDoctorInput | DoctorPatientCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
  }

  export type DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput> | DoctorPatientCreateWithoutDoctorInput[] | DoctorPatientUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutDoctorInput | DoctorPatientCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DoctorPatientUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput> | DoctorPatientCreateWithoutDoctorInput[] | DoctorPatientUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutDoctorInput | DoctorPatientCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput | DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    set?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    disconnect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    delete?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    update?: DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput | DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorPatientUpdateManyWithWhereWithoutDoctorInput | DoctorPatientUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
  }

  export type DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput> | DoctorPatientCreateWithoutDoctorInput[] | DoctorPatientUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutDoctorInput | DoctorPatientCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput | DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    set?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    disconnect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    delete?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    update?: DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput | DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorPatientUpdateManyWithWhereWithoutDoctorInput | DoctorPatientUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
  }

  export type PatientDoshaCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput> | PatientDoshaCreateWithoutPatientInput[] | PatientDoshaUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutPatientInput | PatientDoshaCreateOrConnectWithoutPatientInput[]
    createMany?: PatientDoshaCreateManyPatientInputEnvelope
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
  }

  export type DoctorPatientCreateNestedManyWithoutPatientInput = {
    create?: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput> | DoctorPatientCreateWithoutPatientInput[] | DoctorPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutPatientInput | DoctorPatientCreateOrConnectWithoutPatientInput[]
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
  }

  export type PatientDoshaUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput> | PatientDoshaCreateWithoutPatientInput[] | PatientDoshaUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutPatientInput | PatientDoshaCreateOrConnectWithoutPatientInput[]
    createMany?: PatientDoshaCreateManyPatientInputEnvelope
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
  }

  export type DoctorPatientUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput> | DoctorPatientCreateWithoutPatientInput[] | DoctorPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutPatientInput | DoctorPatientCreateOrConnectWithoutPatientInput[]
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDietaryHabitsFieldUpdateOperationsInput = {
    set?: $Enums.DietaryHabits
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDigestionQualityFieldUpdateOperationsInput = {
    set?: $Enums.DigestionQuality
  }

  export type EnumBowelMovementFieldUpdateOperationsInput = {
    set?: $Enums.BowelMovement
  }

  export type PatientDoshaUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput> | PatientDoshaCreateWithoutPatientInput[] | PatientDoshaUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutPatientInput | PatientDoshaCreateOrConnectWithoutPatientInput[]
    upsert?: PatientDoshaUpsertWithWhereUniqueWithoutPatientInput | PatientDoshaUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientDoshaCreateManyPatientInputEnvelope
    set?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    disconnect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    delete?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    update?: PatientDoshaUpdateWithWhereUniqueWithoutPatientInput | PatientDoshaUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientDoshaUpdateManyWithWhereWithoutPatientInput | PatientDoshaUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
  }

  export type DoctorPatientUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput> | DoctorPatientCreateWithoutPatientInput[] | DoctorPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutPatientInput | DoctorPatientCreateOrConnectWithoutPatientInput[]
    upsert?: DoctorPatientUpsertWithWhereUniqueWithoutPatientInput | DoctorPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    set?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    disconnect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    delete?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    update?: DoctorPatientUpdateWithWhereUniqueWithoutPatientInput | DoctorPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DoctorPatientUpdateManyWithWhereWithoutPatientInput | DoctorPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
  }

  export type PatientDoshaUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput> | PatientDoshaCreateWithoutPatientInput[] | PatientDoshaUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutPatientInput | PatientDoshaCreateOrConnectWithoutPatientInput[]
    upsert?: PatientDoshaUpsertWithWhereUniqueWithoutPatientInput | PatientDoshaUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientDoshaCreateManyPatientInputEnvelope
    set?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    disconnect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    delete?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    update?: PatientDoshaUpdateWithWhereUniqueWithoutPatientInput | PatientDoshaUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientDoshaUpdateManyWithWhereWithoutPatientInput | PatientDoshaUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
  }

  export type DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput> | DoctorPatientCreateWithoutPatientInput[] | DoctorPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DoctorPatientCreateOrConnectWithoutPatientInput | DoctorPatientCreateOrConnectWithoutPatientInput[]
    upsert?: DoctorPatientUpsertWithWhereUniqueWithoutPatientInput | DoctorPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    set?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    disconnect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    delete?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    connect?: DoctorPatientWhereUniqueInput | DoctorPatientWhereUniqueInput[]
    update?: DoctorPatientUpdateWithWhereUniqueWithoutPatientInput | DoctorPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DoctorPatientUpdateManyWithWhereWithoutPatientInput | DoctorPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
  }

  export type DoctorCreateNestedOneWithoutDoctorPatientInput = {
    create?: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorPatientInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutDoctorPatientInput = {
    create?: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDoctorPatientInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput = {
    create?: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorPatientInput
    upsert?: DoctorUpsertWithoutDoctorPatientInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutDoctorPatientInput, DoctorUpdateWithoutDoctorPatientInput>, DoctorUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type PatientUpdateOneRequiredWithoutDoctorPatientNestedInput = {
    create?: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDoctorPatientInput
    upsert?: PatientUpsertWithoutDoctorPatientInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDoctorPatientInput, PatientUpdateWithoutDoctorPatientInput>, PatientUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type RecipeCreateNestedManyWithoutCuisineInput = {
    create?: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput> | RecipeCreateWithoutCuisineInput[] | RecipeUncheckedCreateWithoutCuisineInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCuisineInput | RecipeCreateOrConnectWithoutCuisineInput[]
    createMany?: RecipeCreateManyCuisineInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutCuisineInput = {
    create?: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput> | RecipeCreateWithoutCuisineInput[] | RecipeUncheckedCreateWithoutCuisineInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCuisineInput | RecipeCreateOrConnectWithoutCuisineInput[]
    createMany?: RecipeCreateManyCuisineInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeUpdateManyWithoutCuisineNestedInput = {
    create?: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput> | RecipeCreateWithoutCuisineInput[] | RecipeUncheckedCreateWithoutCuisineInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCuisineInput | RecipeCreateOrConnectWithoutCuisineInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCuisineInput | RecipeUpsertWithWhereUniqueWithoutCuisineInput[]
    createMany?: RecipeCreateManyCuisineInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCuisineInput | RecipeUpdateWithWhereUniqueWithoutCuisineInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCuisineInput | RecipeUpdateManyWithWhereWithoutCuisineInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutCuisineNestedInput = {
    create?: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput> | RecipeCreateWithoutCuisineInput[] | RecipeUncheckedCreateWithoutCuisineInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCuisineInput | RecipeCreateOrConnectWithoutCuisineInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCuisineInput | RecipeUpsertWithWhereUniqueWithoutCuisineInput[]
    createMany?: RecipeCreateManyCuisineInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCuisineInput | RecipeUpdateWithWhereUniqueWithoutCuisineInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCuisineInput | RecipeUpdateManyWithWhereWithoutCuisineInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type FoodNutrientCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput> | FoodNutrientCreateWithoutFoodInput[] | FoodNutrientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutFoodInput | FoodNutrientCreateOrConnectWithoutFoodInput[]
    createMany?: FoodNutrientCreateManyFoodInputEnvelope
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
  }

  export type FoodRasaCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput> | FoodRasaCreateWithoutFoodInput[] | FoodRasaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutFoodInput | FoodRasaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodRasaCreateManyFoodInputEnvelope
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
  }

  export type FoodGunaCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput> | FoodGunaCreateWithoutFoodInput[] | FoodGunaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutFoodInput | FoodGunaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodGunaCreateManyFoodInputEnvelope
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
  }

  export type FoodDoshaCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput> | FoodDoshaCreateWithoutFoodInput[] | FoodDoshaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutFoodInput | FoodDoshaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodDoshaCreateManyFoodInputEnvelope
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
  }

  export type FoodViryaCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput> | FoodViryaCreateWithoutFoodInput[] | FoodViryaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutFoodInput | FoodViryaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodViryaCreateManyFoodInputEnvelope
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
  }

  export type FoodVipakaCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput> | FoodVipakaCreateWithoutFoodInput[] | FoodVipakaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutFoodInput | FoodVipakaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodVipakaCreateManyFoodInputEnvelope
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
  }

  export type FoodDigestibilityCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput> | FoodDigestibilityCreateWithoutFoodInput[] | FoodDigestibilityUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutFoodInput | FoodDigestibilityCreateOrConnectWithoutFoodInput[]
    createMany?: FoodDigestibilityCreateManyFoodInputEnvelope
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
  }

  export type RecipeIngredientCreateNestedManyWithoutFoodInput = {
    create?: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput> | RecipeIngredientCreateWithoutFoodInput[] | RecipeIngredientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutFoodInput | RecipeIngredientCreateOrConnectWithoutFoodInput[]
    createMany?: RecipeIngredientCreateManyFoodInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type DietChartRecipeCreateNestedManyWithoutFoodInput = {
    create?: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput> | DietChartRecipeCreateWithoutFoodInput[] | DietChartRecipeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutFoodInput | DietChartRecipeCreateOrConnectWithoutFoodInput[]
    createMany?: DietChartRecipeCreateManyFoodInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type FoodNutrientUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput> | FoodNutrientCreateWithoutFoodInput[] | FoodNutrientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutFoodInput | FoodNutrientCreateOrConnectWithoutFoodInput[]
    createMany?: FoodNutrientCreateManyFoodInputEnvelope
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
  }

  export type FoodRasaUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput> | FoodRasaCreateWithoutFoodInput[] | FoodRasaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutFoodInput | FoodRasaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodRasaCreateManyFoodInputEnvelope
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
  }

  export type FoodGunaUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput> | FoodGunaCreateWithoutFoodInput[] | FoodGunaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutFoodInput | FoodGunaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodGunaCreateManyFoodInputEnvelope
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
  }

  export type FoodDoshaUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput> | FoodDoshaCreateWithoutFoodInput[] | FoodDoshaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutFoodInput | FoodDoshaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodDoshaCreateManyFoodInputEnvelope
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
  }

  export type FoodViryaUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput> | FoodViryaCreateWithoutFoodInput[] | FoodViryaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutFoodInput | FoodViryaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodViryaCreateManyFoodInputEnvelope
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
  }

  export type FoodVipakaUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput> | FoodVipakaCreateWithoutFoodInput[] | FoodVipakaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutFoodInput | FoodVipakaCreateOrConnectWithoutFoodInput[]
    createMany?: FoodVipakaCreateManyFoodInputEnvelope
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
  }

  export type FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput> | FoodDigestibilityCreateWithoutFoodInput[] | FoodDigestibilityUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutFoodInput | FoodDigestibilityCreateOrConnectWithoutFoodInput[]
    createMany?: FoodDigestibilityCreateManyFoodInputEnvelope
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput> | RecipeIngredientCreateWithoutFoodInput[] | RecipeIngredientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutFoodInput | RecipeIngredientCreateOrConnectWithoutFoodInput[]
    createMany?: RecipeIngredientCreateManyFoodInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput> | DietChartRecipeCreateWithoutFoodInput[] | DietChartRecipeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutFoodInput | DietChartRecipeCreateOrConnectWithoutFoodInput[]
    createMany?: DietChartRecipeCreateManyFoodInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type FoodNutrientUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput> | FoodNutrientCreateWithoutFoodInput[] | FoodNutrientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutFoodInput | FoodNutrientCreateOrConnectWithoutFoodInput[]
    upsert?: FoodNutrientUpsertWithWhereUniqueWithoutFoodInput | FoodNutrientUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodNutrientCreateManyFoodInputEnvelope
    set?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    disconnect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    delete?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    update?: FoodNutrientUpdateWithWhereUniqueWithoutFoodInput | FoodNutrientUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodNutrientUpdateManyWithWhereWithoutFoodInput | FoodNutrientUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
  }

  export type FoodRasaUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput> | FoodRasaCreateWithoutFoodInput[] | FoodRasaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutFoodInput | FoodRasaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodRasaUpsertWithWhereUniqueWithoutFoodInput | FoodRasaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodRasaCreateManyFoodInputEnvelope
    set?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    disconnect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    delete?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    update?: FoodRasaUpdateWithWhereUniqueWithoutFoodInput | FoodRasaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodRasaUpdateManyWithWhereWithoutFoodInput | FoodRasaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
  }

  export type FoodGunaUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput> | FoodGunaCreateWithoutFoodInput[] | FoodGunaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutFoodInput | FoodGunaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodGunaUpsertWithWhereUniqueWithoutFoodInput | FoodGunaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodGunaCreateManyFoodInputEnvelope
    set?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    disconnect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    delete?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    update?: FoodGunaUpdateWithWhereUniqueWithoutFoodInput | FoodGunaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodGunaUpdateManyWithWhereWithoutFoodInput | FoodGunaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
  }

  export type FoodDoshaUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput> | FoodDoshaCreateWithoutFoodInput[] | FoodDoshaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutFoodInput | FoodDoshaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodDoshaUpsertWithWhereUniqueWithoutFoodInput | FoodDoshaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodDoshaCreateManyFoodInputEnvelope
    set?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    disconnect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    delete?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    update?: FoodDoshaUpdateWithWhereUniqueWithoutFoodInput | FoodDoshaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodDoshaUpdateManyWithWhereWithoutFoodInput | FoodDoshaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
  }

  export type FoodViryaUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput> | FoodViryaCreateWithoutFoodInput[] | FoodViryaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutFoodInput | FoodViryaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodViryaUpsertWithWhereUniqueWithoutFoodInput | FoodViryaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodViryaCreateManyFoodInputEnvelope
    set?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    disconnect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    delete?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    update?: FoodViryaUpdateWithWhereUniqueWithoutFoodInput | FoodViryaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodViryaUpdateManyWithWhereWithoutFoodInput | FoodViryaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
  }

  export type FoodVipakaUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput> | FoodVipakaCreateWithoutFoodInput[] | FoodVipakaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutFoodInput | FoodVipakaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodVipakaUpsertWithWhereUniqueWithoutFoodInput | FoodVipakaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodVipakaCreateManyFoodInputEnvelope
    set?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    disconnect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    delete?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    update?: FoodVipakaUpdateWithWhereUniqueWithoutFoodInput | FoodVipakaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodVipakaUpdateManyWithWhereWithoutFoodInput | FoodVipakaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
  }

  export type FoodDigestibilityUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput> | FoodDigestibilityCreateWithoutFoodInput[] | FoodDigestibilityUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutFoodInput | FoodDigestibilityCreateOrConnectWithoutFoodInput[]
    upsert?: FoodDigestibilityUpsertWithWhereUniqueWithoutFoodInput | FoodDigestibilityUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodDigestibilityCreateManyFoodInputEnvelope
    set?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    disconnect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    delete?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    update?: FoodDigestibilityUpdateWithWhereUniqueWithoutFoodInput | FoodDigestibilityUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodDigestibilityUpdateManyWithWhereWithoutFoodInput | FoodDigestibilityUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
  }

  export type RecipeIngredientUpdateManyWithoutFoodNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput> | RecipeIngredientCreateWithoutFoodInput[] | RecipeIngredientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutFoodInput | RecipeIngredientCreateOrConnectWithoutFoodInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutFoodInput | RecipeIngredientUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: RecipeIngredientCreateManyFoodInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutFoodInput | RecipeIngredientUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutFoodInput | RecipeIngredientUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type DietChartRecipeUpdateManyWithoutFoodNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput> | DietChartRecipeCreateWithoutFoodInput[] | DietChartRecipeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutFoodInput | DietChartRecipeCreateOrConnectWithoutFoodInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutFoodInput | DietChartRecipeUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: DietChartRecipeCreateManyFoodInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutFoodInput | DietChartRecipeUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutFoodInput | DietChartRecipeUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput> | FoodNutrientCreateWithoutFoodInput[] | FoodNutrientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutFoodInput | FoodNutrientCreateOrConnectWithoutFoodInput[]
    upsert?: FoodNutrientUpsertWithWhereUniqueWithoutFoodInput | FoodNutrientUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodNutrientCreateManyFoodInputEnvelope
    set?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    disconnect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    delete?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    update?: FoodNutrientUpdateWithWhereUniqueWithoutFoodInput | FoodNutrientUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodNutrientUpdateManyWithWhereWithoutFoodInput | FoodNutrientUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
  }

  export type FoodRasaUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput> | FoodRasaCreateWithoutFoodInput[] | FoodRasaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutFoodInput | FoodRasaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodRasaUpsertWithWhereUniqueWithoutFoodInput | FoodRasaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodRasaCreateManyFoodInputEnvelope
    set?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    disconnect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    delete?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    update?: FoodRasaUpdateWithWhereUniqueWithoutFoodInput | FoodRasaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodRasaUpdateManyWithWhereWithoutFoodInput | FoodRasaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
  }

  export type FoodGunaUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput> | FoodGunaCreateWithoutFoodInput[] | FoodGunaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutFoodInput | FoodGunaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodGunaUpsertWithWhereUniqueWithoutFoodInput | FoodGunaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodGunaCreateManyFoodInputEnvelope
    set?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    disconnect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    delete?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    update?: FoodGunaUpdateWithWhereUniqueWithoutFoodInput | FoodGunaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodGunaUpdateManyWithWhereWithoutFoodInput | FoodGunaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
  }

  export type FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput> | FoodDoshaCreateWithoutFoodInput[] | FoodDoshaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutFoodInput | FoodDoshaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodDoshaUpsertWithWhereUniqueWithoutFoodInput | FoodDoshaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodDoshaCreateManyFoodInputEnvelope
    set?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    disconnect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    delete?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    update?: FoodDoshaUpdateWithWhereUniqueWithoutFoodInput | FoodDoshaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodDoshaUpdateManyWithWhereWithoutFoodInput | FoodDoshaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
  }

  export type FoodViryaUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput> | FoodViryaCreateWithoutFoodInput[] | FoodViryaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutFoodInput | FoodViryaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodViryaUpsertWithWhereUniqueWithoutFoodInput | FoodViryaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodViryaCreateManyFoodInputEnvelope
    set?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    disconnect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    delete?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    update?: FoodViryaUpdateWithWhereUniqueWithoutFoodInput | FoodViryaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodViryaUpdateManyWithWhereWithoutFoodInput | FoodViryaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
  }

  export type FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput> | FoodVipakaCreateWithoutFoodInput[] | FoodVipakaUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutFoodInput | FoodVipakaCreateOrConnectWithoutFoodInput[]
    upsert?: FoodVipakaUpsertWithWhereUniqueWithoutFoodInput | FoodVipakaUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodVipakaCreateManyFoodInputEnvelope
    set?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    disconnect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    delete?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    update?: FoodVipakaUpdateWithWhereUniqueWithoutFoodInput | FoodVipakaUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodVipakaUpdateManyWithWhereWithoutFoodInput | FoodVipakaUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
  }

  export type FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput> | FoodDigestibilityCreateWithoutFoodInput[] | FoodDigestibilityUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutFoodInput | FoodDigestibilityCreateOrConnectWithoutFoodInput[]
    upsert?: FoodDigestibilityUpsertWithWhereUniqueWithoutFoodInput | FoodDigestibilityUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodDigestibilityCreateManyFoodInputEnvelope
    set?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    disconnect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    delete?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    update?: FoodDigestibilityUpdateWithWhereUniqueWithoutFoodInput | FoodDigestibilityUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodDigestibilityUpdateManyWithWhereWithoutFoodInput | FoodDigestibilityUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput> | RecipeIngredientCreateWithoutFoodInput[] | RecipeIngredientUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutFoodInput | RecipeIngredientCreateOrConnectWithoutFoodInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutFoodInput | RecipeIngredientUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: RecipeIngredientCreateManyFoodInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutFoodInput | RecipeIngredientUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutFoodInput | RecipeIngredientUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput> | DietChartRecipeCreateWithoutFoodInput[] | DietChartRecipeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutFoodInput | DietChartRecipeCreateOrConnectWithoutFoodInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutFoodInput | DietChartRecipeUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: DietChartRecipeCreateManyFoodInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutFoodInput | DietChartRecipeUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutFoodInput | DietChartRecipeUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type FoodNutrientCreateNestedManyWithoutNutrientInput = {
    create?: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput> | FoodNutrientCreateWithoutNutrientInput[] | FoodNutrientUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutNutrientInput | FoodNutrientCreateOrConnectWithoutNutrientInput[]
    createMany?: FoodNutrientCreateManyNutrientInputEnvelope
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
  }

  export type RdaCreateNestedManyWithoutNutrientInput = {
    create?: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput> | RdaCreateWithoutNutrientInput[] | RdaUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: RdaCreateOrConnectWithoutNutrientInput | RdaCreateOrConnectWithoutNutrientInput[]
    createMany?: RdaCreateManyNutrientInputEnvelope
    connect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
  }

  export type FoodNutrientUncheckedCreateNestedManyWithoutNutrientInput = {
    create?: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput> | FoodNutrientCreateWithoutNutrientInput[] | FoodNutrientUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutNutrientInput | FoodNutrientCreateOrConnectWithoutNutrientInput[]
    createMany?: FoodNutrientCreateManyNutrientInputEnvelope
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
  }

  export type RdaUncheckedCreateNestedManyWithoutNutrientInput = {
    create?: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput> | RdaCreateWithoutNutrientInput[] | RdaUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: RdaCreateOrConnectWithoutNutrientInput | RdaCreateOrConnectWithoutNutrientInput[]
    createMany?: RdaCreateManyNutrientInputEnvelope
    connect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
  }

  export type FoodNutrientUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput> | FoodNutrientCreateWithoutNutrientInput[] | FoodNutrientUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutNutrientInput | FoodNutrientCreateOrConnectWithoutNutrientInput[]
    upsert?: FoodNutrientUpsertWithWhereUniqueWithoutNutrientInput | FoodNutrientUpsertWithWhereUniqueWithoutNutrientInput[]
    createMany?: FoodNutrientCreateManyNutrientInputEnvelope
    set?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    disconnect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    delete?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    update?: FoodNutrientUpdateWithWhereUniqueWithoutNutrientInput | FoodNutrientUpdateWithWhereUniqueWithoutNutrientInput[]
    updateMany?: FoodNutrientUpdateManyWithWhereWithoutNutrientInput | FoodNutrientUpdateManyWithWhereWithoutNutrientInput[]
    deleteMany?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
  }

  export type RdaUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput> | RdaCreateWithoutNutrientInput[] | RdaUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: RdaCreateOrConnectWithoutNutrientInput | RdaCreateOrConnectWithoutNutrientInput[]
    upsert?: RdaUpsertWithWhereUniqueWithoutNutrientInput | RdaUpsertWithWhereUniqueWithoutNutrientInput[]
    createMany?: RdaCreateManyNutrientInputEnvelope
    set?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    disconnect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    delete?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    connect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    update?: RdaUpdateWithWhereUniqueWithoutNutrientInput | RdaUpdateWithWhereUniqueWithoutNutrientInput[]
    updateMany?: RdaUpdateManyWithWhereWithoutNutrientInput | RdaUpdateManyWithWhereWithoutNutrientInput[]
    deleteMany?: RdaScalarWhereInput | RdaScalarWhereInput[]
  }

  export type FoodNutrientUncheckedUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput> | FoodNutrientCreateWithoutNutrientInput[] | FoodNutrientUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: FoodNutrientCreateOrConnectWithoutNutrientInput | FoodNutrientCreateOrConnectWithoutNutrientInput[]
    upsert?: FoodNutrientUpsertWithWhereUniqueWithoutNutrientInput | FoodNutrientUpsertWithWhereUniqueWithoutNutrientInput[]
    createMany?: FoodNutrientCreateManyNutrientInputEnvelope
    set?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    disconnect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    delete?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    connect?: FoodNutrientWhereUniqueInput | FoodNutrientWhereUniqueInput[]
    update?: FoodNutrientUpdateWithWhereUniqueWithoutNutrientInput | FoodNutrientUpdateWithWhereUniqueWithoutNutrientInput[]
    updateMany?: FoodNutrientUpdateManyWithWhereWithoutNutrientInput | FoodNutrientUpdateManyWithWhereWithoutNutrientInput[]
    deleteMany?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
  }

  export type RdaUncheckedUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput> | RdaCreateWithoutNutrientInput[] | RdaUncheckedCreateWithoutNutrientInput[]
    connectOrCreate?: RdaCreateOrConnectWithoutNutrientInput | RdaCreateOrConnectWithoutNutrientInput[]
    upsert?: RdaUpsertWithWhereUniqueWithoutNutrientInput | RdaUpsertWithWhereUniqueWithoutNutrientInput[]
    createMany?: RdaCreateManyNutrientInputEnvelope
    set?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    disconnect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    delete?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    connect?: RdaWhereUniqueInput | RdaWhereUniqueInput[]
    update?: RdaUpdateWithWhereUniqueWithoutNutrientInput | RdaUpdateWithWhereUniqueWithoutNutrientInput[]
    updateMany?: RdaUpdateManyWithWhereWithoutNutrientInput | RdaUpdateManyWithWhereWithoutNutrientInput[]
    deleteMany?: RdaScalarWhereInput | RdaScalarWhereInput[]
  }

  export type FoodRasaCreateNestedManyWithoutRasaInput = {
    create?: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput> | FoodRasaCreateWithoutRasaInput[] | FoodRasaUncheckedCreateWithoutRasaInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutRasaInput | FoodRasaCreateOrConnectWithoutRasaInput[]
    createMany?: FoodRasaCreateManyRasaInputEnvelope
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
  }

  export type FoodRasaUncheckedCreateNestedManyWithoutRasaInput = {
    create?: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput> | FoodRasaCreateWithoutRasaInput[] | FoodRasaUncheckedCreateWithoutRasaInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutRasaInput | FoodRasaCreateOrConnectWithoutRasaInput[]
    createMany?: FoodRasaCreateManyRasaInputEnvelope
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
  }

  export type FoodRasaUpdateManyWithoutRasaNestedInput = {
    create?: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput> | FoodRasaCreateWithoutRasaInput[] | FoodRasaUncheckedCreateWithoutRasaInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutRasaInput | FoodRasaCreateOrConnectWithoutRasaInput[]
    upsert?: FoodRasaUpsertWithWhereUniqueWithoutRasaInput | FoodRasaUpsertWithWhereUniqueWithoutRasaInput[]
    createMany?: FoodRasaCreateManyRasaInputEnvelope
    set?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    disconnect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    delete?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    update?: FoodRasaUpdateWithWhereUniqueWithoutRasaInput | FoodRasaUpdateWithWhereUniqueWithoutRasaInput[]
    updateMany?: FoodRasaUpdateManyWithWhereWithoutRasaInput | FoodRasaUpdateManyWithWhereWithoutRasaInput[]
    deleteMany?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
  }

  export type FoodRasaUncheckedUpdateManyWithoutRasaNestedInput = {
    create?: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput> | FoodRasaCreateWithoutRasaInput[] | FoodRasaUncheckedCreateWithoutRasaInput[]
    connectOrCreate?: FoodRasaCreateOrConnectWithoutRasaInput | FoodRasaCreateOrConnectWithoutRasaInput[]
    upsert?: FoodRasaUpsertWithWhereUniqueWithoutRasaInput | FoodRasaUpsertWithWhereUniqueWithoutRasaInput[]
    createMany?: FoodRasaCreateManyRasaInputEnvelope
    set?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    disconnect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    delete?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    connect?: FoodRasaWhereUniqueInput | FoodRasaWhereUniqueInput[]
    update?: FoodRasaUpdateWithWhereUniqueWithoutRasaInput | FoodRasaUpdateWithWhereUniqueWithoutRasaInput[]
    updateMany?: FoodRasaUpdateManyWithWhereWithoutRasaInput | FoodRasaUpdateManyWithWhereWithoutRasaInput[]
    deleteMany?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
  }

  export type FoodGunaCreateNestedManyWithoutGunaInput = {
    create?: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput> | FoodGunaCreateWithoutGunaInput[] | FoodGunaUncheckedCreateWithoutGunaInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutGunaInput | FoodGunaCreateOrConnectWithoutGunaInput[]
    createMany?: FoodGunaCreateManyGunaInputEnvelope
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
  }

  export type FoodGunaUncheckedCreateNestedManyWithoutGunaInput = {
    create?: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput> | FoodGunaCreateWithoutGunaInput[] | FoodGunaUncheckedCreateWithoutGunaInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutGunaInput | FoodGunaCreateOrConnectWithoutGunaInput[]
    createMany?: FoodGunaCreateManyGunaInputEnvelope
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
  }

  export type FoodGunaUpdateManyWithoutGunaNestedInput = {
    create?: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput> | FoodGunaCreateWithoutGunaInput[] | FoodGunaUncheckedCreateWithoutGunaInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutGunaInput | FoodGunaCreateOrConnectWithoutGunaInput[]
    upsert?: FoodGunaUpsertWithWhereUniqueWithoutGunaInput | FoodGunaUpsertWithWhereUniqueWithoutGunaInput[]
    createMany?: FoodGunaCreateManyGunaInputEnvelope
    set?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    disconnect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    delete?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    update?: FoodGunaUpdateWithWhereUniqueWithoutGunaInput | FoodGunaUpdateWithWhereUniqueWithoutGunaInput[]
    updateMany?: FoodGunaUpdateManyWithWhereWithoutGunaInput | FoodGunaUpdateManyWithWhereWithoutGunaInput[]
    deleteMany?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
  }

  export type FoodGunaUncheckedUpdateManyWithoutGunaNestedInput = {
    create?: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput> | FoodGunaCreateWithoutGunaInput[] | FoodGunaUncheckedCreateWithoutGunaInput[]
    connectOrCreate?: FoodGunaCreateOrConnectWithoutGunaInput | FoodGunaCreateOrConnectWithoutGunaInput[]
    upsert?: FoodGunaUpsertWithWhereUniqueWithoutGunaInput | FoodGunaUpsertWithWhereUniqueWithoutGunaInput[]
    createMany?: FoodGunaCreateManyGunaInputEnvelope
    set?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    disconnect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    delete?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    connect?: FoodGunaWhereUniqueInput | FoodGunaWhereUniqueInput[]
    update?: FoodGunaUpdateWithWhereUniqueWithoutGunaInput | FoodGunaUpdateWithWhereUniqueWithoutGunaInput[]
    updateMany?: FoodGunaUpdateManyWithWhereWithoutGunaInput | FoodGunaUpdateManyWithWhereWithoutGunaInput[]
    deleteMany?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
  }

  export type FoodDoshaCreateNestedManyWithoutDoshaInput = {
    create?: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput> | FoodDoshaCreateWithoutDoshaInput[] | FoodDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutDoshaInput | FoodDoshaCreateOrConnectWithoutDoshaInput[]
    createMany?: FoodDoshaCreateManyDoshaInputEnvelope
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
  }

  export type PatientDoshaCreateNestedManyWithoutDoshaInput = {
    create?: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput> | PatientDoshaCreateWithoutDoshaInput[] | PatientDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutDoshaInput | PatientDoshaCreateOrConnectWithoutDoshaInput[]
    createMany?: PatientDoshaCreateManyDoshaInputEnvelope
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
  }

  export type FoodDoshaUncheckedCreateNestedManyWithoutDoshaInput = {
    create?: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput> | FoodDoshaCreateWithoutDoshaInput[] | FoodDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutDoshaInput | FoodDoshaCreateOrConnectWithoutDoshaInput[]
    createMany?: FoodDoshaCreateManyDoshaInputEnvelope
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
  }

  export type PatientDoshaUncheckedCreateNestedManyWithoutDoshaInput = {
    create?: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput> | PatientDoshaCreateWithoutDoshaInput[] | PatientDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutDoshaInput | PatientDoshaCreateOrConnectWithoutDoshaInput[]
    createMany?: PatientDoshaCreateManyDoshaInputEnvelope
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
  }

  export type FoodDoshaUpdateManyWithoutDoshaNestedInput = {
    create?: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput> | FoodDoshaCreateWithoutDoshaInput[] | FoodDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutDoshaInput | FoodDoshaCreateOrConnectWithoutDoshaInput[]
    upsert?: FoodDoshaUpsertWithWhereUniqueWithoutDoshaInput | FoodDoshaUpsertWithWhereUniqueWithoutDoshaInput[]
    createMany?: FoodDoshaCreateManyDoshaInputEnvelope
    set?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    disconnect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    delete?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    update?: FoodDoshaUpdateWithWhereUniqueWithoutDoshaInput | FoodDoshaUpdateWithWhereUniqueWithoutDoshaInput[]
    updateMany?: FoodDoshaUpdateManyWithWhereWithoutDoshaInput | FoodDoshaUpdateManyWithWhereWithoutDoshaInput[]
    deleteMany?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
  }

  export type PatientDoshaUpdateManyWithoutDoshaNestedInput = {
    create?: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput> | PatientDoshaCreateWithoutDoshaInput[] | PatientDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutDoshaInput | PatientDoshaCreateOrConnectWithoutDoshaInput[]
    upsert?: PatientDoshaUpsertWithWhereUniqueWithoutDoshaInput | PatientDoshaUpsertWithWhereUniqueWithoutDoshaInput[]
    createMany?: PatientDoshaCreateManyDoshaInputEnvelope
    set?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    disconnect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    delete?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    update?: PatientDoshaUpdateWithWhereUniqueWithoutDoshaInput | PatientDoshaUpdateWithWhereUniqueWithoutDoshaInput[]
    updateMany?: PatientDoshaUpdateManyWithWhereWithoutDoshaInput | PatientDoshaUpdateManyWithWhereWithoutDoshaInput[]
    deleteMany?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
  }

  export type FoodDoshaUncheckedUpdateManyWithoutDoshaNestedInput = {
    create?: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput> | FoodDoshaCreateWithoutDoshaInput[] | FoodDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: FoodDoshaCreateOrConnectWithoutDoshaInput | FoodDoshaCreateOrConnectWithoutDoshaInput[]
    upsert?: FoodDoshaUpsertWithWhereUniqueWithoutDoshaInput | FoodDoshaUpsertWithWhereUniqueWithoutDoshaInput[]
    createMany?: FoodDoshaCreateManyDoshaInputEnvelope
    set?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    disconnect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    delete?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    connect?: FoodDoshaWhereUniqueInput | FoodDoshaWhereUniqueInput[]
    update?: FoodDoshaUpdateWithWhereUniqueWithoutDoshaInput | FoodDoshaUpdateWithWhereUniqueWithoutDoshaInput[]
    updateMany?: FoodDoshaUpdateManyWithWhereWithoutDoshaInput | FoodDoshaUpdateManyWithWhereWithoutDoshaInput[]
    deleteMany?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
  }

  export type PatientDoshaUncheckedUpdateManyWithoutDoshaNestedInput = {
    create?: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput> | PatientDoshaCreateWithoutDoshaInput[] | PatientDoshaUncheckedCreateWithoutDoshaInput[]
    connectOrCreate?: PatientDoshaCreateOrConnectWithoutDoshaInput | PatientDoshaCreateOrConnectWithoutDoshaInput[]
    upsert?: PatientDoshaUpsertWithWhereUniqueWithoutDoshaInput | PatientDoshaUpsertWithWhereUniqueWithoutDoshaInput[]
    createMany?: PatientDoshaCreateManyDoshaInputEnvelope
    set?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    disconnect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    delete?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    connect?: PatientDoshaWhereUniqueInput | PatientDoshaWhereUniqueInput[]
    update?: PatientDoshaUpdateWithWhereUniqueWithoutDoshaInput | PatientDoshaUpdateWithWhereUniqueWithoutDoshaInput[]
    updateMany?: PatientDoshaUpdateManyWithWhereWithoutDoshaInput | PatientDoshaUpdateManyWithWhereWithoutDoshaInput[]
    deleteMany?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
  }

  export type FoodViryaCreateNestedManyWithoutViryaInput = {
    create?: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput> | FoodViryaCreateWithoutViryaInput[] | FoodViryaUncheckedCreateWithoutViryaInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutViryaInput | FoodViryaCreateOrConnectWithoutViryaInput[]
    createMany?: FoodViryaCreateManyViryaInputEnvelope
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
  }

  export type FoodViryaUncheckedCreateNestedManyWithoutViryaInput = {
    create?: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput> | FoodViryaCreateWithoutViryaInput[] | FoodViryaUncheckedCreateWithoutViryaInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutViryaInput | FoodViryaCreateOrConnectWithoutViryaInput[]
    createMany?: FoodViryaCreateManyViryaInputEnvelope
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
  }

  export type FoodViryaUpdateManyWithoutViryaNestedInput = {
    create?: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput> | FoodViryaCreateWithoutViryaInput[] | FoodViryaUncheckedCreateWithoutViryaInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutViryaInput | FoodViryaCreateOrConnectWithoutViryaInput[]
    upsert?: FoodViryaUpsertWithWhereUniqueWithoutViryaInput | FoodViryaUpsertWithWhereUniqueWithoutViryaInput[]
    createMany?: FoodViryaCreateManyViryaInputEnvelope
    set?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    disconnect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    delete?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    update?: FoodViryaUpdateWithWhereUniqueWithoutViryaInput | FoodViryaUpdateWithWhereUniqueWithoutViryaInput[]
    updateMany?: FoodViryaUpdateManyWithWhereWithoutViryaInput | FoodViryaUpdateManyWithWhereWithoutViryaInput[]
    deleteMany?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
  }

  export type FoodViryaUncheckedUpdateManyWithoutViryaNestedInput = {
    create?: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput> | FoodViryaCreateWithoutViryaInput[] | FoodViryaUncheckedCreateWithoutViryaInput[]
    connectOrCreate?: FoodViryaCreateOrConnectWithoutViryaInput | FoodViryaCreateOrConnectWithoutViryaInput[]
    upsert?: FoodViryaUpsertWithWhereUniqueWithoutViryaInput | FoodViryaUpsertWithWhereUniqueWithoutViryaInput[]
    createMany?: FoodViryaCreateManyViryaInputEnvelope
    set?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    disconnect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    delete?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    connect?: FoodViryaWhereUniqueInput | FoodViryaWhereUniqueInput[]
    update?: FoodViryaUpdateWithWhereUniqueWithoutViryaInput | FoodViryaUpdateWithWhereUniqueWithoutViryaInput[]
    updateMany?: FoodViryaUpdateManyWithWhereWithoutViryaInput | FoodViryaUpdateManyWithWhereWithoutViryaInput[]
    deleteMany?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
  }

  export type FoodVipakaCreateNestedManyWithoutVipakaInput = {
    create?: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput> | FoodVipakaCreateWithoutVipakaInput[] | FoodVipakaUncheckedCreateWithoutVipakaInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutVipakaInput | FoodVipakaCreateOrConnectWithoutVipakaInput[]
    createMany?: FoodVipakaCreateManyVipakaInputEnvelope
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
  }

  export type FoodVipakaUncheckedCreateNestedManyWithoutVipakaInput = {
    create?: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput> | FoodVipakaCreateWithoutVipakaInput[] | FoodVipakaUncheckedCreateWithoutVipakaInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutVipakaInput | FoodVipakaCreateOrConnectWithoutVipakaInput[]
    createMany?: FoodVipakaCreateManyVipakaInputEnvelope
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
  }

  export type FoodVipakaUpdateManyWithoutVipakaNestedInput = {
    create?: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput> | FoodVipakaCreateWithoutVipakaInput[] | FoodVipakaUncheckedCreateWithoutVipakaInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutVipakaInput | FoodVipakaCreateOrConnectWithoutVipakaInput[]
    upsert?: FoodVipakaUpsertWithWhereUniqueWithoutVipakaInput | FoodVipakaUpsertWithWhereUniqueWithoutVipakaInput[]
    createMany?: FoodVipakaCreateManyVipakaInputEnvelope
    set?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    disconnect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    delete?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    update?: FoodVipakaUpdateWithWhereUniqueWithoutVipakaInput | FoodVipakaUpdateWithWhereUniqueWithoutVipakaInput[]
    updateMany?: FoodVipakaUpdateManyWithWhereWithoutVipakaInput | FoodVipakaUpdateManyWithWhereWithoutVipakaInput[]
    deleteMany?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
  }

  export type FoodVipakaUncheckedUpdateManyWithoutVipakaNestedInput = {
    create?: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput> | FoodVipakaCreateWithoutVipakaInput[] | FoodVipakaUncheckedCreateWithoutVipakaInput[]
    connectOrCreate?: FoodVipakaCreateOrConnectWithoutVipakaInput | FoodVipakaCreateOrConnectWithoutVipakaInput[]
    upsert?: FoodVipakaUpsertWithWhereUniqueWithoutVipakaInput | FoodVipakaUpsertWithWhereUniqueWithoutVipakaInput[]
    createMany?: FoodVipakaCreateManyVipakaInputEnvelope
    set?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    disconnect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    delete?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    connect?: FoodVipakaWhereUniqueInput | FoodVipakaWhereUniqueInput[]
    update?: FoodVipakaUpdateWithWhereUniqueWithoutVipakaInput | FoodVipakaUpdateWithWhereUniqueWithoutVipakaInput[]
    updateMany?: FoodVipakaUpdateManyWithWhereWithoutVipakaInput | FoodVipakaUpdateManyWithWhereWithoutVipakaInput[]
    deleteMany?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
  }

  export type FoodDigestibilityCreateNestedManyWithoutDigestibilityInput = {
    create?: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput> | FoodDigestibilityCreateWithoutDigestibilityInput[] | FoodDigestibilityUncheckedCreateWithoutDigestibilityInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutDigestibilityInput | FoodDigestibilityCreateOrConnectWithoutDigestibilityInput[]
    createMany?: FoodDigestibilityCreateManyDigestibilityInputEnvelope
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
  }

  export type FoodDigestibilityUncheckedCreateNestedManyWithoutDigestibilityInput = {
    create?: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput> | FoodDigestibilityCreateWithoutDigestibilityInput[] | FoodDigestibilityUncheckedCreateWithoutDigestibilityInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutDigestibilityInput | FoodDigestibilityCreateOrConnectWithoutDigestibilityInput[]
    createMany?: FoodDigestibilityCreateManyDigestibilityInputEnvelope
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
  }

  export type FoodDigestibilityUpdateManyWithoutDigestibilityNestedInput = {
    create?: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput> | FoodDigestibilityCreateWithoutDigestibilityInput[] | FoodDigestibilityUncheckedCreateWithoutDigestibilityInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutDigestibilityInput | FoodDigestibilityCreateOrConnectWithoutDigestibilityInput[]
    upsert?: FoodDigestibilityUpsertWithWhereUniqueWithoutDigestibilityInput | FoodDigestibilityUpsertWithWhereUniqueWithoutDigestibilityInput[]
    createMany?: FoodDigestibilityCreateManyDigestibilityInputEnvelope
    set?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    disconnect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    delete?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    update?: FoodDigestibilityUpdateWithWhereUniqueWithoutDigestibilityInput | FoodDigestibilityUpdateWithWhereUniqueWithoutDigestibilityInput[]
    updateMany?: FoodDigestibilityUpdateManyWithWhereWithoutDigestibilityInput | FoodDigestibilityUpdateManyWithWhereWithoutDigestibilityInput[]
    deleteMany?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
  }

  export type FoodDigestibilityUncheckedUpdateManyWithoutDigestibilityNestedInput = {
    create?: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput> | FoodDigestibilityCreateWithoutDigestibilityInput[] | FoodDigestibilityUncheckedCreateWithoutDigestibilityInput[]
    connectOrCreate?: FoodDigestibilityCreateOrConnectWithoutDigestibilityInput | FoodDigestibilityCreateOrConnectWithoutDigestibilityInput[]
    upsert?: FoodDigestibilityUpsertWithWhereUniqueWithoutDigestibilityInput | FoodDigestibilityUpsertWithWhereUniqueWithoutDigestibilityInput[]
    createMany?: FoodDigestibilityCreateManyDigestibilityInputEnvelope
    set?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    disconnect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    delete?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    connect?: FoodDigestibilityWhereUniqueInput | FoodDigestibilityWhereUniqueInput[]
    update?: FoodDigestibilityUpdateWithWhereUniqueWithoutDigestibilityInput | FoodDigestibilityUpdateWithWhereUniqueWithoutDigestibilityInput[]
    updateMany?: FoodDigestibilityUpdateManyWithWhereWithoutDigestibilityInput | FoodDigestibilityUpdateManyWithWhereWithoutDigestibilityInput[]
    deleteMany?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
  }

  export type NutrientCreateNestedOneWithoutRdaInput = {
    create?: XOR<NutrientCreateWithoutRdaInput, NutrientUncheckedCreateWithoutRdaInput>
    connectOrCreate?: NutrientCreateOrConnectWithoutRdaInput
    connect?: NutrientWhereUniqueInput
  }

  export type EnumAgeGroupFieldUpdateOperationsInput = {
    set?: $Enums.AgeGroup
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NutrientUpdateOneRequiredWithoutRdaNestedInput = {
    create?: XOR<NutrientCreateWithoutRdaInput, NutrientUncheckedCreateWithoutRdaInput>
    connectOrCreate?: NutrientCreateOrConnectWithoutRdaInput
    upsert?: NutrientUpsertWithoutRdaInput
    connect?: NutrientWhereUniqueInput
    update?: XOR<XOR<NutrientUpdateToOneWithWhereWithoutRdaInput, NutrientUpdateWithoutRdaInput>, NutrientUncheckedUpdateWithoutRdaInput>
  }

  export type FoodCreateNestedOneWithoutFoodNutrientInput = {
    create?: XOR<FoodCreateWithoutFoodNutrientInput, FoodUncheckedCreateWithoutFoodNutrientInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodNutrientInput
    connect?: FoodWhereUniqueInput
  }

  export type NutrientCreateNestedOneWithoutFoodNutrientInput = {
    create?: XOR<NutrientCreateWithoutFoodNutrientInput, NutrientUncheckedCreateWithoutFoodNutrientInput>
    connectOrCreate?: NutrientCreateOrConnectWithoutFoodNutrientInput
    connect?: NutrientWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodNutrientNestedInput = {
    create?: XOR<FoodCreateWithoutFoodNutrientInput, FoodUncheckedCreateWithoutFoodNutrientInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodNutrientInput
    upsert?: FoodUpsertWithoutFoodNutrientInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodNutrientInput, FoodUpdateWithoutFoodNutrientInput>, FoodUncheckedUpdateWithoutFoodNutrientInput>
  }

  export type NutrientUpdateOneRequiredWithoutFoodNutrientNestedInput = {
    create?: XOR<NutrientCreateWithoutFoodNutrientInput, NutrientUncheckedCreateWithoutFoodNutrientInput>
    connectOrCreate?: NutrientCreateOrConnectWithoutFoodNutrientInput
    upsert?: NutrientUpsertWithoutFoodNutrientInput
    connect?: NutrientWhereUniqueInput
    update?: XOR<XOR<NutrientUpdateToOneWithWhereWithoutFoodNutrientInput, NutrientUpdateWithoutFoodNutrientInput>, NutrientUncheckedUpdateWithoutFoodNutrientInput>
  }

  export type FoodCreateNestedOneWithoutFoodRasaInput = {
    create?: XOR<FoodCreateWithoutFoodRasaInput, FoodUncheckedCreateWithoutFoodRasaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodRasaInput
    connect?: FoodWhereUniqueInput
  }

  export type RasaCreateNestedOneWithoutFoodRasaInput = {
    create?: XOR<RasaCreateWithoutFoodRasaInput, RasaUncheckedCreateWithoutFoodRasaInput>
    connectOrCreate?: RasaCreateOrConnectWithoutFoodRasaInput
    connect?: RasaWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodRasaNestedInput = {
    create?: XOR<FoodCreateWithoutFoodRasaInput, FoodUncheckedCreateWithoutFoodRasaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodRasaInput
    upsert?: FoodUpsertWithoutFoodRasaInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodRasaInput, FoodUpdateWithoutFoodRasaInput>, FoodUncheckedUpdateWithoutFoodRasaInput>
  }

  export type RasaUpdateOneRequiredWithoutFoodRasaNestedInput = {
    create?: XOR<RasaCreateWithoutFoodRasaInput, RasaUncheckedCreateWithoutFoodRasaInput>
    connectOrCreate?: RasaCreateOrConnectWithoutFoodRasaInput
    upsert?: RasaUpsertWithoutFoodRasaInput
    connect?: RasaWhereUniqueInput
    update?: XOR<XOR<RasaUpdateToOneWithWhereWithoutFoodRasaInput, RasaUpdateWithoutFoodRasaInput>, RasaUncheckedUpdateWithoutFoodRasaInput>
  }

  export type FoodCreateNestedOneWithoutFoodGunaInput = {
    create?: XOR<FoodCreateWithoutFoodGunaInput, FoodUncheckedCreateWithoutFoodGunaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodGunaInput
    connect?: FoodWhereUniqueInput
  }

  export type GunaCreateNestedOneWithoutFoodGunaInput = {
    create?: XOR<GunaCreateWithoutFoodGunaInput, GunaUncheckedCreateWithoutFoodGunaInput>
    connectOrCreate?: GunaCreateOrConnectWithoutFoodGunaInput
    connect?: GunaWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodGunaNestedInput = {
    create?: XOR<FoodCreateWithoutFoodGunaInput, FoodUncheckedCreateWithoutFoodGunaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodGunaInput
    upsert?: FoodUpsertWithoutFoodGunaInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodGunaInput, FoodUpdateWithoutFoodGunaInput>, FoodUncheckedUpdateWithoutFoodGunaInput>
  }

  export type GunaUpdateOneRequiredWithoutFoodGunaNestedInput = {
    create?: XOR<GunaCreateWithoutFoodGunaInput, GunaUncheckedCreateWithoutFoodGunaInput>
    connectOrCreate?: GunaCreateOrConnectWithoutFoodGunaInput
    upsert?: GunaUpsertWithoutFoodGunaInput
    connect?: GunaWhereUniqueInput
    update?: XOR<XOR<GunaUpdateToOneWithWhereWithoutFoodGunaInput, GunaUpdateWithoutFoodGunaInput>, GunaUncheckedUpdateWithoutFoodGunaInput>
  }

  export type FoodCreateNestedOneWithoutFoodDoshaInput = {
    create?: XOR<FoodCreateWithoutFoodDoshaInput, FoodUncheckedCreateWithoutFoodDoshaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodDoshaInput
    connect?: FoodWhereUniqueInput
  }

  export type DoshaCreateNestedOneWithoutFoodDoshaInput = {
    create?: XOR<DoshaCreateWithoutFoodDoshaInput, DoshaUncheckedCreateWithoutFoodDoshaInput>
    connectOrCreate?: DoshaCreateOrConnectWithoutFoodDoshaInput
    connect?: DoshaWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodDoshaNestedInput = {
    create?: XOR<FoodCreateWithoutFoodDoshaInput, FoodUncheckedCreateWithoutFoodDoshaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodDoshaInput
    upsert?: FoodUpsertWithoutFoodDoshaInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodDoshaInput, FoodUpdateWithoutFoodDoshaInput>, FoodUncheckedUpdateWithoutFoodDoshaInput>
  }

  export type DoshaUpdateOneRequiredWithoutFoodDoshaNestedInput = {
    create?: XOR<DoshaCreateWithoutFoodDoshaInput, DoshaUncheckedCreateWithoutFoodDoshaInput>
    connectOrCreate?: DoshaCreateOrConnectWithoutFoodDoshaInput
    upsert?: DoshaUpsertWithoutFoodDoshaInput
    connect?: DoshaWhereUniqueInput
    update?: XOR<XOR<DoshaUpdateToOneWithWhereWithoutFoodDoshaInput, DoshaUpdateWithoutFoodDoshaInput>, DoshaUncheckedUpdateWithoutFoodDoshaInput>
  }

  export type PatientCreateNestedOneWithoutPatientDoshaInput = {
    create?: XOR<PatientCreateWithoutPatientDoshaInput, PatientUncheckedCreateWithoutPatientDoshaInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientDoshaInput
    connect?: PatientWhereUniqueInput
  }

  export type DoshaCreateNestedOneWithoutPatientDoshaInput = {
    create?: XOR<DoshaCreateWithoutPatientDoshaInput, DoshaUncheckedCreateWithoutPatientDoshaInput>
    connectOrCreate?: DoshaCreateOrConnectWithoutPatientDoshaInput
    connect?: DoshaWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutPatientDoshaNestedInput = {
    create?: XOR<PatientCreateWithoutPatientDoshaInput, PatientUncheckedCreateWithoutPatientDoshaInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientDoshaInput
    upsert?: PatientUpsertWithoutPatientDoshaInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPatientDoshaInput, PatientUpdateWithoutPatientDoshaInput>, PatientUncheckedUpdateWithoutPatientDoshaInput>
  }

  export type DoshaUpdateOneRequiredWithoutPatientDoshaNestedInput = {
    create?: XOR<DoshaCreateWithoutPatientDoshaInput, DoshaUncheckedCreateWithoutPatientDoshaInput>
    connectOrCreate?: DoshaCreateOrConnectWithoutPatientDoshaInput
    upsert?: DoshaUpsertWithoutPatientDoshaInput
    connect?: DoshaWhereUniqueInput
    update?: XOR<XOR<DoshaUpdateToOneWithWhereWithoutPatientDoshaInput, DoshaUpdateWithoutPatientDoshaInput>, DoshaUncheckedUpdateWithoutPatientDoshaInput>
  }

  export type FoodCreateNestedOneWithoutFoodViryaInput = {
    create?: XOR<FoodCreateWithoutFoodViryaInput, FoodUncheckedCreateWithoutFoodViryaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodViryaInput
    connect?: FoodWhereUniqueInput
  }

  export type ViryaCreateNestedOneWithoutFoodViryaInput = {
    create?: XOR<ViryaCreateWithoutFoodViryaInput, ViryaUncheckedCreateWithoutFoodViryaInput>
    connectOrCreate?: ViryaCreateOrConnectWithoutFoodViryaInput
    connect?: ViryaWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodViryaNestedInput = {
    create?: XOR<FoodCreateWithoutFoodViryaInput, FoodUncheckedCreateWithoutFoodViryaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodViryaInput
    upsert?: FoodUpsertWithoutFoodViryaInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodViryaInput, FoodUpdateWithoutFoodViryaInput>, FoodUncheckedUpdateWithoutFoodViryaInput>
  }

  export type ViryaUpdateOneRequiredWithoutFoodViryaNestedInput = {
    create?: XOR<ViryaCreateWithoutFoodViryaInput, ViryaUncheckedCreateWithoutFoodViryaInput>
    connectOrCreate?: ViryaCreateOrConnectWithoutFoodViryaInput
    upsert?: ViryaUpsertWithoutFoodViryaInput
    connect?: ViryaWhereUniqueInput
    update?: XOR<XOR<ViryaUpdateToOneWithWhereWithoutFoodViryaInput, ViryaUpdateWithoutFoodViryaInput>, ViryaUncheckedUpdateWithoutFoodViryaInput>
  }

  export type FoodCreateNestedOneWithoutFoodVipakaInput = {
    create?: XOR<FoodCreateWithoutFoodVipakaInput, FoodUncheckedCreateWithoutFoodVipakaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodVipakaInput
    connect?: FoodWhereUniqueInput
  }

  export type VipakaCreateNestedOneWithoutFoodVipakaInput = {
    create?: XOR<VipakaCreateWithoutFoodVipakaInput, VipakaUncheckedCreateWithoutFoodVipakaInput>
    connectOrCreate?: VipakaCreateOrConnectWithoutFoodVipakaInput
    connect?: VipakaWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodVipakaNestedInput = {
    create?: XOR<FoodCreateWithoutFoodVipakaInput, FoodUncheckedCreateWithoutFoodVipakaInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodVipakaInput
    upsert?: FoodUpsertWithoutFoodVipakaInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodVipakaInput, FoodUpdateWithoutFoodVipakaInput>, FoodUncheckedUpdateWithoutFoodVipakaInput>
  }

  export type VipakaUpdateOneRequiredWithoutFoodVipakaNestedInput = {
    create?: XOR<VipakaCreateWithoutFoodVipakaInput, VipakaUncheckedCreateWithoutFoodVipakaInput>
    connectOrCreate?: VipakaCreateOrConnectWithoutFoodVipakaInput
    upsert?: VipakaUpsertWithoutFoodVipakaInput
    connect?: VipakaWhereUniqueInput
    update?: XOR<XOR<VipakaUpdateToOneWithWhereWithoutFoodVipakaInput, VipakaUpdateWithoutFoodVipakaInput>, VipakaUncheckedUpdateWithoutFoodVipakaInput>
  }

  export type FoodCreateNestedOneWithoutFoodDigestibilityInput = {
    create?: XOR<FoodCreateWithoutFoodDigestibilityInput, FoodUncheckedCreateWithoutFoodDigestibilityInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodDigestibilityInput
    connect?: FoodWhereUniqueInput
  }

  export type DigestibilityCreateNestedOneWithoutFoodDigestibilityInput = {
    create?: XOR<DigestibilityCreateWithoutFoodDigestibilityInput, DigestibilityUncheckedCreateWithoutFoodDigestibilityInput>
    connectOrCreate?: DigestibilityCreateOrConnectWithoutFoodDigestibilityInput
    connect?: DigestibilityWhereUniqueInput
  }

  export type FoodUpdateOneRequiredWithoutFoodDigestibilityNestedInput = {
    create?: XOR<FoodCreateWithoutFoodDigestibilityInput, FoodUncheckedCreateWithoutFoodDigestibilityInput>
    connectOrCreate?: FoodCreateOrConnectWithoutFoodDigestibilityInput
    upsert?: FoodUpsertWithoutFoodDigestibilityInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutFoodDigestibilityInput, FoodUpdateWithoutFoodDigestibilityInput>, FoodUncheckedUpdateWithoutFoodDigestibilityInput>
  }

  export type DigestibilityUpdateOneRequiredWithoutFoodDigestibilityNestedInput = {
    create?: XOR<DigestibilityCreateWithoutFoodDigestibilityInput, DigestibilityUncheckedCreateWithoutFoodDigestibilityInput>
    connectOrCreate?: DigestibilityCreateOrConnectWithoutFoodDigestibilityInput
    upsert?: DigestibilityUpsertWithoutFoodDigestibilityInput
    connect?: DigestibilityWhereUniqueInput
    update?: XOR<XOR<DigestibilityUpdateToOneWithWhereWithoutFoodDigestibilityInput, DigestibilityUpdateWithoutFoodDigestibilityInput>, DigestibilityUncheckedUpdateWithoutFoodDigestibilityInput>
  }

  export type CuisineCreateNestedOneWithoutRecipeInput = {
    create?: XOR<CuisineCreateWithoutRecipeInput, CuisineUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: CuisineCreateOrConnectWithoutRecipeInput
    connect?: CuisineWhereUniqueInput
  }

  export type RecipeIngredientCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type DietChartRecipeCreateNestedManyWithoutRecipeInput = {
    create?: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput> | DietChartRecipeCreateWithoutRecipeInput[] | DietChartRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutRecipeInput | DietChartRecipeCreateOrConnectWithoutRecipeInput[]
    createMany?: DietChartRecipeCreateManyRecipeInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type DietChartRecipeUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput> | DietChartRecipeCreateWithoutRecipeInput[] | DietChartRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutRecipeInput | DietChartRecipeCreateOrConnectWithoutRecipeInput[]
    createMany?: DietChartRecipeCreateManyRecipeInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type CuisineUpdateOneRequiredWithoutRecipeNestedInput = {
    create?: XOR<CuisineCreateWithoutRecipeInput, CuisineUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: CuisineCreateOrConnectWithoutRecipeInput
    upsert?: CuisineUpsertWithoutRecipeInput
    connect?: CuisineWhereUniqueInput
    update?: XOR<XOR<CuisineUpdateToOneWithWhereWithoutRecipeInput, CuisineUpdateWithoutRecipeInput>, CuisineUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type DietChartRecipeUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput> | DietChartRecipeCreateWithoutRecipeInput[] | DietChartRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutRecipeInput | DietChartRecipeCreateOrConnectWithoutRecipeInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutRecipeInput | DietChartRecipeUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: DietChartRecipeCreateManyRecipeInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutRecipeInput | DietChartRecipeUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutRecipeInput | DietChartRecipeUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput> | DietChartRecipeCreateWithoutRecipeInput[] | DietChartRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutRecipeInput | DietChartRecipeCreateOrConnectWithoutRecipeInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutRecipeInput | DietChartRecipeUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: DietChartRecipeCreateManyRecipeInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutRecipeInput | DietChartRecipeUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutRecipeInput | DietChartRecipeUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutRecipeIngredientInput = {
    create?: XOR<RecipeCreateWithoutRecipeIngredientInput, RecipeUncheckedCreateWithoutRecipeIngredientInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutRecipeIngredientInput
    connect?: RecipeWhereUniqueInput
  }

  export type FoodCreateNestedOneWithoutRecipeIngredientInput = {
    create?: XOR<FoodCreateWithoutRecipeIngredientInput, FoodUncheckedCreateWithoutRecipeIngredientInput>
    connectOrCreate?: FoodCreateOrConnectWithoutRecipeIngredientInput
    connect?: FoodWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutRecipeIngredientNestedInput = {
    create?: XOR<RecipeCreateWithoutRecipeIngredientInput, RecipeUncheckedCreateWithoutRecipeIngredientInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutRecipeIngredientInput
    upsert?: RecipeUpsertWithoutRecipeIngredientInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutRecipeIngredientInput, RecipeUpdateWithoutRecipeIngredientInput>, RecipeUncheckedUpdateWithoutRecipeIngredientInput>
  }

  export type FoodUpdateOneRequiredWithoutRecipeIngredientNestedInput = {
    create?: XOR<FoodCreateWithoutRecipeIngredientInput, FoodUncheckedCreateWithoutRecipeIngredientInput>
    connectOrCreate?: FoodCreateOrConnectWithoutRecipeIngredientInput
    upsert?: FoodUpsertWithoutRecipeIngredientInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutRecipeIngredientInput, FoodUpdateWithoutRecipeIngredientInput>, FoodUncheckedUpdateWithoutRecipeIngredientInput>
  }

  export type DietChartRecipeCreateNestedManyWithoutDietChartInput = {
    create?: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput> | DietChartRecipeCreateWithoutDietChartInput[] | DietChartRecipeUncheckedCreateWithoutDietChartInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutDietChartInput | DietChartRecipeCreateOrConnectWithoutDietChartInput[]
    createMany?: DietChartRecipeCreateManyDietChartInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type DietChartRecipeUncheckedCreateNestedManyWithoutDietChartInput = {
    create?: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput> | DietChartRecipeCreateWithoutDietChartInput[] | DietChartRecipeUncheckedCreateWithoutDietChartInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutDietChartInput | DietChartRecipeCreateOrConnectWithoutDietChartInput[]
    createMany?: DietChartRecipeCreateManyDietChartInputEnvelope
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
  }

  export type DietChartRecipeUpdateManyWithoutDietChartNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput> | DietChartRecipeCreateWithoutDietChartInput[] | DietChartRecipeUncheckedCreateWithoutDietChartInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutDietChartInput | DietChartRecipeCreateOrConnectWithoutDietChartInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutDietChartInput | DietChartRecipeUpsertWithWhereUniqueWithoutDietChartInput[]
    createMany?: DietChartRecipeCreateManyDietChartInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutDietChartInput | DietChartRecipeUpdateWithWhereUniqueWithoutDietChartInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutDietChartInput | DietChartRecipeUpdateManyWithWhereWithoutDietChartInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutDietChartNestedInput = {
    create?: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput> | DietChartRecipeCreateWithoutDietChartInput[] | DietChartRecipeUncheckedCreateWithoutDietChartInput[]
    connectOrCreate?: DietChartRecipeCreateOrConnectWithoutDietChartInput | DietChartRecipeCreateOrConnectWithoutDietChartInput[]
    upsert?: DietChartRecipeUpsertWithWhereUniqueWithoutDietChartInput | DietChartRecipeUpsertWithWhereUniqueWithoutDietChartInput[]
    createMany?: DietChartRecipeCreateManyDietChartInputEnvelope
    set?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    disconnect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    delete?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    connect?: DietChartRecipeWhereUniqueInput | DietChartRecipeWhereUniqueInput[]
    update?: DietChartRecipeUpdateWithWhereUniqueWithoutDietChartInput | DietChartRecipeUpdateWithWhereUniqueWithoutDietChartInput[]
    updateMany?: DietChartRecipeUpdateManyWithWhereWithoutDietChartInput | DietChartRecipeUpdateManyWithWhereWithoutDietChartInput[]
    deleteMany?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
  }

  export type DietChartCreateNestedOneWithoutDietChartRecipeInput = {
    create?: XOR<DietChartCreateWithoutDietChartRecipeInput, DietChartUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: DietChartCreateOrConnectWithoutDietChartRecipeInput
    connect?: DietChartWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutDietChartRecipeInput = {
    create?: XOR<RecipeCreateWithoutDietChartRecipeInput, RecipeUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutDietChartRecipeInput
    connect?: RecipeWhereUniqueInput
  }

  export type FoodCreateNestedOneWithoutDietChartRecipeInput = {
    create?: XOR<FoodCreateWithoutDietChartRecipeInput, FoodUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: FoodCreateOrConnectWithoutDietChartRecipeInput
    connect?: FoodWhereUniqueInput
  }

  export type EnumMealTimeFieldUpdateOperationsInput = {
    set?: $Enums.MealTime
  }

  export type DietChartUpdateOneRequiredWithoutDietChartRecipeNestedInput = {
    create?: XOR<DietChartCreateWithoutDietChartRecipeInput, DietChartUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: DietChartCreateOrConnectWithoutDietChartRecipeInput
    upsert?: DietChartUpsertWithoutDietChartRecipeInput
    connect?: DietChartWhereUniqueInput
    update?: XOR<XOR<DietChartUpdateToOneWithWhereWithoutDietChartRecipeInput, DietChartUpdateWithoutDietChartRecipeInput>, DietChartUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type RecipeUpdateOneRequiredWithoutDietChartRecipeNestedInput = {
    create?: XOR<RecipeCreateWithoutDietChartRecipeInput, RecipeUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutDietChartRecipeInput
    upsert?: RecipeUpsertWithoutDietChartRecipeInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutDietChartRecipeInput, RecipeUpdateWithoutDietChartRecipeInput>, RecipeUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type FoodUpdateOneWithoutDietChartRecipeNestedInput = {
    create?: XOR<FoodCreateWithoutDietChartRecipeInput, FoodUncheckedCreateWithoutDietChartRecipeInput>
    connectOrCreate?: FoodCreateOrConnectWithoutDietChartRecipeInput
    upsert?: FoodUpsertWithoutDietChartRecipeInput
    disconnect?: FoodWhereInput | boolean
    delete?: FoodWhereInput | boolean
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutDietChartRecipeInput, FoodUpdateWithoutDietChartRecipeInput>, FoodUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDietaryHabitsFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryHabits | EnumDietaryHabitsFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    not?: NestedEnumDietaryHabitsFilter<$PrismaModel> | $Enums.DietaryHabits
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDigestionQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestionQuality | EnumDigestionQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestionQualityFilter<$PrismaModel> | $Enums.DigestionQuality
  }

  export type NestedEnumBowelMovementFilter<$PrismaModel = never> = {
    equals?: $Enums.BowelMovement | EnumBowelMovementFieldRefInput<$PrismaModel>
    in?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    notIn?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    not?: NestedEnumBowelMovementFilter<$PrismaModel> | $Enums.BowelMovement
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDietaryHabitsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryHabits | EnumDietaryHabitsFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DietaryHabits[] | ListEnumDietaryHabitsFieldRefInput<$PrismaModel>
    not?: NestedEnumDietaryHabitsWithAggregatesFilter<$PrismaModel> | $Enums.DietaryHabits
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDietaryHabitsFilter<$PrismaModel>
    _max?: NestedEnumDietaryHabitsFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDigestionQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestionQuality | EnumDigestionQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestionQuality[] | ListEnumDigestionQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestionQualityWithAggregatesFilter<$PrismaModel> | $Enums.DigestionQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDigestionQualityFilter<$PrismaModel>
    _max?: NestedEnumDigestionQualityFilter<$PrismaModel>
  }

  export type NestedEnumBowelMovementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BowelMovement | EnumBowelMovementFieldRefInput<$PrismaModel>
    in?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    notIn?: $Enums.BowelMovement[] | ListEnumBowelMovementFieldRefInput<$PrismaModel>
    not?: NestedEnumBowelMovementWithAggregatesFilter<$PrismaModel> | $Enums.BowelMovement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBowelMovementFilter<$PrismaModel>
    _max?: NestedEnumBowelMovementFilter<$PrismaModel>
  }

  export type NestedEnumAgeGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeGroup | EnumAgeGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeGroupFilter<$PrismaModel> | $Enums.AgeGroup
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumAgeGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeGroup | EnumAgeGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeGroup[] | ListEnumAgeGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeGroupWithAggregatesFilter<$PrismaModel> | $Enums.AgeGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeGroupFilter<$PrismaModel>
    _max?: NestedEnumAgeGroupFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumMealTimeFilter<$PrismaModel = never> = {
    equals?: $Enums.MealTime | EnumMealTimeFieldRefInput<$PrismaModel>
    in?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    not?: NestedEnumMealTimeFilter<$PrismaModel> | $Enums.MealTime
  }

  export type NestedEnumMealTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MealTime | EnumMealTimeFieldRefInput<$PrismaModel>
    in?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MealTime[] | ListEnumMealTimeFieldRefInput<$PrismaModel>
    not?: NestedEnumMealTimeWithAggregatesFilter<$PrismaModel> | $Enums.MealTime
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMealTimeFilter<$PrismaModel>
    _max?: NestedEnumMealTimeFilter<$PrismaModel>
  }

  export type DoctorPatientCreateWithoutDoctorInput = {
    patient: PatientCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateWithoutDoctorInput = {
    patient_id: string
  }

  export type DoctorPatientCreateOrConnectWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    create: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPatientCreateManyDoctorInputEnvelope = {
    data: DoctorPatientCreateManyDoctorInput | DoctorPatientCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    update: XOR<DoctorPatientUpdateWithoutDoctorInput, DoctorPatientUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    data: XOR<DoctorPatientUpdateWithoutDoctorInput, DoctorPatientUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorPatientUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorPatientScalarWhereInput
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorPatientScalarWhereInput = {
    AND?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
    OR?: DoctorPatientScalarWhereInput[]
    NOT?: DoctorPatientScalarWhereInput | DoctorPatientScalarWhereInput[]
    doctor_id?: StringFilter<"DoctorPatient"> | string
    patient_id?: StringFilter<"DoctorPatient"> | string
  }

  export type PatientDoshaCreateWithoutPatientInput = {
    dosha: DoshaCreateNestedOneWithoutPatientDoshaInput
  }

  export type PatientDoshaUncheckedCreateWithoutPatientInput = {
    dosha_id: string
  }

  export type PatientDoshaCreateOrConnectWithoutPatientInput = {
    where: PatientDoshaWhereUniqueInput
    create: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput>
  }

  export type PatientDoshaCreateManyPatientInputEnvelope = {
    data: PatientDoshaCreateManyPatientInput | PatientDoshaCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DoctorPatientCreateWithoutPatientInput = {
    doctor: DoctorCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateWithoutPatientInput = {
    doctor_id: string
  }

  export type DoctorPatientCreateOrConnectWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    create: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput>
  }

  export type DoctorPatientCreateManyPatientInputEnvelope = {
    data: DoctorPatientCreateManyPatientInput | DoctorPatientCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientDoshaUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientDoshaWhereUniqueInput
    update: XOR<PatientDoshaUpdateWithoutPatientInput, PatientDoshaUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientDoshaCreateWithoutPatientInput, PatientDoshaUncheckedCreateWithoutPatientInput>
  }

  export type PatientDoshaUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientDoshaWhereUniqueInput
    data: XOR<PatientDoshaUpdateWithoutPatientInput, PatientDoshaUncheckedUpdateWithoutPatientInput>
  }

  export type PatientDoshaUpdateManyWithWhereWithoutPatientInput = {
    where: PatientDoshaScalarWhereInput
    data: XOR<PatientDoshaUpdateManyMutationInput, PatientDoshaUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientDoshaScalarWhereInput = {
    AND?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
    OR?: PatientDoshaScalarWhereInput[]
    NOT?: PatientDoshaScalarWhereInput | PatientDoshaScalarWhereInput[]
    patient_id?: StringFilter<"PatientDosha"> | string
    dosha_id?: StringFilter<"PatientDosha"> | string
  }

  export type DoctorPatientUpsertWithWhereUniqueWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    update: XOR<DoctorPatientUpdateWithoutPatientInput, DoctorPatientUncheckedUpdateWithoutPatientInput>
    create: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput>
  }

  export type DoctorPatientUpdateWithWhereUniqueWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    data: XOR<DoctorPatientUpdateWithoutPatientInput, DoctorPatientUncheckedUpdateWithoutPatientInput>
  }

  export type DoctorPatientUpdateManyWithWhereWithoutPatientInput = {
    where: DoctorPatientScalarWhereInput
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyWithoutPatientInput>
  }

  export type DoctorCreateWithoutDoctorPatientInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorUncheckedCreateWithoutDoctorPatientInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorCreateOrConnectWithoutDoctorPatientInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
  }

  export type PatientCreateWithoutDoctorPatientInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    PatientDosha?: PatientDoshaCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDoctorPatientInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    PatientDosha?: PatientDoshaUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDoctorPatientInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
  }

  export type DoctorUpsertWithoutDoctorPatientInput = {
    update: XOR<DoctorUpdateWithoutDoctorPatientInput, DoctorUncheckedUpdateWithoutDoctorPatientInput>
    create: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutDoctorPatientInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutDoctorPatientInput, DoctorUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type DoctorUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUncheckedUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutDoctorPatientInput = {
    update: XOR<PatientUpdateWithoutDoctorPatientInput, PatientUncheckedUpdateWithoutDoctorPatientInput>
    create: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDoctorPatientInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDoctorPatientInput, PatientUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type PatientUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    PatientDosha?: PatientDoshaUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    PatientDosha?: PatientDoshaUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type RecipeCreateWithoutCuisineInput = {
    recipe_id?: string
    name: string
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutCuisineInput = {
    recipe_id?: string
    name: string
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutCuisineInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput>
  }

  export type RecipeCreateManyCuisineInputEnvelope = {
    data: RecipeCreateManyCuisineInput | RecipeCreateManyCuisineInput[]
    skipDuplicates?: boolean
  }

  export type RecipeUpsertWithWhereUniqueWithoutCuisineInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCuisineInput, RecipeUncheckedUpdateWithoutCuisineInput>
    create: XOR<RecipeCreateWithoutCuisineInput, RecipeUncheckedCreateWithoutCuisineInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCuisineInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCuisineInput, RecipeUncheckedUpdateWithoutCuisineInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCuisineInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutCuisineInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    recipe_id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    cuisine_id?: StringFilter<"Recipe"> | string
  }

  export type FoodNutrientCreateWithoutFoodInput = {
    amount: number
    nutrient: NutrientCreateNestedOneWithoutFoodNutrientInput
  }

  export type FoodNutrientUncheckedCreateWithoutFoodInput = {
    nutrient_id: string
    amount: number
  }

  export type FoodNutrientCreateOrConnectWithoutFoodInput = {
    where: FoodNutrientWhereUniqueInput
    create: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput>
  }

  export type FoodNutrientCreateManyFoodInputEnvelope = {
    data: FoodNutrientCreateManyFoodInput | FoodNutrientCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodRasaCreateWithoutFoodInput = {
    rasa: RasaCreateNestedOneWithoutFoodRasaInput
  }

  export type FoodRasaUncheckedCreateWithoutFoodInput = {
    rasa_id: string
  }

  export type FoodRasaCreateOrConnectWithoutFoodInput = {
    where: FoodRasaWhereUniqueInput
    create: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput>
  }

  export type FoodRasaCreateManyFoodInputEnvelope = {
    data: FoodRasaCreateManyFoodInput | FoodRasaCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodGunaCreateWithoutFoodInput = {
    guna: GunaCreateNestedOneWithoutFoodGunaInput
  }

  export type FoodGunaUncheckedCreateWithoutFoodInput = {
    guna_id: string
  }

  export type FoodGunaCreateOrConnectWithoutFoodInput = {
    where: FoodGunaWhereUniqueInput
    create: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput>
  }

  export type FoodGunaCreateManyFoodInputEnvelope = {
    data: FoodGunaCreateManyFoodInput | FoodGunaCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodDoshaCreateWithoutFoodInput = {
    dosha: DoshaCreateNestedOneWithoutFoodDoshaInput
  }

  export type FoodDoshaUncheckedCreateWithoutFoodInput = {
    dosha_id: string
  }

  export type FoodDoshaCreateOrConnectWithoutFoodInput = {
    where: FoodDoshaWhereUniqueInput
    create: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput>
  }

  export type FoodDoshaCreateManyFoodInputEnvelope = {
    data: FoodDoshaCreateManyFoodInput | FoodDoshaCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodViryaCreateWithoutFoodInput = {
    virya: ViryaCreateNestedOneWithoutFoodViryaInput
  }

  export type FoodViryaUncheckedCreateWithoutFoodInput = {
    virya_id: string
  }

  export type FoodViryaCreateOrConnectWithoutFoodInput = {
    where: FoodViryaWhereUniqueInput
    create: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput>
  }

  export type FoodViryaCreateManyFoodInputEnvelope = {
    data: FoodViryaCreateManyFoodInput | FoodViryaCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodVipakaCreateWithoutFoodInput = {
    vipaka: VipakaCreateNestedOneWithoutFoodVipakaInput
  }

  export type FoodVipakaUncheckedCreateWithoutFoodInput = {
    vipaka_id: string
  }

  export type FoodVipakaCreateOrConnectWithoutFoodInput = {
    where: FoodVipakaWhereUniqueInput
    create: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput>
  }

  export type FoodVipakaCreateManyFoodInputEnvelope = {
    data: FoodVipakaCreateManyFoodInput | FoodVipakaCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodDigestibilityCreateWithoutFoodInput = {
    digestibility: DigestibilityCreateNestedOneWithoutFoodDigestibilityInput
  }

  export type FoodDigestibilityUncheckedCreateWithoutFoodInput = {
    digestibility_id: string
  }

  export type FoodDigestibilityCreateOrConnectWithoutFoodInput = {
    where: FoodDigestibilityWhereUniqueInput
    create: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput>
  }

  export type FoodDigestibilityCreateManyFoodInputEnvelope = {
    data: FoodDigestibilityCreateManyFoodInput | FoodDigestibilityCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type RecipeIngredientCreateWithoutFoodInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutRecipeIngredientInput
  }

  export type RecipeIngredientUncheckedCreateWithoutFoodInput = {
    recipe_id: string
    quantity: number
  }

  export type RecipeIngredientCreateOrConnectWithoutFoodInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput>
  }

  export type RecipeIngredientCreateManyFoodInputEnvelope = {
    data: RecipeIngredientCreateManyFoodInput | RecipeIngredientCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type DietChartRecipeCreateWithoutFoodInput = {
    mealTime: $Enums.MealTime
    quantity?: number | null
    dietChart: DietChartCreateNestedOneWithoutDietChartRecipeInput
    recipe: RecipeCreateNestedOneWithoutDietChartRecipeInput
  }

  export type DietChartRecipeUncheckedCreateWithoutFoodInput = {
    chart_id: string
    recipe_id: string
    mealTime: $Enums.MealTime
    quantity?: number | null
  }

  export type DietChartRecipeCreateOrConnectWithoutFoodInput = {
    where: DietChartRecipeWhereUniqueInput
    create: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput>
  }

  export type DietChartRecipeCreateManyFoodInputEnvelope = {
    data: DietChartRecipeCreateManyFoodInput | DietChartRecipeCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodNutrientUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodNutrientWhereUniqueInput
    update: XOR<FoodNutrientUpdateWithoutFoodInput, FoodNutrientUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodNutrientCreateWithoutFoodInput, FoodNutrientUncheckedCreateWithoutFoodInput>
  }

  export type FoodNutrientUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodNutrientWhereUniqueInput
    data: XOR<FoodNutrientUpdateWithoutFoodInput, FoodNutrientUncheckedUpdateWithoutFoodInput>
  }

  export type FoodNutrientUpdateManyWithWhereWithoutFoodInput = {
    where: FoodNutrientScalarWhereInput
    data: XOR<FoodNutrientUpdateManyMutationInput, FoodNutrientUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodNutrientScalarWhereInput = {
    AND?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
    OR?: FoodNutrientScalarWhereInput[]
    NOT?: FoodNutrientScalarWhereInput | FoodNutrientScalarWhereInput[]
    food_id?: StringFilter<"FoodNutrient"> | string
    nutrient_id?: StringFilter<"FoodNutrient"> | string
    amount?: FloatFilter<"FoodNutrient"> | number
  }

  export type FoodRasaUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodRasaWhereUniqueInput
    update: XOR<FoodRasaUpdateWithoutFoodInput, FoodRasaUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodRasaCreateWithoutFoodInput, FoodRasaUncheckedCreateWithoutFoodInput>
  }

  export type FoodRasaUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodRasaWhereUniqueInput
    data: XOR<FoodRasaUpdateWithoutFoodInput, FoodRasaUncheckedUpdateWithoutFoodInput>
  }

  export type FoodRasaUpdateManyWithWhereWithoutFoodInput = {
    where: FoodRasaScalarWhereInput
    data: XOR<FoodRasaUpdateManyMutationInput, FoodRasaUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodRasaScalarWhereInput = {
    AND?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
    OR?: FoodRasaScalarWhereInput[]
    NOT?: FoodRasaScalarWhereInput | FoodRasaScalarWhereInput[]
    food_id?: StringFilter<"FoodRasa"> | string
    rasa_id?: StringFilter<"FoodRasa"> | string
  }

  export type FoodGunaUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodGunaWhereUniqueInput
    update: XOR<FoodGunaUpdateWithoutFoodInput, FoodGunaUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodGunaCreateWithoutFoodInput, FoodGunaUncheckedCreateWithoutFoodInput>
  }

  export type FoodGunaUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodGunaWhereUniqueInput
    data: XOR<FoodGunaUpdateWithoutFoodInput, FoodGunaUncheckedUpdateWithoutFoodInput>
  }

  export type FoodGunaUpdateManyWithWhereWithoutFoodInput = {
    where: FoodGunaScalarWhereInput
    data: XOR<FoodGunaUpdateManyMutationInput, FoodGunaUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodGunaScalarWhereInput = {
    AND?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
    OR?: FoodGunaScalarWhereInput[]
    NOT?: FoodGunaScalarWhereInput | FoodGunaScalarWhereInput[]
    food_id?: StringFilter<"FoodGuna"> | string
    guna_id?: StringFilter<"FoodGuna"> | string
  }

  export type FoodDoshaUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodDoshaWhereUniqueInput
    update: XOR<FoodDoshaUpdateWithoutFoodInput, FoodDoshaUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodDoshaCreateWithoutFoodInput, FoodDoshaUncheckedCreateWithoutFoodInput>
  }

  export type FoodDoshaUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodDoshaWhereUniqueInput
    data: XOR<FoodDoshaUpdateWithoutFoodInput, FoodDoshaUncheckedUpdateWithoutFoodInput>
  }

  export type FoodDoshaUpdateManyWithWhereWithoutFoodInput = {
    where: FoodDoshaScalarWhereInput
    data: XOR<FoodDoshaUpdateManyMutationInput, FoodDoshaUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodDoshaScalarWhereInput = {
    AND?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
    OR?: FoodDoshaScalarWhereInput[]
    NOT?: FoodDoshaScalarWhereInput | FoodDoshaScalarWhereInput[]
    food_id?: StringFilter<"FoodDosha"> | string
    dosha_id?: StringFilter<"FoodDosha"> | string
  }

  export type FoodViryaUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodViryaWhereUniqueInput
    update: XOR<FoodViryaUpdateWithoutFoodInput, FoodViryaUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodViryaCreateWithoutFoodInput, FoodViryaUncheckedCreateWithoutFoodInput>
  }

  export type FoodViryaUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodViryaWhereUniqueInput
    data: XOR<FoodViryaUpdateWithoutFoodInput, FoodViryaUncheckedUpdateWithoutFoodInput>
  }

  export type FoodViryaUpdateManyWithWhereWithoutFoodInput = {
    where: FoodViryaScalarWhereInput
    data: XOR<FoodViryaUpdateManyMutationInput, FoodViryaUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodViryaScalarWhereInput = {
    AND?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
    OR?: FoodViryaScalarWhereInput[]
    NOT?: FoodViryaScalarWhereInput | FoodViryaScalarWhereInput[]
    food_id?: StringFilter<"FoodVirya"> | string
    virya_id?: StringFilter<"FoodVirya"> | string
  }

  export type FoodVipakaUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodVipakaWhereUniqueInput
    update: XOR<FoodVipakaUpdateWithoutFoodInput, FoodVipakaUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodVipakaCreateWithoutFoodInput, FoodVipakaUncheckedCreateWithoutFoodInput>
  }

  export type FoodVipakaUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodVipakaWhereUniqueInput
    data: XOR<FoodVipakaUpdateWithoutFoodInput, FoodVipakaUncheckedUpdateWithoutFoodInput>
  }

  export type FoodVipakaUpdateManyWithWhereWithoutFoodInput = {
    where: FoodVipakaScalarWhereInput
    data: XOR<FoodVipakaUpdateManyMutationInput, FoodVipakaUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodVipakaScalarWhereInput = {
    AND?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
    OR?: FoodVipakaScalarWhereInput[]
    NOT?: FoodVipakaScalarWhereInput | FoodVipakaScalarWhereInput[]
    food_id?: StringFilter<"FoodVipaka"> | string
    vipaka_id?: StringFilter<"FoodVipaka"> | string
  }

  export type FoodDigestibilityUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodDigestibilityWhereUniqueInput
    update: XOR<FoodDigestibilityUpdateWithoutFoodInput, FoodDigestibilityUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodDigestibilityCreateWithoutFoodInput, FoodDigestibilityUncheckedCreateWithoutFoodInput>
  }

  export type FoodDigestibilityUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodDigestibilityWhereUniqueInput
    data: XOR<FoodDigestibilityUpdateWithoutFoodInput, FoodDigestibilityUncheckedUpdateWithoutFoodInput>
  }

  export type FoodDigestibilityUpdateManyWithWhereWithoutFoodInput = {
    where: FoodDigestibilityScalarWhereInput
    data: XOR<FoodDigestibilityUpdateManyMutationInput, FoodDigestibilityUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodDigestibilityScalarWhereInput = {
    AND?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
    OR?: FoodDigestibilityScalarWhereInput[]
    NOT?: FoodDigestibilityScalarWhereInput | FoodDigestibilityScalarWhereInput[]
    food_id?: StringFilter<"FoodDigestibility"> | string
    digestibility_id?: StringFilter<"FoodDigestibility"> | string
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutFoodInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutFoodInput, RecipeIngredientUncheckedUpdateWithoutFoodInput>
    create: XOR<RecipeIngredientCreateWithoutFoodInput, RecipeIngredientUncheckedCreateWithoutFoodInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutFoodInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutFoodInput, RecipeIngredientUncheckedUpdateWithoutFoodInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutFoodInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutFoodInput>
  }

  export type RecipeIngredientScalarWhereInput = {
    AND?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    OR?: RecipeIngredientScalarWhereInput[]
    NOT?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    recipe_id?: StringFilter<"RecipeIngredient"> | string
    food_id?: StringFilter<"RecipeIngredient"> | string
    quantity?: FloatFilter<"RecipeIngredient"> | number
  }

  export type DietChartRecipeUpsertWithWhereUniqueWithoutFoodInput = {
    where: DietChartRecipeWhereUniqueInput
    update: XOR<DietChartRecipeUpdateWithoutFoodInput, DietChartRecipeUncheckedUpdateWithoutFoodInput>
    create: XOR<DietChartRecipeCreateWithoutFoodInput, DietChartRecipeUncheckedCreateWithoutFoodInput>
  }

  export type DietChartRecipeUpdateWithWhereUniqueWithoutFoodInput = {
    where: DietChartRecipeWhereUniqueInput
    data: XOR<DietChartRecipeUpdateWithoutFoodInput, DietChartRecipeUncheckedUpdateWithoutFoodInput>
  }

  export type DietChartRecipeUpdateManyWithWhereWithoutFoodInput = {
    where: DietChartRecipeScalarWhereInput
    data: XOR<DietChartRecipeUpdateManyMutationInput, DietChartRecipeUncheckedUpdateManyWithoutFoodInput>
  }

  export type DietChartRecipeScalarWhereInput = {
    AND?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
    OR?: DietChartRecipeScalarWhereInput[]
    NOT?: DietChartRecipeScalarWhereInput | DietChartRecipeScalarWhereInput[]
    chart_id?: StringFilter<"DietChartRecipe"> | string
    recipe_id?: StringFilter<"DietChartRecipe"> | string
    mealTime?: EnumMealTimeFilter<"DietChartRecipe"> | $Enums.MealTime
    food_id?: StringNullableFilter<"DietChartRecipe"> | string | null
    quantity?: FloatNullableFilter<"DietChartRecipe"> | number | null
  }

  export type FoodNutrientCreateWithoutNutrientInput = {
    amount: number
    food: FoodCreateNestedOneWithoutFoodNutrientInput
  }

  export type FoodNutrientUncheckedCreateWithoutNutrientInput = {
    food_id: string
    amount: number
  }

  export type FoodNutrientCreateOrConnectWithoutNutrientInput = {
    where: FoodNutrientWhereUniqueInput
    create: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput>
  }

  export type FoodNutrientCreateManyNutrientInputEnvelope = {
    data: FoodNutrientCreateManyNutrientInput | FoodNutrientCreateManyNutrientInput[]
    skipDuplicates?: boolean
  }

  export type RdaCreateWithoutNutrientInput = {
    rda_id?: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
  }

  export type RdaUncheckedCreateWithoutNutrientInput = {
    rda_id?: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
  }

  export type RdaCreateOrConnectWithoutNutrientInput = {
    where: RdaWhereUniqueInput
    create: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput>
  }

  export type RdaCreateManyNutrientInputEnvelope = {
    data: RdaCreateManyNutrientInput | RdaCreateManyNutrientInput[]
    skipDuplicates?: boolean
  }

  export type FoodNutrientUpsertWithWhereUniqueWithoutNutrientInput = {
    where: FoodNutrientWhereUniqueInput
    update: XOR<FoodNutrientUpdateWithoutNutrientInput, FoodNutrientUncheckedUpdateWithoutNutrientInput>
    create: XOR<FoodNutrientCreateWithoutNutrientInput, FoodNutrientUncheckedCreateWithoutNutrientInput>
  }

  export type FoodNutrientUpdateWithWhereUniqueWithoutNutrientInput = {
    where: FoodNutrientWhereUniqueInput
    data: XOR<FoodNutrientUpdateWithoutNutrientInput, FoodNutrientUncheckedUpdateWithoutNutrientInput>
  }

  export type FoodNutrientUpdateManyWithWhereWithoutNutrientInput = {
    where: FoodNutrientScalarWhereInput
    data: XOR<FoodNutrientUpdateManyMutationInput, FoodNutrientUncheckedUpdateManyWithoutNutrientInput>
  }

  export type RdaUpsertWithWhereUniqueWithoutNutrientInput = {
    where: RdaWhereUniqueInput
    update: XOR<RdaUpdateWithoutNutrientInput, RdaUncheckedUpdateWithoutNutrientInput>
    create: XOR<RdaCreateWithoutNutrientInput, RdaUncheckedCreateWithoutNutrientInput>
  }

  export type RdaUpdateWithWhereUniqueWithoutNutrientInput = {
    where: RdaWhereUniqueInput
    data: XOR<RdaUpdateWithoutNutrientInput, RdaUncheckedUpdateWithoutNutrientInput>
  }

  export type RdaUpdateManyWithWhereWithoutNutrientInput = {
    where: RdaScalarWhereInput
    data: XOR<RdaUpdateManyMutationInput, RdaUncheckedUpdateManyWithoutNutrientInput>
  }

  export type RdaScalarWhereInput = {
    AND?: RdaScalarWhereInput | RdaScalarWhereInput[]
    OR?: RdaScalarWhereInput[]
    NOT?: RdaScalarWhereInput | RdaScalarWhereInput[]
    rda_id?: StringFilter<"Rda"> | string
    nutrient_id?: StringFilter<"Rda"> | string
    age_group?: EnumAgeGroupFilter<"Rda"> | $Enums.AgeGroup
    gender?: EnumGenderFilter<"Rda"> | $Enums.Gender
    amount?: FloatFilter<"Rda"> | number
  }

  export type FoodRasaCreateWithoutRasaInput = {
    food: FoodCreateNestedOneWithoutFoodRasaInput
  }

  export type FoodRasaUncheckedCreateWithoutRasaInput = {
    food_id: string
  }

  export type FoodRasaCreateOrConnectWithoutRasaInput = {
    where: FoodRasaWhereUniqueInput
    create: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput>
  }

  export type FoodRasaCreateManyRasaInputEnvelope = {
    data: FoodRasaCreateManyRasaInput | FoodRasaCreateManyRasaInput[]
    skipDuplicates?: boolean
  }

  export type FoodRasaUpsertWithWhereUniqueWithoutRasaInput = {
    where: FoodRasaWhereUniqueInput
    update: XOR<FoodRasaUpdateWithoutRasaInput, FoodRasaUncheckedUpdateWithoutRasaInput>
    create: XOR<FoodRasaCreateWithoutRasaInput, FoodRasaUncheckedCreateWithoutRasaInput>
  }

  export type FoodRasaUpdateWithWhereUniqueWithoutRasaInput = {
    where: FoodRasaWhereUniqueInput
    data: XOR<FoodRasaUpdateWithoutRasaInput, FoodRasaUncheckedUpdateWithoutRasaInput>
  }

  export type FoodRasaUpdateManyWithWhereWithoutRasaInput = {
    where: FoodRasaScalarWhereInput
    data: XOR<FoodRasaUpdateManyMutationInput, FoodRasaUncheckedUpdateManyWithoutRasaInput>
  }

  export type FoodGunaCreateWithoutGunaInput = {
    food: FoodCreateNestedOneWithoutFoodGunaInput
  }

  export type FoodGunaUncheckedCreateWithoutGunaInput = {
    food_id: string
  }

  export type FoodGunaCreateOrConnectWithoutGunaInput = {
    where: FoodGunaWhereUniqueInput
    create: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput>
  }

  export type FoodGunaCreateManyGunaInputEnvelope = {
    data: FoodGunaCreateManyGunaInput | FoodGunaCreateManyGunaInput[]
    skipDuplicates?: boolean
  }

  export type FoodGunaUpsertWithWhereUniqueWithoutGunaInput = {
    where: FoodGunaWhereUniqueInput
    update: XOR<FoodGunaUpdateWithoutGunaInput, FoodGunaUncheckedUpdateWithoutGunaInput>
    create: XOR<FoodGunaCreateWithoutGunaInput, FoodGunaUncheckedCreateWithoutGunaInput>
  }

  export type FoodGunaUpdateWithWhereUniqueWithoutGunaInput = {
    where: FoodGunaWhereUniqueInput
    data: XOR<FoodGunaUpdateWithoutGunaInput, FoodGunaUncheckedUpdateWithoutGunaInput>
  }

  export type FoodGunaUpdateManyWithWhereWithoutGunaInput = {
    where: FoodGunaScalarWhereInput
    data: XOR<FoodGunaUpdateManyMutationInput, FoodGunaUncheckedUpdateManyWithoutGunaInput>
  }

  export type FoodDoshaCreateWithoutDoshaInput = {
    food: FoodCreateNestedOneWithoutFoodDoshaInput
  }

  export type FoodDoshaUncheckedCreateWithoutDoshaInput = {
    food_id: string
  }

  export type FoodDoshaCreateOrConnectWithoutDoshaInput = {
    where: FoodDoshaWhereUniqueInput
    create: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput>
  }

  export type FoodDoshaCreateManyDoshaInputEnvelope = {
    data: FoodDoshaCreateManyDoshaInput | FoodDoshaCreateManyDoshaInput[]
    skipDuplicates?: boolean
  }

  export type PatientDoshaCreateWithoutDoshaInput = {
    patient: PatientCreateNestedOneWithoutPatientDoshaInput
  }

  export type PatientDoshaUncheckedCreateWithoutDoshaInput = {
    patient_id: string
  }

  export type PatientDoshaCreateOrConnectWithoutDoshaInput = {
    where: PatientDoshaWhereUniqueInput
    create: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput>
  }

  export type PatientDoshaCreateManyDoshaInputEnvelope = {
    data: PatientDoshaCreateManyDoshaInput | PatientDoshaCreateManyDoshaInput[]
    skipDuplicates?: boolean
  }

  export type FoodDoshaUpsertWithWhereUniqueWithoutDoshaInput = {
    where: FoodDoshaWhereUniqueInput
    update: XOR<FoodDoshaUpdateWithoutDoshaInput, FoodDoshaUncheckedUpdateWithoutDoshaInput>
    create: XOR<FoodDoshaCreateWithoutDoshaInput, FoodDoshaUncheckedCreateWithoutDoshaInput>
  }

  export type FoodDoshaUpdateWithWhereUniqueWithoutDoshaInput = {
    where: FoodDoshaWhereUniqueInput
    data: XOR<FoodDoshaUpdateWithoutDoshaInput, FoodDoshaUncheckedUpdateWithoutDoshaInput>
  }

  export type FoodDoshaUpdateManyWithWhereWithoutDoshaInput = {
    where: FoodDoshaScalarWhereInput
    data: XOR<FoodDoshaUpdateManyMutationInput, FoodDoshaUncheckedUpdateManyWithoutDoshaInput>
  }

  export type PatientDoshaUpsertWithWhereUniqueWithoutDoshaInput = {
    where: PatientDoshaWhereUniqueInput
    update: XOR<PatientDoshaUpdateWithoutDoshaInput, PatientDoshaUncheckedUpdateWithoutDoshaInput>
    create: XOR<PatientDoshaCreateWithoutDoshaInput, PatientDoshaUncheckedCreateWithoutDoshaInput>
  }

  export type PatientDoshaUpdateWithWhereUniqueWithoutDoshaInput = {
    where: PatientDoshaWhereUniqueInput
    data: XOR<PatientDoshaUpdateWithoutDoshaInput, PatientDoshaUncheckedUpdateWithoutDoshaInput>
  }

  export type PatientDoshaUpdateManyWithWhereWithoutDoshaInput = {
    where: PatientDoshaScalarWhereInput
    data: XOR<PatientDoshaUpdateManyMutationInput, PatientDoshaUncheckedUpdateManyWithoutDoshaInput>
  }

  export type FoodViryaCreateWithoutViryaInput = {
    food: FoodCreateNestedOneWithoutFoodViryaInput
  }

  export type FoodViryaUncheckedCreateWithoutViryaInput = {
    food_id: string
  }

  export type FoodViryaCreateOrConnectWithoutViryaInput = {
    where: FoodViryaWhereUniqueInput
    create: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput>
  }

  export type FoodViryaCreateManyViryaInputEnvelope = {
    data: FoodViryaCreateManyViryaInput | FoodViryaCreateManyViryaInput[]
    skipDuplicates?: boolean
  }

  export type FoodViryaUpsertWithWhereUniqueWithoutViryaInput = {
    where: FoodViryaWhereUniqueInput
    update: XOR<FoodViryaUpdateWithoutViryaInput, FoodViryaUncheckedUpdateWithoutViryaInput>
    create: XOR<FoodViryaCreateWithoutViryaInput, FoodViryaUncheckedCreateWithoutViryaInput>
  }

  export type FoodViryaUpdateWithWhereUniqueWithoutViryaInput = {
    where: FoodViryaWhereUniqueInput
    data: XOR<FoodViryaUpdateWithoutViryaInput, FoodViryaUncheckedUpdateWithoutViryaInput>
  }

  export type FoodViryaUpdateManyWithWhereWithoutViryaInput = {
    where: FoodViryaScalarWhereInput
    data: XOR<FoodViryaUpdateManyMutationInput, FoodViryaUncheckedUpdateManyWithoutViryaInput>
  }

  export type FoodVipakaCreateWithoutVipakaInput = {
    food: FoodCreateNestedOneWithoutFoodVipakaInput
  }

  export type FoodVipakaUncheckedCreateWithoutVipakaInput = {
    food_id: string
  }

  export type FoodVipakaCreateOrConnectWithoutVipakaInput = {
    where: FoodVipakaWhereUniqueInput
    create: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput>
  }

  export type FoodVipakaCreateManyVipakaInputEnvelope = {
    data: FoodVipakaCreateManyVipakaInput | FoodVipakaCreateManyVipakaInput[]
    skipDuplicates?: boolean
  }

  export type FoodVipakaUpsertWithWhereUniqueWithoutVipakaInput = {
    where: FoodVipakaWhereUniqueInput
    update: XOR<FoodVipakaUpdateWithoutVipakaInput, FoodVipakaUncheckedUpdateWithoutVipakaInput>
    create: XOR<FoodVipakaCreateWithoutVipakaInput, FoodVipakaUncheckedCreateWithoutVipakaInput>
  }

  export type FoodVipakaUpdateWithWhereUniqueWithoutVipakaInput = {
    where: FoodVipakaWhereUniqueInput
    data: XOR<FoodVipakaUpdateWithoutVipakaInput, FoodVipakaUncheckedUpdateWithoutVipakaInput>
  }

  export type FoodVipakaUpdateManyWithWhereWithoutVipakaInput = {
    where: FoodVipakaScalarWhereInput
    data: XOR<FoodVipakaUpdateManyMutationInput, FoodVipakaUncheckedUpdateManyWithoutVipakaInput>
  }

  export type FoodDigestibilityCreateWithoutDigestibilityInput = {
    food: FoodCreateNestedOneWithoutFoodDigestibilityInput
  }

  export type FoodDigestibilityUncheckedCreateWithoutDigestibilityInput = {
    food_id: string
  }

  export type FoodDigestibilityCreateOrConnectWithoutDigestibilityInput = {
    where: FoodDigestibilityWhereUniqueInput
    create: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput>
  }

  export type FoodDigestibilityCreateManyDigestibilityInputEnvelope = {
    data: FoodDigestibilityCreateManyDigestibilityInput | FoodDigestibilityCreateManyDigestibilityInput[]
    skipDuplicates?: boolean
  }

  export type FoodDigestibilityUpsertWithWhereUniqueWithoutDigestibilityInput = {
    where: FoodDigestibilityWhereUniqueInput
    update: XOR<FoodDigestibilityUpdateWithoutDigestibilityInput, FoodDigestibilityUncheckedUpdateWithoutDigestibilityInput>
    create: XOR<FoodDigestibilityCreateWithoutDigestibilityInput, FoodDigestibilityUncheckedCreateWithoutDigestibilityInput>
  }

  export type FoodDigestibilityUpdateWithWhereUniqueWithoutDigestibilityInput = {
    where: FoodDigestibilityWhereUniqueInput
    data: XOR<FoodDigestibilityUpdateWithoutDigestibilityInput, FoodDigestibilityUncheckedUpdateWithoutDigestibilityInput>
  }

  export type FoodDigestibilityUpdateManyWithWhereWithoutDigestibilityInput = {
    where: FoodDigestibilityScalarWhereInput
    data: XOR<FoodDigestibilityUpdateManyMutationInput, FoodDigestibilityUncheckedUpdateManyWithoutDigestibilityInput>
  }

  export type NutrientCreateWithoutRdaInput = {
    nutrient_id?: string
    name: string
    unit: string
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutNutrientInput
  }

  export type NutrientUncheckedCreateWithoutRdaInput = {
    nutrient_id?: string
    name: string
    unit: string
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutNutrientInput
  }

  export type NutrientCreateOrConnectWithoutRdaInput = {
    where: NutrientWhereUniqueInput
    create: XOR<NutrientCreateWithoutRdaInput, NutrientUncheckedCreateWithoutRdaInput>
  }

  export type NutrientUpsertWithoutRdaInput = {
    update: XOR<NutrientUpdateWithoutRdaInput, NutrientUncheckedUpdateWithoutRdaInput>
    create: XOR<NutrientCreateWithoutRdaInput, NutrientUncheckedCreateWithoutRdaInput>
    where?: NutrientWhereInput
  }

  export type NutrientUpdateToOneWithWhereWithoutRdaInput = {
    where?: NutrientWhereInput
    data: XOR<NutrientUpdateWithoutRdaInput, NutrientUncheckedUpdateWithoutRdaInput>
  }

  export type NutrientUpdateWithoutRdaInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    FoodNutrient?: FoodNutrientUpdateManyWithoutNutrientNestedInput
  }

  export type NutrientUncheckedUpdateWithoutRdaInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutNutrientNestedInput
  }

  export type FoodCreateWithoutFoodNutrientInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodNutrientInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodNutrientInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodNutrientInput, FoodUncheckedCreateWithoutFoodNutrientInput>
  }

  export type NutrientCreateWithoutFoodNutrientInput = {
    nutrient_id?: string
    name: string
    unit: string
    Rda?: RdaCreateNestedManyWithoutNutrientInput
  }

  export type NutrientUncheckedCreateWithoutFoodNutrientInput = {
    nutrient_id?: string
    name: string
    unit: string
    Rda?: RdaUncheckedCreateNestedManyWithoutNutrientInput
  }

  export type NutrientCreateOrConnectWithoutFoodNutrientInput = {
    where: NutrientWhereUniqueInput
    create: XOR<NutrientCreateWithoutFoodNutrientInput, NutrientUncheckedCreateWithoutFoodNutrientInput>
  }

  export type FoodUpsertWithoutFoodNutrientInput = {
    update: XOR<FoodUpdateWithoutFoodNutrientInput, FoodUncheckedUpdateWithoutFoodNutrientInput>
    create: XOR<FoodCreateWithoutFoodNutrientInput, FoodUncheckedCreateWithoutFoodNutrientInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodNutrientInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodNutrientInput, FoodUncheckedUpdateWithoutFoodNutrientInput>
  }

  export type FoodUpdateWithoutFoodNutrientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodNutrientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type NutrientUpsertWithoutFoodNutrientInput = {
    update: XOR<NutrientUpdateWithoutFoodNutrientInput, NutrientUncheckedUpdateWithoutFoodNutrientInput>
    create: XOR<NutrientCreateWithoutFoodNutrientInput, NutrientUncheckedCreateWithoutFoodNutrientInput>
    where?: NutrientWhereInput
  }

  export type NutrientUpdateToOneWithWhereWithoutFoodNutrientInput = {
    where?: NutrientWhereInput
    data: XOR<NutrientUpdateWithoutFoodNutrientInput, NutrientUncheckedUpdateWithoutFoodNutrientInput>
  }

  export type NutrientUpdateWithoutFoodNutrientInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    Rda?: RdaUpdateManyWithoutNutrientNestedInput
  }

  export type NutrientUncheckedUpdateWithoutFoodNutrientInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    Rda?: RdaUncheckedUpdateManyWithoutNutrientNestedInput
  }

  export type FoodCreateWithoutFoodRasaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodRasaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodRasaInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodRasaInput, FoodUncheckedCreateWithoutFoodRasaInput>
  }

  export type RasaCreateWithoutFoodRasaInput = {
    rasa_id?: string
    name: string
  }

  export type RasaUncheckedCreateWithoutFoodRasaInput = {
    rasa_id?: string
    name: string
  }

  export type RasaCreateOrConnectWithoutFoodRasaInput = {
    where: RasaWhereUniqueInput
    create: XOR<RasaCreateWithoutFoodRasaInput, RasaUncheckedCreateWithoutFoodRasaInput>
  }

  export type FoodUpsertWithoutFoodRasaInput = {
    update: XOR<FoodUpdateWithoutFoodRasaInput, FoodUncheckedUpdateWithoutFoodRasaInput>
    create: XOR<FoodCreateWithoutFoodRasaInput, FoodUncheckedCreateWithoutFoodRasaInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodRasaInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodRasaInput, FoodUncheckedUpdateWithoutFoodRasaInput>
  }

  export type FoodUpdateWithoutFoodRasaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodRasaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type RasaUpsertWithoutFoodRasaInput = {
    update: XOR<RasaUpdateWithoutFoodRasaInput, RasaUncheckedUpdateWithoutFoodRasaInput>
    create: XOR<RasaCreateWithoutFoodRasaInput, RasaUncheckedCreateWithoutFoodRasaInput>
    where?: RasaWhereInput
  }

  export type RasaUpdateToOneWithWhereWithoutFoodRasaInput = {
    where?: RasaWhereInput
    data: XOR<RasaUpdateWithoutFoodRasaInput, RasaUncheckedUpdateWithoutFoodRasaInput>
  }

  export type RasaUpdateWithoutFoodRasaInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RasaUncheckedUpdateWithoutFoodRasaInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateWithoutFoodGunaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodGunaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodGunaInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodGunaInput, FoodUncheckedCreateWithoutFoodGunaInput>
  }

  export type GunaCreateWithoutFoodGunaInput = {
    guna_id?: string
    name: string
  }

  export type GunaUncheckedCreateWithoutFoodGunaInput = {
    guna_id?: string
    name: string
  }

  export type GunaCreateOrConnectWithoutFoodGunaInput = {
    where: GunaWhereUniqueInput
    create: XOR<GunaCreateWithoutFoodGunaInput, GunaUncheckedCreateWithoutFoodGunaInput>
  }

  export type FoodUpsertWithoutFoodGunaInput = {
    update: XOR<FoodUpdateWithoutFoodGunaInput, FoodUncheckedUpdateWithoutFoodGunaInput>
    create: XOR<FoodCreateWithoutFoodGunaInput, FoodUncheckedCreateWithoutFoodGunaInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodGunaInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodGunaInput, FoodUncheckedUpdateWithoutFoodGunaInput>
  }

  export type FoodUpdateWithoutFoodGunaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodGunaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type GunaUpsertWithoutFoodGunaInput = {
    update: XOR<GunaUpdateWithoutFoodGunaInput, GunaUncheckedUpdateWithoutFoodGunaInput>
    create: XOR<GunaCreateWithoutFoodGunaInput, GunaUncheckedCreateWithoutFoodGunaInput>
    where?: GunaWhereInput
  }

  export type GunaUpdateToOneWithWhereWithoutFoodGunaInput = {
    where?: GunaWhereInput
    data: XOR<GunaUpdateWithoutFoodGunaInput, GunaUncheckedUpdateWithoutFoodGunaInput>
  }

  export type GunaUpdateWithoutFoodGunaInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GunaUncheckedUpdateWithoutFoodGunaInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateWithoutFoodDoshaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodDoshaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodDoshaInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodDoshaInput, FoodUncheckedCreateWithoutFoodDoshaInput>
  }

  export type DoshaCreateWithoutFoodDoshaInput = {
    dosha_id?: string
    name: string
    PatientDosha?: PatientDoshaCreateNestedManyWithoutDoshaInput
  }

  export type DoshaUncheckedCreateWithoutFoodDoshaInput = {
    dosha_id?: string
    name: string
    PatientDosha?: PatientDoshaUncheckedCreateNestedManyWithoutDoshaInput
  }

  export type DoshaCreateOrConnectWithoutFoodDoshaInput = {
    where: DoshaWhereUniqueInput
    create: XOR<DoshaCreateWithoutFoodDoshaInput, DoshaUncheckedCreateWithoutFoodDoshaInput>
  }

  export type FoodUpsertWithoutFoodDoshaInput = {
    update: XOR<FoodUpdateWithoutFoodDoshaInput, FoodUncheckedUpdateWithoutFoodDoshaInput>
    create: XOR<FoodCreateWithoutFoodDoshaInput, FoodUncheckedCreateWithoutFoodDoshaInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodDoshaInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodDoshaInput, FoodUncheckedUpdateWithoutFoodDoshaInput>
  }

  export type FoodUpdateWithoutFoodDoshaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodDoshaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type DoshaUpsertWithoutFoodDoshaInput = {
    update: XOR<DoshaUpdateWithoutFoodDoshaInput, DoshaUncheckedUpdateWithoutFoodDoshaInput>
    create: XOR<DoshaCreateWithoutFoodDoshaInput, DoshaUncheckedCreateWithoutFoodDoshaInput>
    where?: DoshaWhereInput
  }

  export type DoshaUpdateToOneWithWhereWithoutFoodDoshaInput = {
    where?: DoshaWhereInput
    data: XOR<DoshaUpdateWithoutFoodDoshaInput, DoshaUncheckedUpdateWithoutFoodDoshaInput>
  }

  export type DoshaUpdateWithoutFoodDoshaInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    PatientDosha?: PatientDoshaUpdateManyWithoutDoshaNestedInput
  }

  export type DoshaUncheckedUpdateWithoutFoodDoshaInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    PatientDosha?: PatientDoshaUncheckedUpdateManyWithoutDoshaNestedInput
  }

  export type PatientCreateWithoutPatientDoshaInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPatientDoshaInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    height?: number | null
    weight?: number | null
    dietary_habits?: $Enums.DietaryHabits
    mealFrequency?: number
    waterIntake?: number
    digestionQuality?: $Enums.DigestionQuality
    bowelMovement?: $Enums.BowelMovement
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPatientDoshaInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPatientDoshaInput, PatientUncheckedCreateWithoutPatientDoshaInput>
  }

  export type DoshaCreateWithoutPatientDoshaInput = {
    dosha_id?: string
    name: string
    FoodDosha?: FoodDoshaCreateNestedManyWithoutDoshaInput
  }

  export type DoshaUncheckedCreateWithoutPatientDoshaInput = {
    dosha_id?: string
    name: string
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutDoshaInput
  }

  export type DoshaCreateOrConnectWithoutPatientDoshaInput = {
    where: DoshaWhereUniqueInput
    create: XOR<DoshaCreateWithoutPatientDoshaInput, DoshaUncheckedCreateWithoutPatientDoshaInput>
  }

  export type PatientUpsertWithoutPatientDoshaInput = {
    update: XOR<PatientUpdateWithoutPatientDoshaInput, PatientUncheckedUpdateWithoutPatientDoshaInput>
    create: XOR<PatientCreateWithoutPatientDoshaInput, PatientUncheckedCreateWithoutPatientDoshaInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPatientDoshaInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPatientDoshaInput, PatientUncheckedUpdateWithoutPatientDoshaInput>
  }

  export type PatientUpdateWithoutPatientDoshaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    DoctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPatientDoshaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dietary_habits?: EnumDietaryHabitsFieldUpdateOperationsInput | $Enums.DietaryHabits
    mealFrequency?: IntFieldUpdateOperationsInput | number
    waterIntake?: FloatFieldUpdateOperationsInput | number
    digestionQuality?: EnumDigestionQualityFieldUpdateOperationsInput | $Enums.DigestionQuality
    bowelMovement?: EnumBowelMovementFieldUpdateOperationsInput | $Enums.BowelMovement
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoshaUpsertWithoutPatientDoshaInput = {
    update: XOR<DoshaUpdateWithoutPatientDoshaInput, DoshaUncheckedUpdateWithoutPatientDoshaInput>
    create: XOR<DoshaCreateWithoutPatientDoshaInput, DoshaUncheckedCreateWithoutPatientDoshaInput>
    where?: DoshaWhereInput
  }

  export type DoshaUpdateToOneWithWhereWithoutPatientDoshaInput = {
    where?: DoshaWhereInput
    data: XOR<DoshaUpdateWithoutPatientDoshaInput, DoshaUncheckedUpdateWithoutPatientDoshaInput>
  }

  export type DoshaUpdateWithoutPatientDoshaInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDosha?: FoodDoshaUpdateManyWithoutDoshaNestedInput
  }

  export type DoshaUncheckedUpdateWithoutPatientDoshaInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutDoshaNestedInput
  }

  export type FoodCreateWithoutFoodViryaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodViryaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodViryaInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodViryaInput, FoodUncheckedCreateWithoutFoodViryaInput>
  }

  export type ViryaCreateWithoutFoodViryaInput = {
    virya_id?: string
    name: string
  }

  export type ViryaUncheckedCreateWithoutFoodViryaInput = {
    virya_id?: string
    name: string
  }

  export type ViryaCreateOrConnectWithoutFoodViryaInput = {
    where: ViryaWhereUniqueInput
    create: XOR<ViryaCreateWithoutFoodViryaInput, ViryaUncheckedCreateWithoutFoodViryaInput>
  }

  export type FoodUpsertWithoutFoodViryaInput = {
    update: XOR<FoodUpdateWithoutFoodViryaInput, FoodUncheckedUpdateWithoutFoodViryaInput>
    create: XOR<FoodCreateWithoutFoodViryaInput, FoodUncheckedCreateWithoutFoodViryaInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodViryaInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodViryaInput, FoodUncheckedUpdateWithoutFoodViryaInput>
  }

  export type FoodUpdateWithoutFoodViryaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodViryaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type ViryaUpsertWithoutFoodViryaInput = {
    update: XOR<ViryaUpdateWithoutFoodViryaInput, ViryaUncheckedUpdateWithoutFoodViryaInput>
    create: XOR<ViryaCreateWithoutFoodViryaInput, ViryaUncheckedCreateWithoutFoodViryaInput>
    where?: ViryaWhereInput
  }

  export type ViryaUpdateToOneWithWhereWithoutFoodViryaInput = {
    where?: ViryaWhereInput
    data: XOR<ViryaUpdateWithoutFoodViryaInput, ViryaUncheckedUpdateWithoutFoodViryaInput>
  }

  export type ViryaUpdateWithoutFoodViryaInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ViryaUncheckedUpdateWithoutFoodViryaInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateWithoutFoodVipakaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodVipakaInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodVipakaInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodVipakaInput, FoodUncheckedCreateWithoutFoodVipakaInput>
  }

  export type VipakaCreateWithoutFoodVipakaInput = {
    vipaka_id?: string
    name: string
  }

  export type VipakaUncheckedCreateWithoutFoodVipakaInput = {
    vipaka_id?: string
    name: string
  }

  export type VipakaCreateOrConnectWithoutFoodVipakaInput = {
    where: VipakaWhereUniqueInput
    create: XOR<VipakaCreateWithoutFoodVipakaInput, VipakaUncheckedCreateWithoutFoodVipakaInput>
  }

  export type FoodUpsertWithoutFoodVipakaInput = {
    update: XOR<FoodUpdateWithoutFoodVipakaInput, FoodUncheckedUpdateWithoutFoodVipakaInput>
    create: XOR<FoodCreateWithoutFoodVipakaInput, FoodUncheckedCreateWithoutFoodVipakaInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodVipakaInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodVipakaInput, FoodUncheckedUpdateWithoutFoodVipakaInput>
  }

  export type FoodUpdateWithoutFoodVipakaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodVipakaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type VipakaUpsertWithoutFoodVipakaInput = {
    update: XOR<VipakaUpdateWithoutFoodVipakaInput, VipakaUncheckedUpdateWithoutFoodVipakaInput>
    create: XOR<VipakaCreateWithoutFoodVipakaInput, VipakaUncheckedCreateWithoutFoodVipakaInput>
    where?: VipakaWhereInput
  }

  export type VipakaUpdateToOneWithWhereWithoutFoodVipakaInput = {
    where?: VipakaWhereInput
    data: XOR<VipakaUpdateWithoutFoodVipakaInput, VipakaUncheckedUpdateWithoutFoodVipakaInput>
  }

  export type VipakaUpdateWithoutFoodVipakaInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VipakaUncheckedUpdateWithoutFoodVipakaInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCreateWithoutFoodDigestibilityInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutFoodDigestibilityInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutFoodDigestibilityInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutFoodDigestibilityInput, FoodUncheckedCreateWithoutFoodDigestibilityInput>
  }

  export type DigestibilityCreateWithoutFoodDigestibilityInput = {
    digestibility_id?: string
    name: string
  }

  export type DigestibilityUncheckedCreateWithoutFoodDigestibilityInput = {
    digestibility_id?: string
    name: string
  }

  export type DigestibilityCreateOrConnectWithoutFoodDigestibilityInput = {
    where: DigestibilityWhereUniqueInput
    create: XOR<DigestibilityCreateWithoutFoodDigestibilityInput, DigestibilityUncheckedCreateWithoutFoodDigestibilityInput>
  }

  export type FoodUpsertWithoutFoodDigestibilityInput = {
    update: XOR<FoodUpdateWithoutFoodDigestibilityInput, FoodUncheckedUpdateWithoutFoodDigestibilityInput>
    create: XOR<FoodCreateWithoutFoodDigestibilityInput, FoodUncheckedCreateWithoutFoodDigestibilityInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutFoodDigestibilityInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutFoodDigestibilityInput, FoodUncheckedUpdateWithoutFoodDigestibilityInput>
  }

  export type FoodUpdateWithoutFoodDigestibilityInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutFoodDigestibilityInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type DigestibilityUpsertWithoutFoodDigestibilityInput = {
    update: XOR<DigestibilityUpdateWithoutFoodDigestibilityInput, DigestibilityUncheckedUpdateWithoutFoodDigestibilityInput>
    create: XOR<DigestibilityCreateWithoutFoodDigestibilityInput, DigestibilityUncheckedCreateWithoutFoodDigestibilityInput>
    where?: DigestibilityWhereInput
  }

  export type DigestibilityUpdateToOneWithWhereWithoutFoodDigestibilityInput = {
    where?: DigestibilityWhereInput
    data: XOR<DigestibilityUpdateWithoutFoodDigestibilityInput, DigestibilityUncheckedUpdateWithoutFoodDigestibilityInput>
  }

  export type DigestibilityUpdateWithoutFoodDigestibilityInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DigestibilityUncheckedUpdateWithoutFoodDigestibilityInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CuisineCreateWithoutRecipeInput = {
    cuisine_id?: string
    name: string
  }

  export type CuisineUncheckedCreateWithoutRecipeInput = {
    cuisine_id?: string
    name: string
  }

  export type CuisineCreateOrConnectWithoutRecipeInput = {
    where: CuisineWhereUniqueInput
    create: XOR<CuisineCreateWithoutRecipeInput, CuisineUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateWithoutRecipeInput = {
    quantity: number
    food: FoodCreateNestedOneWithoutRecipeIngredientInput
  }

  export type RecipeIngredientUncheckedCreateWithoutRecipeInput = {
    food_id: string
    quantity: number
  }

  export type RecipeIngredientCreateOrConnectWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateManyRecipeInputEnvelope = {
    data: RecipeIngredientCreateManyRecipeInput | RecipeIngredientCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type DietChartRecipeCreateWithoutRecipeInput = {
    mealTime: $Enums.MealTime
    quantity?: number | null
    dietChart: DietChartCreateNestedOneWithoutDietChartRecipeInput
    food?: FoodCreateNestedOneWithoutDietChartRecipeInput
  }

  export type DietChartRecipeUncheckedCreateWithoutRecipeInput = {
    chart_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type DietChartRecipeCreateOrConnectWithoutRecipeInput = {
    where: DietChartRecipeWhereUniqueInput
    create: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput>
  }

  export type DietChartRecipeCreateManyRecipeInputEnvelope = {
    data: DietChartRecipeCreateManyRecipeInput | DietChartRecipeCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type CuisineUpsertWithoutRecipeInput = {
    update: XOR<CuisineUpdateWithoutRecipeInput, CuisineUncheckedUpdateWithoutRecipeInput>
    create: XOR<CuisineCreateWithoutRecipeInput, CuisineUncheckedCreateWithoutRecipeInput>
    where?: CuisineWhereInput
  }

  export type CuisineUpdateToOneWithWhereWithoutRecipeInput = {
    where?: CuisineWhereInput
    data: XOR<CuisineUpdateWithoutRecipeInput, CuisineUncheckedUpdateWithoutRecipeInput>
  }

  export type CuisineUpdateWithoutRecipeInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CuisineUncheckedUpdateWithoutRecipeInput = {
    cuisine_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutRecipeInput>
  }

  export type DietChartRecipeUpsertWithWhereUniqueWithoutRecipeInput = {
    where: DietChartRecipeWhereUniqueInput
    update: XOR<DietChartRecipeUpdateWithoutRecipeInput, DietChartRecipeUncheckedUpdateWithoutRecipeInput>
    create: XOR<DietChartRecipeCreateWithoutRecipeInput, DietChartRecipeUncheckedCreateWithoutRecipeInput>
  }

  export type DietChartRecipeUpdateWithWhereUniqueWithoutRecipeInput = {
    where: DietChartRecipeWhereUniqueInput
    data: XOR<DietChartRecipeUpdateWithoutRecipeInput, DietChartRecipeUncheckedUpdateWithoutRecipeInput>
  }

  export type DietChartRecipeUpdateManyWithWhereWithoutRecipeInput = {
    where: DietChartRecipeScalarWhereInput
    data: XOR<DietChartRecipeUpdateManyMutationInput, DietChartRecipeUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeCreateWithoutRecipeIngredientInput = {
    recipe_id?: string
    name: string
    Cuisine: CuisineCreateNestedOneWithoutRecipeInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutRecipeIngredientInput = {
    recipe_id?: string
    name: string
    cuisine_id: string
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutRecipeIngredientInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutRecipeIngredientInput, RecipeUncheckedCreateWithoutRecipeIngredientInput>
  }

  export type FoodCreateWithoutRecipeIngredientInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutRecipeIngredientInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    DietChartRecipe?: DietChartRecipeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutRecipeIngredientInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutRecipeIngredientInput, FoodUncheckedCreateWithoutRecipeIngredientInput>
  }

  export type RecipeUpsertWithoutRecipeIngredientInput = {
    update: XOR<RecipeUpdateWithoutRecipeIngredientInput, RecipeUncheckedUpdateWithoutRecipeIngredientInput>
    create: XOR<RecipeCreateWithoutRecipeIngredientInput, RecipeUncheckedCreateWithoutRecipeIngredientInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutRecipeIngredientInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutRecipeIngredientInput, RecipeUncheckedUpdateWithoutRecipeIngredientInput>
  }

  export type RecipeUpdateWithoutRecipeIngredientInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Cuisine?: CuisineUpdateOneRequiredWithoutRecipeNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutRecipeIngredientInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine_id?: StringFieldUpdateOperationsInput | string
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodUpsertWithoutRecipeIngredientInput = {
    update: XOR<FoodUpdateWithoutRecipeIngredientInput, FoodUncheckedUpdateWithoutRecipeIngredientInput>
    create: XOR<FoodCreateWithoutRecipeIngredientInput, FoodUncheckedCreateWithoutRecipeIngredientInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutRecipeIngredientInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutRecipeIngredientInput, FoodUncheckedUpdateWithoutRecipeIngredientInput>
  }

  export type FoodUpdateWithoutRecipeIngredientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutRecipeIngredientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type DietChartRecipeCreateWithoutDietChartInput = {
    mealTime: $Enums.MealTime
    quantity?: number | null
    recipe: RecipeCreateNestedOneWithoutDietChartRecipeInput
    food?: FoodCreateNestedOneWithoutDietChartRecipeInput
  }

  export type DietChartRecipeUncheckedCreateWithoutDietChartInput = {
    recipe_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type DietChartRecipeCreateOrConnectWithoutDietChartInput = {
    where: DietChartRecipeWhereUniqueInput
    create: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput>
  }

  export type DietChartRecipeCreateManyDietChartInputEnvelope = {
    data: DietChartRecipeCreateManyDietChartInput | DietChartRecipeCreateManyDietChartInput[]
    skipDuplicates?: boolean
  }

  export type DietChartRecipeUpsertWithWhereUniqueWithoutDietChartInput = {
    where: DietChartRecipeWhereUniqueInput
    update: XOR<DietChartRecipeUpdateWithoutDietChartInput, DietChartRecipeUncheckedUpdateWithoutDietChartInput>
    create: XOR<DietChartRecipeCreateWithoutDietChartInput, DietChartRecipeUncheckedCreateWithoutDietChartInput>
  }

  export type DietChartRecipeUpdateWithWhereUniqueWithoutDietChartInput = {
    where: DietChartRecipeWhereUniqueInput
    data: XOR<DietChartRecipeUpdateWithoutDietChartInput, DietChartRecipeUncheckedUpdateWithoutDietChartInput>
  }

  export type DietChartRecipeUpdateManyWithWhereWithoutDietChartInput = {
    where: DietChartRecipeScalarWhereInput
    data: XOR<DietChartRecipeUpdateManyMutationInput, DietChartRecipeUncheckedUpdateManyWithoutDietChartInput>
  }

  export type DietChartCreateWithoutDietChartRecipeInput = {
    chart_id?: string
    name: string
    description?: string | null
  }

  export type DietChartUncheckedCreateWithoutDietChartRecipeInput = {
    chart_id?: string
    name: string
    description?: string | null
  }

  export type DietChartCreateOrConnectWithoutDietChartRecipeInput = {
    where: DietChartWhereUniqueInput
    create: XOR<DietChartCreateWithoutDietChartRecipeInput, DietChartUncheckedCreateWithoutDietChartRecipeInput>
  }

  export type RecipeCreateWithoutDietChartRecipeInput = {
    recipe_id?: string
    name: string
    Cuisine: CuisineCreateNestedOneWithoutRecipeInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutDietChartRecipeInput = {
    recipe_id?: string
    name: string
    cuisine_id: string
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutDietChartRecipeInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutDietChartRecipeInput, RecipeUncheckedCreateWithoutDietChartRecipeInput>
  }

  export type FoodCreateWithoutDietChartRecipeInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateWithoutDietChartRecipeInput = {
    food_id?: string
    name: string
    hindi_name?: string | null
    FoodNutrient?: FoodNutrientUncheckedCreateNestedManyWithoutFoodInput
    FoodRasa?: FoodRasaUncheckedCreateNestedManyWithoutFoodInput
    FoodGuna?: FoodGunaUncheckedCreateNestedManyWithoutFoodInput
    FoodDosha?: FoodDoshaUncheckedCreateNestedManyWithoutFoodInput
    FoodVirya?: FoodViryaUncheckedCreateNestedManyWithoutFoodInput
    FoodVipaka?: FoodVipakaUncheckedCreateNestedManyWithoutFoodInput
    FoodDigestibility?: FoodDigestibilityUncheckedCreateNestedManyWithoutFoodInput
    RecipeIngredient?: RecipeIngredientUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodCreateOrConnectWithoutDietChartRecipeInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutDietChartRecipeInput, FoodUncheckedCreateWithoutDietChartRecipeInput>
  }

  export type DietChartUpsertWithoutDietChartRecipeInput = {
    update: XOR<DietChartUpdateWithoutDietChartRecipeInput, DietChartUncheckedUpdateWithoutDietChartRecipeInput>
    create: XOR<DietChartCreateWithoutDietChartRecipeInput, DietChartUncheckedCreateWithoutDietChartRecipeInput>
    where?: DietChartWhereInput
  }

  export type DietChartUpdateToOneWithWhereWithoutDietChartRecipeInput = {
    where?: DietChartWhereInput
    data: XOR<DietChartUpdateWithoutDietChartRecipeInput, DietChartUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type DietChartUpdateWithoutDietChartRecipeInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DietChartUncheckedUpdateWithoutDietChartRecipeInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpsertWithoutDietChartRecipeInput = {
    update: XOR<RecipeUpdateWithoutDietChartRecipeInput, RecipeUncheckedUpdateWithoutDietChartRecipeInput>
    create: XOR<RecipeCreateWithoutDietChartRecipeInput, RecipeUncheckedCreateWithoutDietChartRecipeInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutDietChartRecipeInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutDietChartRecipeInput, RecipeUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type RecipeUpdateWithoutDietChartRecipeInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Cuisine?: CuisineUpdateOneRequiredWithoutRecipeNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutDietChartRecipeInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine_id?: StringFieldUpdateOperationsInput | string
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodUpsertWithoutDietChartRecipeInput = {
    update: XOR<FoodUpdateWithoutDietChartRecipeInput, FoodUncheckedUpdateWithoutDietChartRecipeInput>
    create: XOR<FoodCreateWithoutDietChartRecipeInput, FoodUncheckedCreateWithoutDietChartRecipeInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutDietChartRecipeInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutDietChartRecipeInput, FoodUncheckedUpdateWithoutDietChartRecipeInput>
  }

  export type FoodUpdateWithoutDietChartRecipeInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateWithoutDietChartRecipeInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hindi_name?: NullableStringFieldUpdateOperationsInput | string | null
    FoodNutrient?: FoodNutrientUncheckedUpdateManyWithoutFoodNestedInput
    FoodRasa?: FoodRasaUncheckedUpdateManyWithoutFoodNestedInput
    FoodGuna?: FoodGunaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDosha?: FoodDoshaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVirya?: FoodViryaUncheckedUpdateManyWithoutFoodNestedInput
    FoodVipaka?: FoodVipakaUncheckedUpdateManyWithoutFoodNestedInput
    FoodDigestibility?: FoodDigestibilityUncheckedUpdateManyWithoutFoodNestedInput
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type DoctorPatientCreateManyDoctorInput = {
    patient_id: string
  }

  export type DoctorPatientUpdateWithoutDoctorInput = {
    patient?: PatientUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateWithoutDoctorInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorPatientUncheckedUpdateManyWithoutDoctorInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaCreateManyPatientInput = {
    dosha_id: string
  }

  export type DoctorPatientCreateManyPatientInput = {
    doctor_id: string
  }

  export type PatientDoshaUpdateWithoutPatientInput = {
    dosha?: DoshaUpdateOneRequiredWithoutPatientDoshaNestedInput
  }

  export type PatientDoshaUncheckedUpdateWithoutPatientInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaUncheckedUpdateManyWithoutPatientInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorPatientUpdateWithoutPatientInput = {
    doctor?: DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateWithoutPatientInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorPatientUncheckedUpdateManyWithoutPatientInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateManyCuisineInput = {
    recipe_id?: string
    name: string
  }

  export type RecipeUpdateWithoutCuisineInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RecipeIngredient?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    DietChartRecipe?: DietChartRecipeUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutCuisineInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RecipeIngredient?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    DietChartRecipe?: DietChartRecipeUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutCuisineInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodNutrientCreateManyFoodInput = {
    nutrient_id: string
    amount: number
  }

  export type FoodRasaCreateManyFoodInput = {
    rasa_id: string
  }

  export type FoodGunaCreateManyFoodInput = {
    guna_id: string
  }

  export type FoodDoshaCreateManyFoodInput = {
    dosha_id: string
  }

  export type FoodViryaCreateManyFoodInput = {
    virya_id: string
  }

  export type FoodVipakaCreateManyFoodInput = {
    vipaka_id: string
  }

  export type FoodDigestibilityCreateManyFoodInput = {
    digestibility_id: string
  }

  export type RecipeIngredientCreateManyFoodInput = {
    recipe_id: string
    quantity: number
  }

  export type DietChartRecipeCreateManyFoodInput = {
    chart_id: string
    recipe_id: string
    mealTime: $Enums.MealTime
    quantity?: number | null
  }

  export type FoodNutrientUpdateWithoutFoodInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    nutrient?: NutrientUpdateOneRequiredWithoutFoodNutrientNestedInput
  }

  export type FoodNutrientUncheckedUpdateWithoutFoodInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodNutrientUncheckedUpdateManyWithoutFoodInput = {
    nutrient_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodRasaUpdateWithoutFoodInput = {
    rasa?: RasaUpdateOneRequiredWithoutFoodRasaNestedInput
  }

  export type FoodRasaUncheckedUpdateWithoutFoodInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodRasaUncheckedUpdateManyWithoutFoodInput = {
    rasa_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaUpdateWithoutFoodInput = {
    guna?: GunaUpdateOneRequiredWithoutFoodGunaNestedInput
  }

  export type FoodGunaUncheckedUpdateWithoutFoodInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaUncheckedUpdateManyWithoutFoodInput = {
    guna_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaUpdateWithoutFoodInput = {
    dosha?: DoshaUpdateOneRequiredWithoutFoodDoshaNestedInput
  }

  export type FoodDoshaUncheckedUpdateWithoutFoodInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaUncheckedUpdateManyWithoutFoodInput = {
    dosha_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaUpdateWithoutFoodInput = {
    virya?: ViryaUpdateOneRequiredWithoutFoodViryaNestedInput
  }

  export type FoodViryaUncheckedUpdateWithoutFoodInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaUncheckedUpdateManyWithoutFoodInput = {
    virya_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaUpdateWithoutFoodInput = {
    vipaka?: VipakaUpdateOneRequiredWithoutFoodVipakaNestedInput
  }

  export type FoodVipakaUncheckedUpdateWithoutFoodInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaUncheckedUpdateManyWithoutFoodInput = {
    vipaka_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityUpdateWithoutFoodInput = {
    digestibility?: DigestibilityUpdateOneRequiredWithoutFoodDigestibilityNestedInput
  }

  export type FoodDigestibilityUncheckedUpdateWithoutFoodInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityUncheckedUpdateManyWithoutFoodInput = {
    digestibility_id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientUpdateWithoutFoodInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutRecipeIngredientNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutFoodInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutFoodInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type DietChartRecipeUpdateWithoutFoodInput = {
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    dietChart?: DietChartUpdateOneRequiredWithoutDietChartRecipeNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutDietChartRecipeNestedInput
  }

  export type DietChartRecipeUncheckedUpdateWithoutFoodInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutFoodInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FoodNutrientCreateManyNutrientInput = {
    food_id: string
    amount: number
  }

  export type RdaCreateManyNutrientInput = {
    rda_id?: string
    age_group: $Enums.AgeGroup
    gender: $Enums.Gender
    amount: number
  }

  export type FoodNutrientUpdateWithoutNutrientInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    food?: FoodUpdateOneRequiredWithoutFoodNutrientNestedInput
  }

  export type FoodNutrientUncheckedUpdateWithoutNutrientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodNutrientUncheckedUpdateManyWithoutNutrientInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RdaUpdateWithoutNutrientInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RdaUncheckedUpdateWithoutNutrientInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RdaUncheckedUpdateManyWithoutNutrientInput = {
    rda_id?: StringFieldUpdateOperationsInput | string
    age_group?: EnumAgeGroupFieldUpdateOperationsInput | $Enums.AgeGroup
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodRasaCreateManyRasaInput = {
    food_id: string
  }

  export type FoodRasaUpdateWithoutRasaInput = {
    food?: FoodUpdateOneRequiredWithoutFoodRasaNestedInput
  }

  export type FoodRasaUncheckedUpdateWithoutRasaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodRasaUncheckedUpdateManyWithoutRasaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaCreateManyGunaInput = {
    food_id: string
  }

  export type FoodGunaUpdateWithoutGunaInput = {
    food?: FoodUpdateOneRequiredWithoutFoodGunaNestedInput
  }

  export type FoodGunaUncheckedUpdateWithoutGunaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodGunaUncheckedUpdateManyWithoutGunaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaCreateManyDoshaInput = {
    food_id: string
  }

  export type PatientDoshaCreateManyDoshaInput = {
    patient_id: string
  }

  export type FoodDoshaUpdateWithoutDoshaInput = {
    food?: FoodUpdateOneRequiredWithoutFoodDoshaNestedInput
  }

  export type FoodDoshaUncheckedUpdateWithoutDoshaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDoshaUncheckedUpdateManyWithoutDoshaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaUpdateWithoutDoshaInput = {
    patient?: PatientUpdateOneRequiredWithoutPatientDoshaNestedInput
  }

  export type PatientDoshaUncheckedUpdateWithoutDoshaInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type PatientDoshaUncheckedUpdateManyWithoutDoshaInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaCreateManyViryaInput = {
    food_id: string
  }

  export type FoodViryaUpdateWithoutViryaInput = {
    food?: FoodUpdateOneRequiredWithoutFoodViryaNestedInput
  }

  export type FoodViryaUncheckedUpdateWithoutViryaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodViryaUncheckedUpdateManyWithoutViryaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaCreateManyVipakaInput = {
    food_id: string
  }

  export type FoodVipakaUpdateWithoutVipakaInput = {
    food?: FoodUpdateOneRequiredWithoutFoodVipakaNestedInput
  }

  export type FoodVipakaUncheckedUpdateWithoutVipakaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodVipakaUncheckedUpdateManyWithoutVipakaInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityCreateManyDigestibilityInput = {
    food_id: string
  }

  export type FoodDigestibilityUpdateWithoutDigestibilityInput = {
    food?: FoodUpdateOneRequiredWithoutFoodDigestibilityNestedInput
  }

  export type FoodDigestibilityUncheckedUpdateWithoutDigestibilityInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type FoodDigestibilityUncheckedUpdateManyWithoutDigestibilityInput = {
    food_id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientCreateManyRecipeInput = {
    food_id: string
    quantity: number
  }

  export type DietChartRecipeCreateManyRecipeInput = {
    chart_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type RecipeIngredientUpdateWithoutRecipeInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    food?: FoodUpdateOneRequiredWithoutRecipeIngredientNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutRecipeInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeInput = {
    food_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
  }

  export type DietChartRecipeUpdateWithoutRecipeInput = {
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    dietChart?: DietChartUpdateOneRequiredWithoutDietChartRecipeNestedInput
    food?: FoodUpdateOneWithoutDietChartRecipeNestedInput
  }

  export type DietChartRecipeUncheckedUpdateWithoutRecipeInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutRecipeInput = {
    chart_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeCreateManyDietChartInput = {
    recipe_id: string
    mealTime: $Enums.MealTime
    food_id?: string | null
    quantity?: number | null
  }

  export type DietChartRecipeUpdateWithoutDietChartInput = {
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    recipe?: RecipeUpdateOneRequiredWithoutDietChartRecipeNestedInput
    food?: FoodUpdateOneWithoutDietChartRecipeNestedInput
  }

  export type DietChartRecipeUncheckedUpdateWithoutDietChartInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietChartRecipeUncheckedUpdateManyWithoutDietChartInput = {
    recipe_id?: StringFieldUpdateOperationsInput | string
    mealTime?: EnumMealTimeFieldUpdateOperationsInput | $Enums.MealTime
    food_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}